#!/bin/sh
# \
exec tclsh "$0" "$@"
# This software is copyrighted 2004, 2005 by G. Andrew Mangogna.  The following
# terms apply to all files associated with the software unless explicitly
# disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
# 
#  *++
# MODULE:
#   ral.test -- test cases for the Tcl Relational Algebra Library
# 
# ABSTRACT:
#   This file contains a set of test cases suitable for execution via
#   "tcltest" to test the code associated with the TCL Relational
#   Algebra library.
# 
# $RCSfile: ral.test,v $
# $Revision: 1.16 $
# $Date: 2006/05/19 04:54:32 $
#  *--

package require tcltest 2.2
eval tcltest::configure $argv

global env
set env(LD_LIBRARY_PATH) [file normalize ..]:/usr/local/ActiveTcl/lib
set ::auto_path [linsert $::auto_path 0 [file normalize ..]]
package require ral 0.8

proc tupleMatch {expected actual} {
    return [::ral::tuple equal $expected $actual]
}

proc relationMatch {expected actual} {
    return [::ral::relation is $expected == $actual]
}

proc dictMatch {expected actual} {
    if {[dict size $expected] != [dict size $actual]} {
	return 0
    }
    dict for {exKey exVal} $expected {
	if {[dict get $actual $exKey] != $exVal} {
	    return 0
	}
    }
    return 1
}

proc ::tcl::mathfunc::rcount {relation} {
    return [::ral::relation cardinality $relation]
}

proc ::tcl::mathfunc::rsum {relation attr} {
    set result 0
    ::ral::relation foreach t $relation {
	set result [expr {$result + [::ral::tuple extract $t $attr]}]
    }
    return $result
}

proc ::tcl::mathfunc::ravg {relation attr} {
    return [expr {rsum($relation, $attr) /\
	[::ral::relation cardinality $relation]}]
}

namespace eval ::ral::test {
    namespace import ::tcltest::*
    namespace import ::ral::*

    customMatch tuple tupleMatch
    customMatch relation relationMatch
    customMatch dict dictMatch

    set DEE {Relation {} {{}} {{}}}
    set DUM {Relation {} {{}} {}}

    # The Date example relations.
    set S {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
	{
	    {S# S1 SNAME Smith STATUS 20 CITY London}
	    {S# S2 SNAME Jones STATUS 10 CITY Paris}
	    {S# S3 SNAME Blake STATUS 30 CITY Paris}
	    {S# S4 SNAME Clark STATUS 20 CITY London}
	    {S# S5 SNAME Adams STATUS 30 CITY Athens}
	}
    }
    set P {
	Relation
	{P# string PNAME string COLOR string WEIGHT double CITY string}
	P#
	{
	    {P# P1 PNAME Nut COLOR Red WEIGHT 12.0 CITY London}
	    {P# P2 PNAME Bolt COLOR Green WEIGHT 17.0 CITY Paris}
	    {P# P3 PNAME Screw COLOR Blue WEIGHT 17.0 CITY Oslo}
	    {P# P4 PNAME Screw COLOR Red WEIGHT 14.0 CITY London}
	    {P# P5 PNAME Cam COLOR Blue WEIGHT 12.0 CITY Paris}
	    {P# P6 PNAME Cog COLOR Red WEIGHT 19.0 CITY London}
	}
    }
    set SP {
	Relation
	{S# string P# string QTY int}
	{{S# P#}}
	{
	    {S# S1 P# P1 QTY 300}
	    {S# S1 P# P2 QTY 200}
	    {S# S1 P# P3 QTY 400}
	    {S# S1 P# P4 QTY 200}
	    {S# S1 P# P5 QTY 100}
	    {S# S1 P# P6 QTY 100}
	    {S# S2 P# P1 QTY 300}
	    {S# S2 P# P2 QTY 400}
	    {S# S3 P# P2 QTY 200}
	    {S# S4 P# P2 QTY 200}
	    {S# S4 P# P4 QTY 300}
	    {S# S4 P# P5 QTY 400}
	}
    }
    # Some examples from the manual pages.
    set DOG {
	Relation
	{DogName string Breed string}
	DogName
	{
	    {DogName Fido Breed Poodle}
	    {DogName Sam Breed Collie}
	    {DogName Spot Breed Terrier}
	    {DogName Rover Breed Retriever}
	    {DogName Fred Breed Spaniel}
	    {DogName Jumper Breed Mutt}
	}
    }
    set OWNER {
	Relation
	{OwnerName string Age int City string}
	OwnerName
	{
	    {OwnerName Sue Age 24 City Cupertino}
	    {OwnerName George Age 35 City Sunnyvale}
	    {OwnerName Alice Age 30 City {San Jose}}
	    {OwnerName Mike Age 50 City {San Jose}}
	    {OwnerName Jim Age 42 City {San Francisco}}
	}
    }
    set OWNERSHIP {
	Relation
	{OwnerName string DogName string Acquired string}
	{{OwnerName DogName}}
	{
	    {OwnerName Sue DogName Fido Acquired 2001}
	    {OwnerName Sue DogName Sam Acquired 2000}
	    {OwnerName George DogName Fido Acquired 2001}
	    {OwnerName George DogName Sam Acquired 2000}
	    {OwnerName Alice DogName Spot Acquired 2001}
	    {OwnerName Mike DogName Rover Acquired 2002}
	    {OwnerName Jim DogName Fred Acquired 2003}
	}
    }

    # Basic tests on the tuple string representation
    test tuple-strrep-1.0 {no attributes} -body {
	tuple degree {Tuple {} {}}
    } -result 0

    test tuple-strrep-2.0 {single attributes} -body {
	tuple degree {Tuple {Name string} {Name Fred}}
    } -result 1

    test tuple-strrep-3.0 {multiple attributes} -body {
	tuple degree {Tuple {Name string Num int Street string}\
	    {Name Fred Num 100 Street Main}}
    } -result 3

    test tuple-strrep-4.0 {Tuple valued attribute} -body {
	tuple degree {Tuple {Name string Addr {Tuple {Num int Street string}}}\
	    {Name Fred Addr {Num 100 Street Main}}}
    } -result 2

    test tuple-strrep-5.0 {other data types} -body {
	tuple degree {Tuple {Name string Status int Position double}\
	    {Name Fred Status 20 Position 1}}
    } -result 3

    test tuple-strrep-5.1 {other data types - wrong values} -body {
	tuple degree {Tuple {Name string Status int Position double}\
	    {Name Fred Status 20.0 Position 1}}
    } -result {bad value type for value, "20.0"} -returnCodes error

    test tuple-strrep-5.2 {other data types - wrong values} -body {
	tuple degree {Tuple {Name string Status int Position double}\
	    {Name Fred Status 20 Position foo}}
    } -result {bad value type for value, "foo"} -returnCodes error

    test tuple-strrep-6.0 {bad format -- extra list element} -body {
	tuple degree {Tuple {Name string} {Name Fred} {}}
    } -result {bad tuple value format, "Tuple {Name string} {Name Fred} {}"}\
    -returnCodes error

    test tuple-strrep-6.1 {bad format -- missing list element} -body {
	tuple degree {Tuple Name}
    } -result {bad tuple value format, "Tuple Name"} -returnCodes error

    test tuple-strrep-6.2 {bad format -- bad keyword} -body {
	tuple degree {Tupel {Name string} {Name Fred}}
    } -result {bad tuple type keyword, "Tupel"}\
    -returnCodes error

    test tuple-strrep-6.3 {bad format -- bad heading} -body {
	tuple degree {Tuple {Name string foo} {Name Fred}}
    } -result {bad tuple heading format, "Name string foo"} -returnCodes error

    test tuple-strrep-6.4 {bad format -- duplicate attribute names} -body {
	tuple degree {Tuple {Name string Name int} {Name Fred Name George}}
    } -result {duplicate attribute name, "Name"} -returnCodes error

    test tuple-strrep-6.5 {bad format -- insufficient values} -body {
	tuple degree {Tuple {Name string Num int Street string}\
	    {Name Fred Num 100}}
    } -result {wrong number of attributes specified, "Name Fred Num 100"}\
    -returnCodes error

    test tuple-strrep-6.6 {bad format -- too many values} -body {
	tuple degree {Tuple {Name string Num int Street string}\
	    {Name Fred Num 100 Street Main Num 200}}
    } -result {wrong number of attributes specified,\
	"Name Fred Num 100 Street Main Num 200"}\
    -returnCodes error

    test tuple-strrep-6.7 {bad format -- value for unknown attribute} -body {
	tuple degree {Tuple {Name string Num int Street string}\
	    {Name Fred Num 100 City Main}}
    } -result {unknown attribute name, "City"} -returnCodes error

    # Tuple Tests

    # tuple assign subcommand
    test tuple-assign-1.0 {single attribute} -body {
	tuple assign {Tuple {Name string} {Name Andrew}}
	expr {$Name eq "Andrew"}
    } -result 1

    test tuple-assign-2.0 {multiple attributes} -body {
	tuple assign {Tuple {Name string Age int} {Name Andrew Age 20}}
	expr {$Name eq "Andrew" && $Age == 20}
    } -result 1

    test tuple-assign-3.0 {no attributes} -body {
	tuple assign {Tuple {} {}}
    } -result 0

    # tuple create subcommand
    test tuple-create-1.0 {single attribute} -body {
	tuple create {Name string} {Name Andrew}
    } -result {Tuple {Name string} {Name Andrew}} -match tuple

    test tuple-create-2.0 {multiple attributes} -body {
	set h {Name string Age int}
	tuple create $h {Name Andrew Age 20}
    } -result {Tuple {Name string Age int} {Name Andrew Age 20}} -match tuple

    test tuple-create-3.0 {bad format} -body {
	set h {Name string Age int}
	tuple create $h {Name Andrew foo}
    } -result {bad tuple value format, "Name Andrew foo"} -returnCodes error

    test tuple-create-4.0 {unknown attribute} -body {
	set h {Name string Age int}
	tuple create $h {Name Andrew foo 20}
    } -result {unknown attribute name, "foo"} -returnCodes error

    test tuple-create-5.0 {bad value type} -body {
	set h {Name string Age int}
	tuple create $h {Name Andrew Age foo}
    } -result {bad value type for value, "foo"} -returnCodes error

    test tuple-create-6.0 {multiple assignment} -body {
	set h {Name string Age int}
	tuple create $h {Name Andrew Name foo}
    } -result {duplicate attribute name, "Name"} -returnCodes error

    test tuple-create-7.0 {different ordering} -body {
	set h {Name string Age int}
	tuple create $h {Age 20 Name Andrew}
    } -result {Tuple {Name string Age int} {Name Andrew Age 20}}

    test tuple-create-8.0 {empty tuple} -body {
	tuple create {} {}
    } -result {Tuple {} {}} -match tuple

    # tuple degree subcommand
    test tuple-degree-1.0 {single attribute} -body {
	tuple degree {Tuple {Name string} {Name Andrew}}
    } -result 1

    test tuple-degree-2.0 {multiple attributes} -body {
	tuple degree {Tuple {Name string Age int} {Age 20 Name Andrew}}
    } -result 2

    test tuple-degree-3.0 {empty tuple} -body {
	tuple degree {Tuple {} {}}
    } -result 0

    # tuple eliminate subcommand
    test tuple-eliminate-1.0 {single attribute} -body {
	tuple eliminate {Tuple {Name string} {Name Andrew}} Name
    } -result {Tuple {} {}}

    test tuple-eliminate-2.0 {multiple attributes} -body {
	tuple eliminate {Tuple {Name string Age int Size double}\
	    {Name Andrew Age 20 Size 1.0}} Age Size
    } -result {Tuple {Name string} {Name Andrew}}

    test tuple-eliminate-3.0 {non-existent attribute} -body {
	tuple eliminate {Tuple {Name string Age int Size double}\
	    {Name Andrew Age 20 Size 1.0}} foo
    } -result {unknown attribute name, "foo"} -returnCodes error

    # tuple equal subcommand
    test tuple-equal-1.0 {single attribute, match} -body {
	set t1 {Tuple {Name string} {Name Andrew}}
	set t2 {Tuple {Name string} {Name Andrew}}
	tuple equal $t1 $t2
    } -result 1

    test tuple-equal-2.0 {multiple attributes, match} -body {
	set t1 {Tuple {Name string Age int} {Age 20 Name Andrew}}
	set t2 {Tuple {Name string Age int} {Name Andrew Age 20}}
	tuple equal $t1 $t2
    } -result 1

    test tuple-equal-3.0 {single attribute, value mismatch} -body {
	set t1 {Tuple {Name string} {Name Andrew}}
	set t2 {Tuple {Name string} {Name George}}
	tuple equal $t1 $t2
    } -result 0

    test tuple-equal-4.0 {single attribute, attribute name mismatch} -body {
	set t1 {Tuple {Name string} {Name Andrew}}
	set t2 {Tuple {name string} {name George}}
	tuple equal $t1 $t2
    } -result 0

    test tuple-equal-5.0 {single attribute, type mismatch} -body {
	set t1 {Tuple {Name string} {Name 20}}
	set t2 {Tuple {Name int} {Name 40}}
	tuple equal $t1 $t2
    } -result 0

    test tuple-equal-6.0 {multiple attributes, value mismatch} -body {
	set t1 {Tuple {Name string Age int} {Age 20 Name Andrew}}
	set t2 {Tuple {Name string Age int} {Name Andrew Age 30}}
	tuple equal $t1 $t2
    } -result 0

    test tuple-equal-7.0 {multiple attributes, match, out of order} -body {
	set t1 {Tuple {Name string Age int Size double}\
	    {Name Andrew Age 20 Size 1.0}}
	set t2 {Tuple {Size double Name string Age int}\
	    {Name Andrew Age 20 Size 1.0}}
	tuple equal $t1 $t2
    } -result 1

    test tuple-equal-8.0 {multiple attributes, match, value variations} -body {
	set t1 {Tuple {Name string Age int Size double}\
	    {Name Andrew Age 0x20 Size 12.30}}
	set t2 {Tuple {Size double Name string Age int}\
	    {Name Andrew Age 32 Size 1.23e1}}
	tuple equal $t1 $t2
    } -result 1

    # tuple extend subcommand
    test tuple-extend-1.0 {single attribute} -body {
	set t {Tuple {Name string} {Name Andrew}}
	tuple extend $t {Age int 20}
    } -result {Tuple {Name string Age int} {Name Andrew Age 20}} -match tuple

    test tuple-extend-2.0 {multiple attributes} -body {
	set t {Tuple {Name string} {Name Andrew}}
	tuple extend $t {Age int 20} {Size double 1.3}
    } -result {Tuple {Name string Age int Size double}\
	{Name Andrew Age 20 Size 1.3}} -match tuple

    test tuple-extend-3.0 {duplicate name} -body {
	set t {Tuple {Name string} {Name Andrew}}
	tuple extend $t {Name int 20}
    } -result {duplicate attribute name, "Name"} -returnCodes error

    test tuple-extend-4.0 {bad value} -body {
	set t {Tuple {Name string} {Name Andrew}}
	tuple extend $t {Age int foo}
    } -result {expected integer but got "foo"} -returnCodes error

    test tuple-extend-5.0 {bad type} -body {
	set t {Tuple {Name string} {Name Andrew}}
	tuple extend $t {Age foo foo}
    } -result {unknown data type, "foo"} -returnCodes error

    # tuple extract subcommand
    test tuple-extract-1.0 {single attribute} -body {
	set t {Tuple {Name string} {Name Andrew}}
	tuple extract $t Name
    } -result {Andrew}

    test tuple-extract-2.0 {multiple attributes} -body {
	set t {Tuple {Name string Age int Size double}\
	    {Name Andrew Age 20 Size 1.3}}
	tuple extract $t Age Size
    } -result {20 1.3}

    test tuple-extract-3.0 {unknown attribute} -body {
	set t {Tuple {Name string Age int Size double}\
	    {Name Andrew Age 20 Size 1.3}}
	tuple extract $t foo
    } -result {unknown attribute name, "foo"} -returnCodes error

    # tuple get subcommand
    test tuple-get-1.0 {single attribute} -body {
	tuple get {Tuple {Name string} {Name Andrew}}
    } -result {Name Andrew}

    test tuple-get-2.0 {multiple attributes} -body {
	tuple get {Tuple {Name string Age int Size double}\
	    {Name Andrew Age 20 Size 1.3}}
    } -result {Name Andrew Age 20 Size 1.3}

    # tuple heading subcommand
    test tuple-heading-1.0 {single attribute} -setup {
	set t [tuple create {Name string} {Name Andrew}]
    } -body {
	tuple heading $t
    } -result {Tuple {Name string}}

    test tuple-heading-2.0 {multiple attributes} -setup {
	set t [tuple create {Name string Age int Size double}\
	    {Name Andrew Age 20 Size 3.0}]
    } -body {
	tuple heading $t
    } -result {Tuple {Name string Age int Size double}}

    # tuple project subcommand
    test tuple-project-1.0 {single attribute} -body {
	set t {Tuple {Name string} {Name Andrew}}
	tuple project $t Name
    } -result {Tuple {Name string} {Name Andrew}} -match tuple

    test tuple-project-2.0 {multiple attributes} -body {
	set t {Tuple {Name string Age int Size double}\
	    {Name Andrew Age 20 Size 1.3}}
	tuple project $t Name Age
    } -result {Tuple {Name string Age int} {Name Andrew Age 20}} -match tuple

    test tuple-project-3.0 {project nothing} -body {
	set t {Tuple {Name string Age int} {Name Andrew Age 20}}
	tuple project $t
    } -result {Tuple {} {}} -match tuple

    test tuple-project-4.0 {project everything} -body {
	set t {Tuple {Name string Age int} {Name Andrew Age 20}}
	tuple project $t Name Age
    } -result {Tuple {Name string Age int} {Name Andrew Age 20}} -match tuple

    test tuple-project-5.0 {unknown attribute} -body {
	set t {Tuple {Name string Age int} {Name Andrew Age 20}}
	tuple project $t foo
    } -result {unknown attribute name, "foo"} -returnCodes error

    # tuple rename subcommand
    test tuple-rename-1.0 {single attribute} -setup {
	set t [tuple create {Name string} {Name Andrew}]
    } -body {
	tuple rename $t Name Age
    } -result {Tuple {Age string} {Age Andrew}} -match tuple

    test tuple-rename-2.0 {multiple attributes} -setup {
	set t [tuple create {Name string Age int} {Name Andrew Age 20}]
    } -body {
	tuple rename $t Name foo
    } -result {Tuple {foo string Age int} {foo Andrew Age 20}} -match tuple

    test tuple-rename-3.0 {unknown attribute} -setup {
	set t [tuple create {Name string Age int} {Name Andrew Age 20}]
    } -body {
	tuple rename $t foo Name
    } -result {unknown attribute name, "foo"} -returnCodes error

    test tuple-rename-4.0 {unpaired attributes} -setup {
	set t [tuple create {Name string Age int} {Name Andrew Age 20}]
    } -body {
	tuple rename $t foo Name bar
    } -result {bad list of pairs, "for oldname / newname arguments"}\
    -returnCodes error

    test tuple-rename-5.0 {multiple renamings} -setup {
	set t [tuple create {Name string Age int} {Name Andrew Age 20}]
    } -body {
	tuple rename $t Age bar Name foo
    } -result {Tuple {foo string bar int} {foo Andrew bar 20}} -match tuple

    test tuple-rename-6.0 {same attribute, multiple renamings} -setup {
	set t [tuple create {Name string Age int} {Name Andrew Age 20}]
    } -body {
	tuple rename $t Name foo foo bar bar baz
    } -result {Tuple {baz string Age int} {baz Andrew Age 20}} -match tuple

    test tuple-rename-7.0 {existing attribute} -setup {
	set t [tuple create {Name string Age int} {Name Andrew Age 20}]
    } -body {
	tuple rename $t Name Age
    } -result {duplicate attribute name, "Age"} -returnCodes error

    # tuple unwrap subcommand
    test tuple-unwrap-1.0 {unwrap multiple attributes} -setup {
	set t [tuple create\
	    {Name string\
		Address {Tuple {Number int Street string City string}}}\
	    {Name Andrew Address {Number 599 Street Blackwood City Sunnyvale}}]
    } -body {
	tuple unwrap $t Address
    } -result {Tuple {Name string Number int Street string City string}\
	{Name Andrew Number 599 Street Blackwood City Sunnyvale}}\
    -match tuple

    test tuple-unwrap-2.0 {unwrap single attribute} -setup {
	set t [tuple create\
	    {Name string Address {Tuple {Number int}}}\
	    {Name Andrew Address {Number 599}}]
    } -body {
	tuple unwrap $t Address
    } -result {Tuple {Name string Number int} {Name Andrew Number 599}}\
    -match tuple

    test tuple-unwrap-3.0 {unknown unwrap attribute} -setup {
	set t [tuple create\
	    {Name string\
		Address {Tuple {Number int Street string City string}}}\
	    {Name Andrew Address {Number 599 Street Blackwood City Sunnyvale}}]
    } -body {
	tuple unwrap $t foo
    } -result {unknown attribute name, "foo"} -returnCodes error

    test tuple-unwrap-4.0 {non-tuple unwrap attribute} -setup {
	set t [tuple create\
	    {Name string\
		Address {Tuple {Number int Street string City string}}}\
	    {Name Andrew Address {Number 599 Street Blackwood City Sunnyvale}}]
    } -body {
	tuple unwrap $t Name
    } -result {bad value type for value,\
	"attribute to unwrap must be of Tuple type"} -returnCodes error

    # tuple update subcommand
    test tuple-update-1.0 {single attribute} -setup {
	set t [tuple create {Name string Age int Size double}\
	    {Name Andrew Age 20 Size 3.0}]
    } -body {
	tuple update t {Age 40}
    } -result {Tuple {Name string Age int Size double}\
	    {Name Andrew Age 40 Size 3.0}} -match tuple

    test tuple-update-2.0 {multiple attributes} -setup {
	set t [tuple create {Name string Age int Size double}\
	    {Name Andrew Age 20 Size 3.0}]
    } -body {
	tuple update t {Age 40 Size 33.0}
    } -result {Tuple {Name string Age int Size double}\
	    {Name Andrew Age 40 Size 33.0}} -match tuple

    test tuple-update-3.0 {unknown attribute} -setup {
	set t [tuple create {Name string Age int Size double}\
	    {Name Andrew Age 20 Size 3.0}]
    } -body {
	tuple update t {foo 40}
    } -result {unknown attribute name, "foo"} -returnCodes error

    test tuple-update-4.0 {bad type} -setup {
	set t [tuple create {Name string Age int Size double}\
	    {Name Andrew Age 20 Size 3.0}]
    } -body {
	tuple update t {Age foo}
    } -result {bad value type for value, "foo"} -returnCodes error

    # tuple wrap subcommand
    test tuple-wrap-1.0 {wrap 1 attribute} -setup {
	set t [tuple create {Name string Age int Size double}\
	    {Age 20 Name Andrew Size 3.0}]
    } -body {
	tuple wrap $t Props {Age}
    } -result {Tuple {Name string Size double Props {Tuple {Age int}}}\
	{Name Andrew Size 3.0 Props {Age 20}}} -match tuple

    test tuple-wrap-2.0 {wrap multiple attributes} -setup {
	set t [tuple create {Name string Age int Size double}\
	    {Age 20 Name Andrew Size 3.0}]
    } -body {
	tuple wrap $t Props {Age Size}
    } -result {Tuple {Name string Props {Tuple {Age int Size double}}}\
	{Name Andrew Props {Age 20 Size 3.0}}} -match tuple

    test tuple-wrap-3.0 {wrap all attributes} -setup {
	set t [tuple create {Name string Age int Size double}\
	    {Age 20 Name Andrew Size 3.0}]
    } -body {
	tuple wrap $t Props {Name Age Size}
    } -result {Tuple {Props {Tuple {Name string Age int Size double}}}\
	{Props {Name Andrew Age 20 Size 3.0}}} -match tuple

    test tuple-wrap-4.0 {non-existent attribute to wrap} -setup {
	set t [tuple create {Name string Age int Size double}\
	    {Age 20 Name Andrew Size 3.0}]
    } -body {
	tuple wrap $t Props {foo}
    } -result {unknown attribute name, "foo"} -returnCodes error

    test tuple-wrap-5.0 {wrap same attribute multiple times} -setup {
	set t [tuple create {Name string Age int Size double}\
	    {Age 20 Name Andrew Size 3.0}]
    } -body {
	tuple wrap $t Props {Name Age Name}
    } -result {duplicate attribute name, "Name"} -returnCodes error

    test tuple-wrap-6.0 {wrap attribute is a duplicate} -setup {
	set t [tuple create {Name string Age int Size double}\
	    {Age 20 Name Andrew Size 3.0}]
    } -body {
	tuple wrap $t Size {Name Age}
    } -result {duplicate attribute name, "Size"} -returnCodes error

    # relation shimmering tests
    test relation-shimmer-1.0 {dum relation} -body {
	relation cardinality $DUM
	string length $DUM
	set DUM
    } -result {Relation {} {{}} {}} -match relation

    test relation-shimmer-2.0 {dee relation} -body {
	relation cardinality $DEE
	string length $DEE
	set DEE
    } -result {Relation {} {{}} {{}}} -match relation

    test relation-shimmer-3.0 {degree 1, cardinality 0} -body {
	set r {Relation {a1 string} a1 {}}
	relation cardinality $r
	string length $r
	set r
    } -result {Relation {a1 string} a1 {}} -match relation

    test relation-shimmer-3.1 {degree 1, cardinality 1} -body {
	set r {Relation {a1 string} a1 {{a1 foo}}}
	relation cardinality $r
	string length $r
	set r
    } -result {Relation {a1 string} a1 {{a1 foo}}} -match relation

    test relation-shimmer-3.2 {degree 1, cardinality 2} -body {
	set r {Relation {a1 string} a1 {{a1 foo} {a1 bar}}}
	relation cardinality $r
	string length $r
	set r
    } -result {Relation {a1 string} a1 {{a1 foo} {a1 bar}}} -match relation

    test relation-shimmer-4.0 {tuple attr, degree 1, cardinality 0} -body {
	set r {Relation {a1 {Tuple {t1 string t2 string}}} {a1} {}}
	relation cardinality $r
	string length $r
	set r
    } -result {Relation {a1 {Tuple {t1 string t2 string}}} a1 {}}\
    -match relation

    test relation-shimmer-4.1 {tuple attr, degree 1, cardinality 1} -body {
	set r {
	    Relation
	    {a1 {Tuple {t1 string t2 string}}}
	    a1
	    {
		{a1 {t1 foo t2 bar}}
	    }
	}
	relation cardinality $r
	string length $r
	set r
    } -result {
	Relation
	{a1 {Tuple {t1 string t2 string}}}
	a1
	{
	    {a1 {t1 foo t2 bar}}
	}
    } -match relation

    test relation-shimmer-4.2 {tuple attr, degree 1, cardinality 2} -body {
	set r {
	    Relation
	    {a1 {Tuple {t1 string t2 string}}}
	    a1
	    {
		{a1 {t1 foo t2 bar}}
		{a1 {t1 foo2 t2 bar2}}
	    }
	}
	relation cardinality $r
	string length $r
	set r
    } -result {
	Relation
	{a1 {Tuple {t1 string t2 string}}}
	a1
	{
	    {a1 {t1 foo t2 bar}}
	    {a1 {t1 foo2 t2 bar2}}
	}
    } -match relation

    test relation-shimmer-5.0 {relation attr, degree 1, cardinality 0} -body {
	set r {Relation {a1 {Relation {t1 string t2 string} {t1}}} {a1} {}}
	relation cardinality $r
	string length $r
	set r
    } -result {Relation {a1 {Relation {t1 string t2 string} t1}} a1 {}}\
    -match relation

    test relation-shimmer-5.1 {relation attr, degree 1, cardinality 1} -body {
	set r {
	    Relation
	    {a1 {Relation {t1 string t2 string} {t1}}}
	    a1
	    {
		{a1 {{t1 foo t2 bar}}}
	    }
	}
	relation cardinality $r
	string length $r
	set r
    } -result {
	Relation
	{a1 {Relation {t1 string t2 string} t1}}
	a1
	{
	    {a1 {{t1 foo t2 bar}}}
	}
    } -match relation

    test relation-shimmer-5.2 {relation attr, degree 1, cardinality 1} -body {
	set r {
	    Relation
	    {a1 {Relation {t1 string t2 string} {t1}}}
	    a1
	    {
		{a1 {{t1 foo t2 bar} {t1 foo2 t2 bar2}}}
	    }
	}
	relation cardinality $r
	string length $r
	set r
    } -result {
	Relation
	{a1 {Relation {t1 string t2 string} t1}}
	a1
	{
	    {a1 {{t1 foo t2 bar} {t1 foo2 t2 bar2}}}
	}
    } -match relation

    test relation-shimmer-6.0 {multiple identifiers} -body {
	set r {
	    Relation
	    {a1 string a2 string a3 string}
	    {a1 a2}
	    {
		{a1 a a2 b a3 c}
		{a1 d a2 e a3 f}
	    }
	}
	relation cardinality $r
	string length $r
	set r
    } -result {
	Relation
	{a1 string a2 string a3 string}
	{a1 a2}
	{
	    {a1 a a2 b a3 c}
	    {a1 d a2 e a3 f}
	}
    } -match relation

    # relation array subcommand
    test relation-array-1.0 {supplier number / city map} -body {
	relation array [relation project $S S# CITY] smap
	array get smap
    } -cleanup {
	unset smap
    } -result {
	    S1 London
	    S2 Paris
	    S3 Paris
	    S4 London
	    S5 Athens
    } -match dict

    # relation cardinality subcommand
    test relation-cardinality-1.0 {dum relation} -body {
	relation cardinality $DUM
    } -result 0

    test relation-cardinality-2.0 {dee relation} -body {
	relation cardinality $DEE
    } -result 1

    test relation-cardinality-3.0 {relation with 1 attribute} -body {
	relation cardinality {Relation {a1 string} a1 {}}
    } -result 0

    test relation-cardinality-3.0 {relation with 4 attributes} -body {
	relation cardinality $S
    } -result 5

    # relation choose subcommand
    test relation-choose-1.0 {match the only id} -body {
	set r {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	relation choose $r Name Fred
    } -result {Relation {Name string Age int City string} Name\
	{{Name Fred Age 10 City Saratoga}}} -match relation

    test relation-choose-2.0 {no match} -body {
	set r {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	relation choose $r Name Alice
    } -result {Relation {Name string Age int City string} Name {}}\
    -match relation

    test relation-choose-3.0 {bad identifier} -body {
	set r {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	relation choose $r City Sunnyvale
    } -result {attributes do not constitute an identifier, "during find operation"}\
    -returnCodes 1

    test relation-choose-4.0 {multiple identifiers} -body {
	set r {Relation {Name string Age int} {Name Age}\
	    {{Name Andrew Age 10} {Name George Age 20} {Name Fred Age 30}}}
	relation choose $r Age 30
    } -result {Relation {Name string Age int} {Name Age} {{Name Fred Age 30}}}\
    -match relation

    # relation degree subcommand
    test relation-degree-1.0 {dum relation} -body {
	relation degree $DUM
    } -result 0

    test relation-degree-2.0 {single attribute} -body {
	relation degree {Relation {Name string} Name {}}
    } -result 1

    test relation-degree-3.0 {multiple attributes} -body {
	relation degree $S
    } -result 4

    # relation eliminate subcommand
    test relation-eliminate-1.0 {single attribute} -body {
	set r1 {Relation\
	    {Name string Number int Street string IsMale string}\
	    Name\
	    {{Name Andrew Number 599 Street Blackwood IsMale true}\
	    {Name Jane Street Main Number 300 IsMale false}\
	    {Name Fred Street Maple Number 599 IsMale true}}}
	relation eliminate $r1 Name
    } -result {Relation {Number int Street string IsMale string} {{Number Street IsMale}} {{Number 599 Street Blackwood IsMale true} {Number 300 Street Main IsMale false} {Number 599 Street Maple IsMale true}}}\
    -match relation

    test relation-eliminate-2.0 {multiple attributes} -body {
	set r1 {Relation\
	    {Name string Number int Street string IsMale string}\
	    Name\
	    {{Name Andrew Number 599 Street Blackwood IsMale true}\
	    {Name Jane Street Main Number 300 IsMale false}\
	    {Name Fred Street Maple Number 599 IsMale true}}}
	relation eliminate $r1 Number IsMale
    } -result {Relation {Name string Street string} Name {{Name Andrew Street Blackwood} {Name Jane Street Main} {Name Fred Street Maple}}}\
    -match relation

    test relation-eliminate-2.1 {multiple attributes} -body {
	set r1 {Relation\
	    {Name string Number int Street string IsMale string}\
	    Name\
	    {{Name Andrew Number 599 Street Blackwood IsMale true}\
	    {Name Jane Street Main Number 300 IsMale false}\
	    {Name Fred Street Maple Number 599 IsMale true}}}
	relation eliminate $r1 Name Street
    } -result {Relation {Number int IsMale string} {{Number IsMale}} {{Number 599 IsMale true} {Number 300 IsMale false}}}\
    -match relation

    test relation-eliminate-3.0 {nullary eliminate, non-empty relation} -body {
	set r1 {Relation\
	    {Name string Number int Street string IsMale string}\
	    Name\
	    {{Name Andrew Number 599 Street Blackwood IsMale true}\
	    {Name Jane Street Main Number 300 IsMale false}\
	    {Name Fred Street Maple Number 599 IsMale true}}}
	relation eliminate $r1
    } -result {Relation {Name string Number int Street string IsMale string} Name {{Name Andrew Number 599 Street Blackwood IsMale true} {Name Jane Number 300 Street Main IsMale false} {Name Fred Number 599 Street Maple IsMale true}}}\
    -match relation

    test relation-eliminate-4.0 {nullary eliminate, empty relation} -body {
	set r1 {
	    Relation
	    {Name string Number int Street string IsMale string}
	    Name
	    {}
	}
	relation eliminate $r1
    } -result {
	Relation
	{Name string Number int Street string IsMale string}
	Name
	{}
    } -match relation

    # relation dict subcommand
    test relation-dict-1.0 {supplier number / city map} -body {
	relation dict [relation project $S S# CITY]
    } -result {
	    S1 London
	    S2 Paris
	    S3 Paris
	    S4 London
	    S5 Athens
    } -match dict

    test relation-dict-2.0 {id problem} -body {
	relation dict [relation project $S SNAME CITY]
    } -result {identifier must have only a single attribute, "Relation {SNAME string CITY string} {{SNAME CITY}} {{SNAME Smith CITY London} {SNAME Jones CITY Paris} {SNAME Blake CITY Paris} {SNAME Clark CITY London} {SNAME Adams CITY Athens}}"} -returnCodes error

    # relation divide subcommand
    test relation-divide-1.0 {suppliers who supply P1} -setup {
	set dend [relation project $S S#]
	set med [relation project $SP S# P#]
	set dsor [relation project\
	    [relation restrictwith $P {${P#} eq "P1"}] P#]
    } -body {
	relation divide $dend $dsor $med
    } -result {
	Relation
	{S# string}
	S#
	{
	    {S# S1}
	    {S# S2}
	}
    } -match relation

    test relation-divide-2.0 {suppliers who supply P2 and P4} -setup {
	set dend [relation project $S S#]
	set med [relation project $SP P# S#]
	set dsor [relation project\
	    [relation restrictwith $P {${P#} eq "P2" || ${P#} eq "P4"}] P#]
    } -body {
	relation divide $dend $dsor $med
    } -result {
	Relation
	{S# string}
	S#
	{
	    {S# S1}
	    {S# S4}
	}
    } -match relation

    test relation-divide-3.0 {suppliers who supply all parts} -setup {
	set dend [relation project $S S#]
	set med [relation project $SP P# S#]
	set dsor [relation project $P P#]
    } -body {
	relation divide $dend $dsor $med
    } -result {
	Relation
	{S# string}
	S#
	{
	    {S# S1}
	}
    } -match relation

    test relation-divide-4.0 {not disjoint dividend and divsor} -setup {
	set dend [relation project $S S#]
	set dsor $S
	set med [relation project $SP P# S#]
    } -body {
	relation divide $dend $dsor $med
    } -result {divisor heading must be disjoint from the dividend heading, "during divide operation"}\
    -returnCodes error

    test relation-divide-5.0 {mediator not union dividend and divsor} -setup {
	set dend [relation project $S S#]
	set dsor [relation project $P P#]
	set med [relation project $SP S#]
    } -body {
	relation divide $dend $dsor $med
    } -result {mediator heading must be a union of the dividend and divisor headings, "during divide operation"}\
    -returnCodes error

    # relation emptyof subcommand
    test relation-emptyof-1.0 {multiple attributes} -body {
	relation emptyof $S
    } -result {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
	{}
    } -match relation

    # relation extend subcommand
    test relation-extend-1.0 {multiple body tuples} -body {
	set r1 {Relation {Name string Age int} Name\
	    {{Name Andrew Age 20}\
	    {Name George Age 20}\
	    {Name Fred Age 20}}}
	relation extend $r1 t AgeInMonths int {[tuple extract $t Age] * 12}
    } -result {
	Relation
	{Name string Age int AgeInMonths int}
	Name
	{
	    {Name Andrew Age 20 AgeInMonths 240}
	    {Name George Age 20 AgeInMonths 240}
	    {Name Fred Age 20 AgeInMonths 240}
	}
    } -match relation

    test relation-extend-2.0 {bad expression} -body {
	set r1 {Relation {Name string Age int} Name\
	    {{Name Andrew Age 20}\
	    {Name George Age 20}\
	    {Name Fred Age 20}}}
	relation extend $r1 t AgeInMonths int {[tuple extract $t foo] * 12}
    } -result {unknown attribute name, "foo"} -returnCodes error

    test relation-extend-3.0 {specify ordering} -body {
	set r1 {
	    Relation
	    {Name string Age int}
	    Name
	    {
		{Name Andrew Age 20}
		{Name George Age 20}
		{Name Fred Age 20}
	    }
	}
	set cnt -1
	relation extend $r1 -ascending Name t Order int {[incr cnt]}
    } -match relation -result {
	Relation
	{Name string Age int Order int}
	Name
	{
	    {Name Andrew Age 20 Order 0}
	    {Name George Age 20 Order 2}
	    {Name Fred Age 20 Order 1}
	}
    }

    test relation-extend-3.1 {specify ordering; bad command} -body {
	set r1 {
	    Relation
	    {Name string Age int}
	    Name
	    {
		{Name Andrew Age 20}
		{Name George Age 20}
		{Name Fred Age 20}
	    }
	}
	set cnt -1
	relation extend $r1 -ascending t Order int {[incr cnt]}
    } -returnCodes error -result {unknown attribute name, "t"}

    test relation-extend-3.2 {specify ordering; bad command} -body {
	set r1 {
	    Relation
	    {Name string Age int}
	    Name
	    {
		{Name Andrew Age 20}
		{Name George Age 20}
		{Name Fred Age 20}
	    }
	}
	set cnt -1
	relation extend $r1 -ascending Name
    } -returnCodes error -result {wrong # args: should be "relation extend relationValue ?-ascending | -descending attrList? tupleVarName ?attr1 type1 expr1 ... attrN typeN exprN?"}
    # HERE -- add tests

    # relation foreach subcommand
    test relation-foreach-1.0 {simple visit of suppliers} -body {
	set nameList [list]
	relation foreach sup $S {
	    lappend nameList [tuple extract $sup SNAME]
	}
	lsort $nameList
    } -result {Adams Blake Clark Jones Smith}

    test relation-foreach-2.0 {visit of suppliers ascending order} -body {
	set nameList [list]
	relation foreach sup $S -ascending SNAME {
	    lappend nameList [tuple extract $sup SNAME]
	}
	set nameList
    } -result {Adams Blake Clark Jones Smith}

    test relation-foreach-3.0 {visit of suppliers descending order} -body {
	set nameList [list]
	relation foreach sup $S -descending SNAME {
	    lappend nameList [tuple extract $sup SNAME]
	}
	set nameList
    } -result {Smith Jones Clark Blake Adams}

    test relation-foreach-4.0 {visit of suppliers ordered by multiple} -body {
	set nameList [list]
	relation foreach sup $S -ascending {STATUS CITY} {
	    lappend nameList [tuple extract $sup SNAME]
	}
	set nameList
    } -result {Jones Smith Clark Adams Blake}

    test relation-foreach-5.0 {unset tuple variable} -body {
	set nameList [list]
	relation foreach sup $S {
	    unset sup
	}
	set S
    } -result {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
	{
	    {S# S1 SNAME Smith STATUS 20 CITY London}
	    {S# S2 SNAME Jones STATUS 10 CITY Paris}
	    {S# S3 SNAME Blake STATUS 30 CITY Paris}
	    {S# S4 SNAME Clark STATUS 20 CITY London}
	    {S# S5 SNAME Adams STATUS 30 CITY Athens}
	}
    } -match relation

    test relation-foreach-5.1 {update tuple variable} -body {
	set nameList [list]
	relation foreach sup $S {
	    tuple update sup {CITY Sunnyvale}
	}
	set S
    } -result {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
	{
	    {S# S1 SNAME Smith STATUS 20 CITY London}
	    {S# S2 SNAME Jones STATUS 10 CITY Paris}
	    {S# S3 SNAME Blake STATUS 30 CITY Paris}
	    {S# S4 SNAME Clark STATUS 20 CITY London}
	    {S# S5 SNAME Adams STATUS 30 CITY Athens}
	}
    } -match relation

    # relation group subcommand
    test relation-group-1.0 {group two attributes} -body {
	relation group $SP PQ P# QTY
    } -result {
	Relation
	{S# string PQ {Relation {P# string QTY int} P#}}
	S#
	{
	    {S# S1 PQ {
		{P# P1 QTY 300}
		{P# P2 QTY 200}
		{P# P3 QTY 400}
		{P# P4 QTY 200}
		{P# P5 QTY 100}
		{P# P6 QTY 100}}
	    }
	    {S# S2 PQ {
		{P# P1 QTY 300}
		{P# P2 QTY 400}}
	    }
	    {S# S3 PQ {
		{P# P2 QTY 200}}
	    }
	    {S# S4 PQ {
		{P# P2 QTY 200}
		{P# P4 QTY 300}
		{P# P5 QTY 400}}
	    }
	}
    } -match relation

    test relation-group-2.0 {group two attributes} -body {
	relation group $SP SQ S# QTY
    } -result {
	Relation
	{P# string SQ {Relation {S# string QTY int} S#}}
	P#
	{
	    {P# P1 SQ {{S# S1 QTY 300} {S# S2 QTY 300}}}
	    {P# P2 SQ {
		{S# S1 QTY 200}
		{S# S2 QTY 400}
		{S# S3 QTY 200}
		{S# S4 QTY 200}}
	    }
	    {P# P3 SQ {{S# S1 QTY 400}}}
	    {P# P4 SQ {{S# S1 QTY 200} {S# S4 QTY 300}}}
	    {P# P5 SQ {{S# S1 QTY 100} {S# S4 QTY 400}}}
	    {P# P6 SQ {{S# S1 QTY 100}}}
	}
    } -match relation

    test relation-group-3.0 {group; no ids in grouped attribute} -setup {
	set r1 {
	    Relation
	    {Name string Number int Street string}
	    Name
	    {
		{Name Andrew Number 599 Street Blackwood}
		{Name Jane Street Main Number 300}
		{Name Alice Street Main Number 300}
		{Name Fred Street Maple Number 599}
	    }
	}
    } -body {
	relation group $r1 Addr Number Street
    } -result {
	Relation
	{Name string Addr
	    {Relation {Number int Street string} {{Number Street}}}
	}
	Name
	{
	    {Name Andrew Addr {{Number 599 Street Blackwood}}}
	    {Name Jane Addr {{Number 300 Street Main}}}
	    {Name Alice Addr {{Number 300 Street Main}}}
	    {Name Fred Addr {{Number 599 Street Maple}}}
	}
    } -match relation

    test relation-group-4.0 {group; all ids in grouped attribute} -setup {
	set r1 {
	    Relation
	    {Name string Number int Street string}
	    {{Name Number Street}}
	    {
		{Name Andrew Number 599 Street Blackwood}
		{Name Jane Street Main Number 300}
		{Name Alice Street Main Number 300}
		{Name Fred Street Maple Number 599}
	    }
	}
    } -body {
	relation group $r1 Addr Number Street
    } -result {
	Relation
	{Name string Addr
	    {Relation {Number int Street string} {{Number Street}}}
	}
	Name
	{
	    {Name Andrew Addr {{Number 599 Street Blackwood}}}
	    {Name Jane Addr {{Number 300 Street Main}}}
	    {Name Alice Addr {{Number 300 Street Main}}}
	    {Name Fred Addr {{Number 599 Street Maple}}}
	}
    } -match relation

    test relation-group-5.0 {group, unreversable} -setup {
	set three {
	    Relation
	    {A int X string}
	    {{A X}}
	    {
		{A 1 X a}
		{A 1 X b}
		{A 1 X c}
	    }
	}
    } -body {
	relation group $three RVX X
    } -result {
	Relation
	{A int RVX {Relation {X string} X}}
	A
	{
	    {A 1 RVX {{X a} {X b} {X c}}}
	}
    } -match relation

    # relation heading subcommand
    test relation-heading-1.0 {dum relation} -body {
	relation heading $DUM
    } -result {Relation {} {{}}}

    test relation-heading-2.0 {dee relation} -body {
	relation heading $DEE
    } -result {Relation {} {{}}}

    test relation-heading-3.0 {single attribute} -body {
	relation heading {Relation {Name string} Name {{Name Andrew}}}
    } -result {Relation {Name string} Name}

    test relation-heading-4.0 {multiple attributes} -body {
	relation heading $S
    } -result {Relation {S# string SNAME string STATUS int CITY string} S#}

    # relation identifiers subcommand
    test relation-identifiers-1.0 {dum relation} -body {
	relation identifiers $DUM
    } -result {{}}

    test relation-identifiers-2.0 {single identifier} -body {
	relation identifiers {Relation {a1 string} a1 {}}
    } -result {a1}

    test relation-identifiers-3.0 {multiple identifiers} -body {
	relation identifiers {Relation {a1 string a2 string} {a1 a2} {}}
    } -result {a1 a2}

    test relation-identifiers-4.0 {multiple compound identifiers} -body {
	relation identifiers {Relation {a1 string a2 string a3 string} {{a1 a2} {a2 a3}} {}}
    } -result {{a1 a2} {a2 a3}}

    # relation intersect subcommand
    test relation-intersect-1.0 {dum relation} -body {
	relation intersect $DUM $DUM
    } -result {Relation {} {{}} {}} -match relation

    test relation-intersect-2.0 {dee relation} -body {
	relation intersect $DEE $DEE
    } -result {Relation {} {{}} {{}}} -match relation

    test relation-intersect-3.0 {disjoint sets} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Name George Age 20 City {San Jose}}}}
	relation intersect $r1 $r2
    } -result {Relation {Name string Age int City string} Name {}}\
    -match relation

    test relation-intersect-4.0 {same relation} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}}}
	relation intersect $r1 $r1
    } -result {Relation {Name string Age int City string} Name\
	{{Name Andrew Age 30 City Sunnyvale}}}\
    -match relation

    test relation-intersect-5.0 {common tuples} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Name George Age 20 City {San Jose}}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Name George Age 20 City {San Jose}}}}
	relation intersect $r1 $r2
    } -result {Relation {Name string Age int City string} Name\
	{{Name George Age 20 City {San Jose}}}}\
    -match relation

    test relation-intersect-6.0 {multiple common tuples} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Name George Age 20 City {San Jose}}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Name George Age 20 City {San Jose}}\
	    {Name Fred Age 10 City Saratoga}\
	    {Name Andrew Age 30 City Sunnyvale}}}
	relation intersect $r1 $r2
    } -result {Relation {Name string Age int City string} Name\
	{{Name Andrew Age 30 City Sunnyvale}\
	{Name George Age 20 City {San Jose}}}}\
    -match relation

    test relation-intersect-7.0 {multiple relations} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Name George Age 20 City {San Jose}}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Name George Age 20 City {San Jose}}}}
	set r3 {Relation {Name string Age int City string} Name\
	    {{Name George Age 20 City {San Jose}}\
	    {Name Fred Age 10 City Saratoga}}}
	relation intersect $r1 $r2 $r3
    } -result {Relation {Name string Age int City string} Name\
	{{Name George Age 20 City {San Jose}}}}\
    -match relation

    test relation-intersect-8.0 {multiple relations, different order} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Name George Age 20 City {San Jose}}}}
	set r2 {Relation {Age int Name string City string} Name\
	    {{Name George Age 20 City {San Jose}}}}
	set r3 {Relation {Age int City string Name string} Name\
	    {{Name George Age 20 City {San Jose}}\
	    {Name Fred Age 10 City Saratoga}}}
	relation intersect $r1 $r2 $r3
    } -result {Relation {Name string Age int City string} Name\
	{{Name George Age 20 City {San Jose}}}}\
    -match relation

    # relation is subcommand

    # relation equal operator
    test relation-is-equal-1.0 {dum relation} -body {
	relation is $DUM equal {Relation {} {{}} {}}
    } -result 1

    test relation-is-equal-2.0 {dee relation} -body {
	relation is $DEE equal {Relation {} {{}} {{}}}
    } -result 1

    test relation-is-equal-3.0 {same relations} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 equal $r2
    } -result 1

    test relation-is-equal-4.0 {different header order} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string City string Age int} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 equal $r2
    } -result 1

    test relation-is-equal-5.0 {different relations} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string City string Age int} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {Name Andrew Age 40 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 equal $r2
    } -result 0

    test relation-is-equal-6.0 {different headings} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string Status int City string} Name\
	    {{Status 20 Name George City {San Jose}}\
	    {Name Andrew Status 30 City Sunnyvale}\
	    {City Saratoga Status 10 Name Fred}}}
	relation is $r1 equal $r2
    } -result {headings not equal, "Relation {Name string Status int City string} Name {{Name George Status 20 City {San Jose}} {Name Andrew Status 30 City Sunnyvale} {Name Fred Status 10 City Saratoga}}"}\
    -returnCodes error

    test relation-is-equal-7.0 {tuple valued attributes} -body {
	set r1 {
	    Relation
	    {	Name string
		Age int
		Address {Tuple {Number int Street string City string}}
	    }
	    Name
	    {
		{Name Andrew Age 30
		    Address {Number 200 Street Main City Sunnyvale}}
		{Age 20 Name George
		    Address {Number 300 Street Clay City {San Jose}}}
		{Address {Street 51st Number 100 City Saratoga}
		    Age 10 Name Fred}
	    }
	}
	set r2 {
	    Relation
	    {	Name string
		Address {Tuple {Number int Street string City string}}
		Age int
	    }
	    Name
	    {
		{   Address {City Sunnyvale Number 200 Street Main}
		    Age 30
		    Name Andrew
		}
		{   Age 20 
		    Name George
		    Address {Number 300 Street Clay City {San Jose}}
		}
		{   Name Fred
		    Address {Street 51st Number 100 City Saratoga}
		    Age 10
		}
	    }
	}
	relation is $r1 == $r2
    } -result 1

    test relation-is-equal-8.0 {relation valued attributes} -body {
	set r1 {
	    Relation
	    {	Name string
		Age int
		Addresses {
		    Relation
		    {Number int Street string City string}
		    {{Number Street City}}
		}
	    }
	    Name
	    {
		{   Name Andrew
		    Age 30
		    Addresses {
			{Number 200 Street Main City Sunnyvale}
		    }
		}
		{
		    Age 20
		    Name George
		    Addresses {
			{Number 300 Street Clay City {San Jose}}
		    }
		}
		{   Addresses {
			{Street 51st Number 100 City Saratoga}
		    }
		    Age 10
		    Name Fred
		}
	    }
	}
	set r2 {
	    Relation
	    {	Name string
		Age int
		Addresses {
		    Relation
		    {Number int Street string City string}
		    {{Number Street City}}
		}
	    }
	    Name
	    {
		{
		    Age 20
		    Addresses {
			{Number 300 Street Clay City {San Jose}}
		    }
		    Name George
		}
		{   Addresses {
			{Street 51st Number 100 City Saratoga}
		    }
		    Age 10
		    Name Fred
		}
		{   Name Andrew
		    Addresses {
			{Number 200 Street Main City Sunnyvale}
		    }
		    Age 30
		}
	    }
	}
	relation is $r1 == $r2
    } -result 1

    test relation-is-equal-8.1 {relation valued attributes, multi value} -body {
	set r1 {
	    Relation
	    {	Name string
		Age int
		Addresses {
		    Relation
		    {Number int Street string City string}
		    {{Number Street City}}
		}
	    }
	    Name
	    {
		{   Name Andrew
		    Age 30
		    Addresses {
			{Number 200 Street Main City Sunnyvale}
			{Number 201 Street Main City Sunnyvale}
			{Number 202 Street Main City Sunnyvale}
		    }
		}
		{
		    Age 20
		    Name George
		    Addresses {
			{Number 300 Street Clay City {San Jose}}
			{Number 301 Street Clay City {San Jose}}
			{Number 302 Street Clay City {San Jose}}
		    }
		}
		{   Addresses {
			{Street 51st Number 100 City Saratoga}
			{Street 51st Number 101 City Saratoga}
			{Street 51st Number 102 City Saratoga}
		    }
		    Age 10
		    Name Fred
		}
	    }
	}
	set r2 {
	    Relation
	    {	Name string
		Age int
		Addresses {
		    Relation
		    {Number int Street string City string}
		    {{Number Street City}}
		}
	    }
	    Name
	    {
		{
		    Age 20
		    Addresses {
			{Number 301 Street Clay City {San Jose}}
			{Number 300 Street Clay City {San Jose}}
			{Number 302 Street Clay City {San Jose}}
		    }
		    Name George
		}
		{   Addresses {
			{Street 51st Number 102 City Saratoga}
			{Street 51st Number 100 City Saratoga}
			{Street 51st Number 101 City Saratoga}
		    }
		    Age 10
		    Name Fred
		}
		{   Name Andrew
		    Addresses {
			{Number 201 Street Main City Sunnyvale}
			{Number 202 Street Main City Sunnyvale}
			{Number 200 Street Main City Sunnyvale}
		    }
		    Age 30
		}
	    }
	}
	relation is $r1 == $r2
    } -result 1

    # relation notequal operator
    test relation-is-notequal-1.0 {dum relation} -body {
	relation is $DUM notequal {Relation {} {{}} {}}
    } -result 0

    test relation-is-notequal-2.0 {dee relation} -body {
	relation is $DEE notequal {Relation {} {{}} {{}}}
    } -result 0

    test relation-is-notequal-3.0 {same relations} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 notequal $r2
    } -result 0

    test relation-is-notequal-4.0 {different header order} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string City string Age int} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 notequal $r2
    } -result 0

    test relation-is-notequal-5.0 {different relations} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string City string Age int} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {Name Andrew Age 40 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 != $r2
    } -result 1

    # relation propersubset operator
    test relation-is-propersubset-1.0 {dum relation} -body {
	relation is $DUM propersubsetof $DUM
    } -result 0

    test relation-is-propersubset-2.0 {dee relation} -body {
	relation is $DEE propersubsetof $DEE
    } -result 0

    test relation-is-propersubset-3.0 {same relations} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 propersubsetof $r2
    } -result 0

    test relation-is-propersubset-4.0 {smaller 1st relation} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 propersubsetof $r2
    } -result 1

    test relation-is-propersubset-5.0 {larger 1st relation} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 < $r2
    } -result 0

    # relation propersuperset operator
    test relation-is-propersuperset-1.0 {dum relation} -body {
	relation is $DUM propersuperset $DUM
    } -result 0

    test relation-is-propersuperset-2.0 {dee relation} -body {
	relation is $DEE propersupersetof $DEE
    } -result 0

    test relation-is-propersuperset-3.0 {same relations} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 propersupersetof $r2
    } -result 0

    test relation-is-propersuperset-4.0 {larger 1st relation} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 propersupersetof $r2
    } -result 1

    test relation-is-propersuperset-5.0 {smaller 1st relation} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 > $r2
    } -result 0

    # relation subset operator
    test relation-is-subset-1.0 {dum relation} -body {
	relation is $DUM subsetof $DUM
    } -result 1

    test relation-is-subset-2.0 {dee relation} -body {
	relation is $DEE subsetof $DEE
    } -result 1

    test relation-is-subset-3.0 {same relations} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 subsetof $r2
    } -result 1

    test relation-is-subset-4.0 {smaller 1st relation} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 subsetof $r2
    } -result 1

    test relation-is-subset-5.0 {larger 1st relation} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 <= $r2
    } -result 0

    # relation superset operator
    test relation-is-superset-1.0 {dum relation} -body {
	relation is $DUM supersetof $DUM
    } -result 1

    test relation-is-superset-2.0 {dee relation} -body {
	relation is $DEE supersetof $DEE
    } -result 1

    test relation-is-superset-3.0 {same relations} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 supersetof $r2
    } -result 1

    test relation-is-superset-4.0 {larger 1st relation} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 supersetof $r2
    } -result 1

    test relation-is-superset-5.0 {smaller 1st relation} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {Name Andrew Age 30 City Sunnyvale}\
	    {City Saratoga Age 10 Name Fred}}}
	relation is $r1 >= $r2
    } -result 0

    # relation isempty subcommand
    test relation-isempty-1.0 {dum relation} -body {
	relation isempty $DUM
    } -result 1

    test relation-isempty-2.0 {dee relation} -body {
	relation isempty $DEE
    } -result 0

    test relation-isempty-3.0 {multiple body tuples} -body {
	relation isempty $S
    } -result 0

    # relation isnotempty subcommand
    test relation-isnotempty-1.0 {dum relation} -body {
	relation isnotempty $DUM
    } -result 0

    test relation-isnotempty-2.0 {dee relation} -body {
	relation isnotempty $DEE
    } -result 1

    test relation-isnotempty-3.0 {multiple body tuples} -body {
	relation isnotempty $S
    } -result 1

    # relation join subcommand
    test relation-join-1.0 {one common attribute} -body {
	set r1 {Relation {Name string Age int} Name\
	    {{Age 20 Name George}\
	    {Age 10 Name Fred}}}
	set r2 {Relation {Age int City string} Age\
	    {{Age 30 City Sunnyvale}\
	    {Age 20 City {San Jose}}\
	    {City Saratoga Age 10}}}
	relation join $r1 $r2
    } -result {
	Relation
	{Name string Age int City string}
	{{Name Age}}
	{
	    {Name George Age 20 City {San Jose}}
	    {Name Fred Age 10 City Saratoga}
	}
    } -match relation

    test relation-join-2.0 {multiple common attribute} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Age int City string} Age\
	    {{Age 30 City Sunnyvale}\
	    {Age 20 City {San Jose}}\
	    {City Saratoga Age 10}}}
	relation join $r1 $r2
    } -result {
	Relation
	{Name string Age int City string}
	{{Name Age}}
	{
	    {Name George Age 20 City {San Jose}}
	    {Name Fred Age 10 City Saratoga}
	}
    } -match relation

    test relation-join-3.0 {no common attribute} -body {
	set r1 {Relation {Name string Age int} Name\
	    {{Age 20 Name George}\
	    {Age 10 Name Fred}}}
	set r2 {Relation {Status int City string} Status\
	    {{Status 30 City Sunnyvale}\
	    {Status 20 City {San Jose}}\
	    {City Saratoga Status 10}}}
	relation join $r1 $r2
    } -result {
	Relation
	{Name string Age int Status int City string}
	{{Name Status}}
	{
	    {Name George Age 20 Status 30 City Sunnyvale}
	    {Name George Age 20 Status 20 City {San Jose}}
	    {Name George Age 20 Status 10 City Saratoga}
	    {Name Fred Age 10 Status 30 City Sunnyvale}
	    {Name Fred Age 10 Status 20 City {San Jose}}
	    {Name Fred Age 10 Status 10 City Saratoga}
	}
    } -match relation

    test relation-join-4.0 {join with DEE; identity} -body {
	set r1 {Relation {Name string Age int} Name\
	    {{Age 20 Name George}\
	    {Age 10 Name Fred}}}
	set r2 {Relation {} {{}} {{}}}
	relation is [relation join $r1 $r2] == $r1
    } -result 1

    test relation-join-5.0 {join with DUM ; empty} -body {
	set r1 {Relation {Name string Age int} Name\
	    {{Age 20 Name George}\
	    {Age 10 Name Fred}}}
	set r2 {Relation {} {{}} {}}
	relation is [relation join $r1 $r2] == [relation empty $r1]
    } -result 1

    test relation-join-6.0 {specified attribute} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	set r2 {Relation {Status int City string} Status\
	    {{Status 30 City Sunnyvale}\
	    {Status 20 City {San Jose}}\
	    {City Saratoga Status 10}}}
	relation join $r1 $r2 -using {City City}
    } -result {
	Relation
	{Name string Age int City string Status int}
	{{Name Status}}
	{
	    {Name George Age 20 City {San Jose} Status 20}
	    {Name Fred Age 10 City Saratoga Status 10}
	}
    } -match relation

    # relation list subcommand
    test relation-list-1.0 {multiple tuples} -body {
	set r {
	    Relation
	    {SNAME string}
	    SNAME
	    {
		{SNAME Smith}
		{SNAME Jones}
		{SNAME Blake}
		{SNAME Clark}
		{SNAME Adams}
	    }
	}
	lsort [relation list $r]
    } -result {Adams Blake Clark Jones Smith}

    test relation-list-2.0 {one tuple} -body {
	relation list {Relation {Name string} Name {{Name Fred}}}
    } -result {Fred}

    # relation minus subcommand
    test relation-minus-1.0 {dum relation} -body {
	relation minus $DUM $DUM
    } -result {Relation {} {{}} {}} -match relation

    test relation-minus-2.0 {dee relation} -body {
	relation minus $DEE $DEE
    } -result {Relation {} {{}} {}} -match relation

    test relation-minus-3.0 {disjoint sets} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Name George Age 20 City {San Jose}}}}
	relation minus $r1 $r2
    } -result {Relation {Name string Age int City string} Name\
	{{Name Andrew Age 30 City Sunnyvale}}} -match relation

    test relation-minus-4.0 {same sets} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}}}
	relation minus $r1 $r1
    } -result {Relation {Name string Age int City string} Name {}}\
    -match relation

    # relation project subcommand
    test relation-project-1.0 {single attribute} -body {
	set r1 {Relation \
	    {Name string Number int Street string IsMale string}\
	    Name\
	    {{Name Andrew Number 599 Street Blackwood IsMale true}\
	    {Name Jane Street Main Number 300 IsMale false}\
	    {Name Fred Street Maple Number 599 IsMale true}}}
	relation project $r1 Name
    } -result {
	Relation
	{Name string}
	Name
	{
	    {Name Andrew}
	    {Name Jane}
	    {Name Fred}
	}
    } -match relation

    test relation-project-2.0 {multiple attributes} -body {
	set r1 {Relation \
	    {Name string Number int Street string IsMale string}\
	    Name\
	    {{Name Andrew Number 599 Street Blackwood IsMale true}\
	    {Name Jane Street Main Number 300 IsMale false}\
	    {Name Fred Street Maple Number 599 IsMale true}}}
	relation project $r1 Number IsMale
    } -result {
	Relation
	{Number int IsMale string}
	{{Number IsMale}}
	{
	    {Number 599 IsMale true}
	    {Number 300 IsMale false}
	}
    } -match relation

    test relation-project-3.0 {nullary projection, non-empty relation} -body {
	set r1 {Relation \
	    {Name string Number int Street string IsMale string}\
	    Name\
	    {{Name Andrew Number 599 Street Blackwood IsMale true}\
	    {Name Jane Street Main Number 300 IsMale false}\
	    {Name Fred Street Maple Number 599 IsMale true}}}
	relation project $r1
    } -result {Relation {} {{}} {{}}} -match relation

    test relation-project-4.0 {nullary projection, empty relation} -body {
	set r1 {Relation \
	    {Name string Number int Street string IsMale string}\
	    Name\
	    {}}
	relation project $r1
    } -result {Relation {} {{}} {}} -match relation

    test relation-project-5.0 {non-existant attribute} -body {
	set r1 {Relation \
	    {Name string Number int Street string IsMale string}\
	    Name\
	    {{Name Andrew Number 599 Street Blackwood IsMale true}\
	    {Name Jane Street Main Number 300 IsMale false}\
	    {Name Fred Street Maple Number 599 IsMale true}}}
	relation project $r1 foo
    } -result {unknown attribute name, "foo"} -returnCodes error

    test relation-project-6.0 {duplicate projection attribute} -body {
	set r1 {Relation \
	    {Name string Number int Street string IsMale string}\
	    Name\
	    {{Name Andrew Number 599 Street Blackwood IsMale true}\
	    {Name Jane Street Main Number 300 IsMale false}\
	    {Name Fred Street Maple Number 599 IsMale true}}}
	relation project $r1 Name Name
    } -result {Relation {Name string} Name {{Name Andrew} {Name Jane} {Name Fred}}}\
    -match relation

    test relation-project-7.0 {reorder attributes} -body {
	set r1 {Relation \
	    {Name string Number int Street string IsMale string}\
	    {{Number Street}}\
	    {{Name Andrew Number 599 Street Blackwood IsMale true}\
	    {Name Jane Street Main Number 300 IsMale false}\
	    {Name Fred Street Maple Number 599 IsMale true}}}
	relation project $r1 Number Street IsMale
    } -result {Relation {Number int Street string IsMale string} {{Number Street}} {{Number 599 Street Blackwood IsMale true} {Number 300 Street Main IsMale false} {Number 599 Street Maple IsMale true}}}\
    -match relation

    # relation rename subcommand
    test relation-rename-1.0 {single attribute} -body {
	set r {Relation {Name string} Name {{Name Andrew}}}
	relation rename $r Name foo
    } -result {Relation {foo string} foo {{foo Andrew}}}\
    -match relation

    test relation-rename-2.0 {multiple attributes} -body {
	set r {Relation {Name string Age int City string} Name\
	{{Name Andrew Age 30 City Sunnyvale}\
	 {Name George Age 20 City {San Jose}}}}
	relation rename $r Age Status
    } -result {Relation {Name string Status int City string} Name\
	{{Name Andrew Status 30 City Sunnyvale}\
	 {Name George Status 20 City {San Jose}}}}\
     -match relation

    test relation-rename-2.1 {multiple attributes, multiple renames} -body {
	set r {Relation {Name string Age int City string} Name\
	{{Name Andrew Age 30 City Sunnyvale}\
	 {Name George Age 20 City {San Jose}}}}
	relation rename $r Age Status City Town
    } -result {Relation {Name string Status int Town string} Name\
	{{Name Andrew Status 30 Town Sunnyvale}\
	 {Name George Status 20 Town {San Jose}}}}\
    -match relation

    # relation restrict subcommand
    test relation-restrict-1.0 {match on one attribute} -body {
	set r {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	relation restrict $r t {[tuple extract $t Age] < 20}
    } -result {Relation {Name string Age int City string} Name\
	{{Name Fred Age 10 City Saratoga}}}\
    -match relation

    test relation-restrict-2.0 {match on several attributes} -body {
	set r {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	relation restrict $r t\
	    {[tuple extract $t Age] < 20 &&\
	    [string index [tuple extract $t City] 0] ne "S"}
    } -result {Relation {Name string Age int City string} Name {}}\
    -match relation

    test relation-restrict-3.0 {bad expression} -body {
	set r {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	relation restrict $r selected {< 20}
    } -result {syntax error in expression "< 20": unexpected operator <}\
    -returnCodes error

    # relation restrictwith subcommand
    test relation-restrictwith-1.0 {match on one attribute} -body {
	set r {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	relation restrictwith $r {$Age < 20}
    } -result {Relation {Name string Age int City string} Name\
	{{Name Fred Age 10 City Saratoga}}}\
    -match relation

    test relation-restrictwith-2.0 {match on several attributes} -body {
	set r {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	relation restrictwith $r\
	    {$Age < 20 && [string index $City 0] ne "S"}
    } -result {Relation {Name string Age int City string} Name {}}\
    -match relation

    test relation-restrictwith-3.0 {bad expression} -body {
	set r {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {City Saratoga Age 10 Name Fred}}}
	relation restrictwith $r {< 20}
    } -result {syntax error in expression "< 20": unexpected operator <}\
    -returnCodes error

    # relation semijoin subcommand
    test relation-semijoin-1.0 {one common attribute} -body {
	set r1 {Relation {Age int City string} Age\
	    {{Age 30 City Sunnyvale}\
	    {Age 20 City {San Jose}}\
	    {City Saratoga Age 10}}}
	set r2 {Relation {Name string Age int} Name\
	    {{Age 20 Name George}\
	    {Age 10 Name Fred}}}
	relation semijoin $r1 $r2
    } -result {
	Relation
	{Name string Age int}
	Name
	{
	    {Name George Age 20}
	    {Name Fred Age 10}
	}
    } -match relation

    test relation-semijoin-2.0 {one common attribute} -body {
	set r1 {Relation {Age int City string} Age\
	    {{Age 35 City Sunnyvale}\
	    {Age 20 City {San Jose}}\
	    {City Saratoga Age 15}}}
	set r2 {Relation {Name string Age int} Name\
	    {{Age 20 Name George}\
	    {Age 10 Name Fred}}}
	relation semijoin $r1 $r2
    } -result {
	Relation
	{Name string Age int}
	Name
	{
	    {Name George Age 20}
	}
    } -match relation

    test relation-semijoin-3.0 {more than two relations} -body {
	relation semijoin $P $SP $S
    } -result {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
	{
	    {S# S1 SNAME Smith STATUS 20 CITY London}
	    {S# S2 SNAME Jones STATUS 10 CITY Paris}
	    {S# S3 SNAME Blake STATUS 30 CITY Paris}
	    {S# S4 SNAME Clark STATUS 20 CITY London}
	}
    } -match relation
    # HERE -- add tests

    # relation semiminus subcommand
    test relation-semiminus-1.0 {one common attribute} -body {
	relation semiminus $SP $S
    } -result {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
	{
	    {S# S5 SNAME Adams STATUS 30 CITY Athens}
	}
    } -match relation

    test relation-semiminus-2.0 {one common attribute} -body {
	relation semiminus $S $SP
    } -result {
	Relation
	{S# string P# string QTY int}
	{{S# P#}}
	{}
    } -match relation

    test relation-semiminus-3.0 {one common attribute} -body {
	set r1 {
	    Relation
	    {Age int City string}
	    Age
	    {
		{Age 30 City Sunnyvale}
		{Age 20 City {San Jose}}
		{City Saratoga Age 10}
	    }
	}
	set r2 {
	    Relation
	    {Name string Age int Town string}
	    Name
	    {
		{Age 20 Name George Town Sunnyvale}
		{Age 10 Name Fred Town {New York}}
	    }
	}
	relation semiminus $r1 $r2 -using {City Town}
    } -result {
	    Relation
	    {Name string Age int Town string}
	    Name
	    {
		{Age 10 Name Fred Town {New York}}
	    }
    } -match relation
    # HERE -- add tests

    # relation summarize subcommand
    test relation-summarize-1.0 {count} -body {
	set p [relation project $P P#]
	relation summarize $SP $p r Total int {rsum($r, "QTY")}
    } -result {
	Relation
	{P# string Total int}
	P#
	{
	    {P# P1 Total 600}
	    {P# P2 Total 1000}
	    {P# P3 Total 400}
	    {P# P4 Total 500}
	    {P# P5 Total 500}
	    {P# P6 Total 100}
	}
    } -match relation

    test relation-summarize-2.0 {summarize per dee} -body {
	relation summarize $SP $DEE r GrandTotal int {rsum($r, "QTY")}
    } -result {
	Relation
	{GrandTotal int}
	GrandTotal
	{
	    {GrandTotal 3100}
	}
    } -match relation

    test relation-summarize-2.1 {summarize per dee, average} -body {
	relation summarize $SP $DEE r GrandAvg int {ravg($r, "QTY")}
    } -result {
	Relation
	{GrandAvg int}
	GrandAvg
	{
	    {GrandAvg 258}
	}
    } -match relation

    test relation-summarize-2.2 {summarize per dee, average} -body {
	relation summarize $OWNER $DEE r AverageAge int {ravg($r, "Age")}
    } -result {
	Relation
	{AverageAge int}
	AverageAge
	{
	    {AverageAge 36}
	}
    } -match relation

    test relation-summarize-3.0 {projection} -body {
	relation summarize $S [relation project $S STATUS CITY] r\
	    TOTAL int {rcount($r)}
    } -result {
	Relation
	{STATUS int CITY string TOTAL int}
	{{STATUS CITY}}
	{
	    {STATUS 20 CITY London TOTAL 2}
	    {STATUS 10 CITY Paris TOTAL 1}
	    {STATUS 30 CITY Paris TOTAL 1}
	    {STATUS 30 CITY Athens TOTAL 1}
	}
    } -match relation

    test relation-summarize-4.0 {projection, counting} -body {
	set ac [relation project $OWNERSHIP Acquired]
	relation summarize $OWNERSHIP $ac r\
	    NumAcquired int {[relation cardinality $r]}
    } -result {
	Relation
	{Acquired string NumAcquired int}
	Acquired
	{
	    {Acquired 2001 NumAcquired 3}
	    {Acquired 2000 NumAcquired 2}
	    {Acquired 2002 NumAcquired 1}
	    {Acquired 2003 NumAcquired 1}
	}
    } -match relation

    # relation tclose subcommand
    test relation-tclose-1.0 {single path} -body {
	set r {
	    Relation
	    {A string B string}
	    {{A B}}
	    {
		{A a B b}
		{A b B c}
	    }
	}
	relation tclose $r
    } -result {
	Relation
	{A string B string}
	{{A B}}
	{
	    {A a B b}
	    {A b B c}
	    {A a B c}
	}
    } -match relation

    test relation-tclose-1.1 {reverse path} -body {
	set r {
	    Relation
	    {A string B string}
	    {{A B}}
	    {
		{A b B a}
		{A c B b}
	    }
	}
	relation tclose $r
    } -result {
	Relation
	{A string B string}
	{{A B}}
	{
	    {A b B a}
	    {A c B b}
	    {A c B a}
	}
    } -match relation

    test relation-tclose-2.0 {joining path} -body {
	set r {
	    Relation
	    {A string B string}
	    {{A B}}
	    {
		{A a B b}
		{A a B c}
		{A b B d}
		{A c B d}
	    }
	}
	relation tclose $r
    } -result {
	Relation
	{A string B string}
	{{A B}}
	{
	    {A a B b}
	    {A a B c}
	    {A b B d}
	    {A c B d}
	    {A a B d}
	}
    } -match relation

    test relation-tclose-2.1 {diverging path} -body {
	set r {
	    Relation
	    {A string B string}
	    {{A B}}
	    {
		{A a B b}
		{A a B c}
		{A b B d}
		{A c B d}
		{A c B e}
		{A e B f}
	    }
	}
	relation tclose $r
    } -result {
	Relation
	{A string B string}
	{{A B}}
	{
	    {A a B b}
	    {A a B c}
	    {A a B d}
	    {A a B e}
	    {A a B f}
	    {A b B d}
	    {A c B d}
	    {A c B e}
	    {A c B f}
	    {A e B f}
	}
    } -match relation

    test relation-tclose-3.0 {AHU example} -body {
	set r {
	    Relation
	    {A string B string}
	    {{A B}}
	    {
		{A v1 B v1}
		{A v1 B v2}
		{A v1 B v3}
		{A v2 B v1}
		{A v3 B v2}
	    }
	}
	relation tclose $r
    } -result {
	Relation
	{A string B string}
	{{A B}}
	{
	    {A v1 B v1}
	    {A v1 B v2}
	    {A v1 B v3}
	    {A v2 B v1}
	    {A v2 B v2}
	    {A v2 B v3}
	    {A v3 B v1}
	    {A v3 B v2}
	    {A v3 B v3}
	}
    } -match relation

    test relation-tclose-4.0 {tree} -body {
	set r {
	    Relation
	    {A string B string}
	    {{A B}}
	    {
		{A root B n1}
		{A root B n2}
		{A n1 B n3}
		{A n1 B n4}
		{A n2 B n5}
		{A n2 B n6}
	    }
	}
	relation tclose $r
    } -result {
	Relation
	{A string B string}
	{{A B}}
	{
	    {A root B n1}
	    {A root B n2}
	    {A root B n3}
	    {A root B n4}
	    {A root B n5}
	    {A root B n6}
	    {A n1 B n3}
	    {A n1 B n4}
	    {A n2 B n5}
	    {A n2 B n6}
	}
    } -match relation

    test relation-tclose-4.1 {reverse tree} -body {
	set r {
	    Relation
	    {B string A string}
	    {{B A}}
	    {
		{A root B n1}
		{A root B n2}
		{A n1 B n3}
		{A n1 B n4}
		{A n2 B n5}
		{A n2 B n6}
	    }
	}
	relation tclose $r
    } -result {
	Relation
	{A string B string}
	{{A B}}
	{
	    {A root B n1}
	    {A root B n2}
	    {A root B n3}
	    {A root B n4}
	    {A root B n5}
	    {A root B n6}
	    {A n1 B n3}
	    {A n1 B n4}
	    {A n2 B n5}
	    {A n2 B n6}
	}
    } -match relation

    # relation times subcommand
    test relation-times-1.0 {single attribute, square relation} -body {
	set r1 {Relation {Name string} Name {{Name Andrew}}}
	set r2 {Relation {XName string} XName {{XName Andrew}}}
	relation times $r1 $r2
    } -result {
	Relation
	{Name string XName string}
	{{Name XName}}
	{
	    {Name Andrew XName Andrew}
	}
    } -match relation

    test relation-times-2.0 {single attribute times dee} -body {
	set r1 {Relation {Name string} Name {{Name Andrew}}}
	relation times $r1 $DEE
    } -result {Relation {Name string} Name {{Name Andrew}}}\
    -match relation

    test relation-times-3.0 {single attribute times dum} -body {
	set r1 {Relation {Name string} Name {{Name Andrew}}}
	relation times $r1 $DUM
    } -result {Relation {Name string} Name {}} -match relation

    test relation-times-4.0 {single attribute, cube relation} -body {
	set r1 {Relation {Name string} Name {{Name Andrew}}}
	set r2 {Relation {XName string} XName {{XName Andrew}}}
	set r3 {Relation {YName string} YName {{YName Andrew}}}
	relation times $r1 $r2 $r3
    } -result {
	Relation
	{Name string XName string YName string}
	{{Name XName YName}}
	{
	    {Name Andrew XName Andrew YName Andrew}
	}
    } -match relation

    test relation-times-5.0 {multiple attributes, square relation} -body {
	set r1 {Relation {Name string} Name {{Name Andrew} {Name George}}}
	set r2 {Relation {Status int} Status {{Status 20} {Status 30}}}
	relation times $r1 $r2
    } -result {
	Relation
	{Name string Status int}
	{{Name Status}}
	{
	    {Name Andrew Status 20}
	    {Name Andrew Status 30}
	    {Name George Status 20}
	    {Name George Status 30}
	}
    } -match relation

    test relation-times-6.0 {attribute name conflict} -body {
	set r1 {Relation {Name string} Name {{Name Andrew}}}
	relation times $r1 $r1
    } -result {duplicate attribute name, "Relation {Name string} Name {{Name Andrew}}"}\
    -returnCodes error

    test relation-times-6.1 {attribute name conflict, third relation} -body {
	set r1 {Relation {Name string} Name {{Name Andrew}}}
	set r2 {Relation {Status int} Status {{Status 20} {Status 30}}}
	relation times $r1 $r2 $r1
    } -result {duplicate attribute name, "Relation {Name string} Name {{Name Andrew}}"}\
    -returnCodes error

    # relation tuple subcommand
    test relation-tuple-1.0 {single attribute} -body {
	set t [relation tuple {Relation {Name string} Name {{Name Andrew}}}]
	tuple equal $t {Tuple {Name string} {Name Andrew}}
    } -result 1

    test relation-tuple-2.0 {multiple attributes} -body {
	set r {Relation {Name string Age int} Name {{Name Andrew Age 20}}}
	set t [relation tuple $r]
	tuple equal $t {Tuple {Name string Age int} {Name Andrew Age 20}}
    } -result 1

    test relation-tuple-3.0 {body too long} -body {
	set r {Relation {Name string Age int} Name\
	    {{Name Andrew Age 20} {Name George Age 20}}}
	relation tuple $r
    } -result {relation must have cardinality of one, "Relation {Name string Age int} Name {{Name Andrew Age 20} {Name George Age 20}}"} -returnCodes error

    # relation ungroup subcommand
    test relation-ungroup-1.0 {two attribute relation} -body {
	set r {
	    Relation
	    {Name string
		Dog {Relation {DogName string Breed string} DogName}
	    }
	    Name
	    {
		{Name Fred Dog {
		    {DogName Rover Breed Terrier}
		    {DogName Missy Breed Poodle}}
		}
		{Name Alice Dog {
		    {DogName Tiger Breed Setter}}
		}
	    }
	}
	relation ungroup $r Dog
    } -result {
	Relation
	{Name string DogName string Breed string}
	{{Name DogName}}
	{
	    {Name Fred DogName Rover Breed Terrier}
	    {Name Fred DogName Missy Breed Poodle}
	    {Name Alice DogName Tiger Breed Setter}
	}
    } -match relation

    test relation-ungroup-2.0 {duplicate attribute name} -body {
	set r {
	    Relation
	    {Name string Dog {Relation {Name string Breed string} Name}}
	    Name
	    {
		{Name Fred Dog {
		    {Name Rover Breed Terrier}
		    {Name Missy Breed Poodle}}
		}
		{Name Alice Dog {{Name Tiger Breed Setter}}}
	    }
	}
	relation ungroup $r Dog
    } -result {duplicate attribute name, "during ungroup operation"}\
    -returnCodes error

    test relation-ungroup-2.1 {unknown attribute name} -body {
	set r {
	    Relation
	    {Name string Dog {Relation {Name string Breed string} Name}}
	    Name
	    {
		{Name Fred Dog
		    {
			{Name Rover Breed Terrier}
			{Name Missy Breed Poodle}
		    }
		}
		{Name Alice Dog {{Name Tiger Breed Setter}}
		}
	    }
	}
	relation ungroup $r Weight
    } -result {unknown attribute name, "during ungroup operation"}\
    -returnCodes error

    test relation-ungroup-2.2 {attribute not a relation} -body {
	set r {
	    Relation
	    {Name string Dog {Relation {Name string Breed string} Name}}
	    Name
	    {
		{Name Fred Dog
		    {
			{Name Rover Breed Terrier}
			{Name Missy Breed Poodle}
		    }
		}
		{Name Alice Dog {{Name Tiger Breed Setter}}
		}
	    }
	}
	relation ungroup $r Name
    } -result\
	{attribute must be of a Relation type, "during ungroup operation"}\
    -returnCodes error

    test relation-ungroup-3.0 {common tuples in the relation attribute} -body {
	set r {
	    Relation
	    {Name string Dog {Relation {DogName string Breed string} DogName}}
	    {{Name Dog}}
	    {
		{Name Fred Dog {
		    {DogName Rover Breed Terrier}
		    {DogName Missy Breed Poodle}}
		}
		{Name Fred Dog {{DogName Rover Breed Terrier}}}
	    }
	}
	relation ungroup $r Dog
    } -result {
	Relation
	{Name string DogName string Breed string}
	{{Name DogName}}
	{
	    {Name Fred DogName Rover Breed Terrier}
	    {Name Fred DogName Missy Breed Poodle}
	}
    } -match relation

    test relation-ungroup-4.0 {attributes beyond ungrouped attribute} -body {
	set r {
	    Relation
	    {Name string Dog {
		Relation
		{DogName string Breed string}
		DogName} Weight int}
	    Name
	    {
		{Name Fred Dog {
			{DogName Rover Breed Terrier}
			{DogName Missy Breed Poodle}} Weight 20
		}
		{Name Alice Dog {
			{DogName Tiger Breed Setter}} Weight 40
		}
	    }
	}
	relation ungroup $r Dog
    } -result {
	Relation
	{Name string Weight int DogName string Breed string}
	{{Name DogName}}
	{
	    {Name Fred Weight 20 DogName Rover Breed Terrier}
	    {Name Fred Weight 20 DogName Missy Breed Poodle}
	    {Name Alice Weight 40 DogName Tiger Breed Setter}
	}
    } -match relation

    test relation-ungroup-5.0 {ungroup; functionally dependent} -setup {
	set two {
	    Relation
	    {A int RVX {Relation {X string} X}}
	    {{A RVX}}
	    {
		{A 1 RVX {{X a} {X b}}}
		{A 1 RVX {{X a} {X c}}}
	    }
	}
    } -body {
	relation ungroup $two RVX
    } -result {
	Relation
	{A int X string}
	{{A X}}
	{
	    {A 1 X a}
	    {A 1 X b}
	    {A 1 X c}
	}
    } -match relation

    # relation union subcommand
    test relation-union-1.0 {dum relation} -body {
	relation union $DUM $DUM
    } -result {Relation {} {{}} {}} -match relation

    test relation-union-2.0 {dee relation} -body {
	relation union $DEE $DEE
    } -result {Relation {} {{}} {{}}} -match relation

    test relation-union-3.0 {disjoint sets} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Name George Age 20 City {San Jose}}}}
	relation union $r1 $r2
    } -result {Relation {Name string Age int City string} Name\
	{{Name Andrew Age 30 City Sunnyvale}\
	 {Name George Age 20 City {San Jose}}}}\
     -match relation

    test relation-union-4.0 {relations with common tuples} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}\
	    {Name George Age 20 City {San Jose}}}}
	relation union $r1 $r2
    } -result {
	Relation
	{Name string Age int City string}
	Name
	{
	    {Name Andrew Age 30 City Sunnyvale}
	    {Name George Age 20 City {San Jose}}
	}
    } -match relation

    test relation-union-5.0 {union of more than two relations} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Name George Age 20 City {San Jose}}}}
	set r3 {Relation {Name string Age int City string} Name\
	    {{Name Fred Age 10 City Saratoga}}}
	relation union $r1 $r2 $r3
    } -result {
	Relation
	{Name string Age int City string}
	Name
	{
	    {Name Andrew Age 30 City Sunnyvale}
	    {Name George Age 20 City {San Jose}}
	    {Name Fred Age 10 City Saratoga}
	}
    } -match relation

    test relation-union-6.0 {union of more than two, common tuples } -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}}}
	set r2 {Relation {Name string Age int City string} Name\
	    {{Name George Age 20 City {San Jose}}\
	    {Name Andrew Age 30 City Sunnyvale}}}
	set r3 {Relation {Name string Age int City string} Name\
	    {{Name George Age 20 City {San Jose}}\
	    {Name Fred Age 10 City Saratoga}}}
	relation union $r1 $r2 $r3
    } -result {
	Relation
	{Name string Age int City string}
	Name
	{
	    {Name Andrew Age 30 City Sunnyvale}
	    {Name George Age 20 City {San Jose}}
	    {Name Fred Age 10 City Saratoga}
	}
    } -match relation

    test relation-union-7.0 {type mismatch} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}}}
	set r2 {Relation {Name string City string} Name\
	    {{Name George City {San Jose}}}}
	relation union $r1 $r2
    } -result {headings not equal, "Relation {Name string City string} Name {{Name George City {San Jose}}}"}\
    -returnCodes error

    test relation-union-8.0 {equal headings of different order} -body {
	set r1 {Relation {Name string Age int City string} Name\
	    {{Name Andrew Age 30 City Sunnyvale}}}
	set r2 {Relation {Age int Name string City string} Name\
	    {{Name George Age 20 City {San Jose}}}}
	relation union $r1 $r2
    } -result {
	Relation
	{Name string Age int City string}
	Name
	{
	    {Name Andrew Age 30 City Sunnyvale}
	    {Name George Age 20 City {San Jose}}
	}
    } -match relation

    # relvar Tests

    # relvar association subcommand
    test relvar-association-1.1 {one to one} -setup {
	relvar create A {Relation {A1 string A2 int} A1}
	relvar create B {Relation {B1 string B2 string} B1}
	relvar association R1 A A1 1 B B1 1
    } -cleanup {
	relvar constraint delete R1
	relvar destroy A B
    } -body {
	relvar eval {
	    relvar insert A {A1 a A2 42}
	    relvar insert B {B1 a B2 foo}
	}
    } -result {Relation {B1 string B2 string} B1 {{B1 a B2 foo}}}

    test relvar-association-1.2 {one to one -- fail referring} -setup {
	relvar create A {Relation {A1 string A2 int} A1}
	relvar create B {Relation {B1 string B2 string} B1}
	relvar association R1 A A1 1 B B1 1
    } -cleanup {
	relvar constraint delete R1
	relvar destroy A B
    } -body {
	relvar insert A {A1 b A2 42}
    } -result {for association R1(::ral::test::A [1] ==> [1] ::ral::test::B), in relvar ::ral::test::A
tuple {A1 b A2 42} references no tuple} -returnCodes error

    test relvar-association-1.3 {one to one -- fail referred to} -setup {
	relvar create A {Relation {A1 string A2 int} A1}
	relvar create B {Relation {B1 string B2 string} B1}
	relvar association R1 A A1 1 B B1 1
    } -cleanup {
	relvar constraint delete R1
	relvar destroy A B
    } -body {
	relvar insert B {B1 b B2 bar}
    } -result {for association R1(::ral::test::A [1] ==> [1] ::ral::test::B), in relvar ::ral::test::B
tuple {B1 b B2 bar} is not referenced by any tuple} -returnCodes error

    test relvar-association-2.1 {one conditional to one} -setup {
	relvar create C {Relation {C1 string C2 int} C1}
	relvar create D {Relation {D1 string D2 string} D1}
	relvar association R2 C C1 0..1 D D1 1
    } -cleanup {
	relvar constraint delete R2
	relvar destroy C D
    } -body {
	relvar eval {
	    relvar insert C {C1 a C2 42}
	    relvar insert D {D1 a D2 foo}
	    relvar insert D {D1 b D2 foo}
	}
    } -result {Relation {D1 string D2 string} D1 {{D1 a D2 foo} {D1 b D2 foo}}}

    test relvar-association-2.2 {one conditional to one -- fail} -setup {
	relvar create C {Relation {C1 string C2 int} C1}
	relvar create D {Relation {D1 string D2 string} D1}
	relvar association R2 C C1 0..1 D D1 1
    } -cleanup {
	relvar constraint delete R2
	relvar destroy C D
    } -body {
	relvar eval {
	    relvar insert C {C1 a C2 42}
	    relvar insert D {D1 a D2 foo}
	    relvar insert D {D1 b D2 foo}
	    relvar insert C {C1 c C2 42}
	}
    } -result {for association R2(::ral::test::C [0..1] ==> [1] ::ral::test::D), in relvar ::ral::test::C
tuple {C1 c C2 42} references no tuple} -returnCodes error

    test relvar-association-3.1 {one conditional to one conditional} -setup {
	relvar create C {Relation {C1 string C2 int} C1}
	relvar create D {Relation {D1 string D2 string} D1}
	relvar association R2 C C1 0..1 D D1 0..1
    } -cleanup {
	relvar constraint delete R2
	relvar destroy C D
    } -body {
	relvar eval {
	    relvar insert C {C1 a C2 42}
	    relvar insert C {C1 c C2 22}
	    relvar insert D {D1 a D2 foo}
	    relvar insert D {D1 b D2 bar}
	}
    } -result {Relation {D1 string D2 string} D1 {{D1 a D2 foo} {D1 b D2 bar}}}

    test relvar-association-4.1 {many to one} -setup {
	relvar create A {Relation {A1 string BID string} A1}
	relvar create B {Relation {B1 string B2 string} B1}
	relvar association R1 A BID 1..* B B1 1
    } -cleanup {
	relvar constraint delete R1
	relvar destroy A B
    } -body {
	relvar eval {
	    relvar insert A {A1 a BID a}
	    relvar insert A {A1 b BID b}
	    relvar insert A {A1 c BID a}
	    relvar insert A {A1 d BID b}
	    relvar insert B {B1 a B2 foo}
	    relvar insert B {B1 b B2 foo}
	}
    } -result {Relation {B1 string B2 string} B1 {{B1 a B2 foo} {B1 b B2 foo}}}

    test relvar-association-4.2 {many to one -- fail referring} -setup {
	relvar create A {Relation {A1 string BID string} A1}
	relvar create B {Relation {B1 string B2 string} B1}
	relvar association R1 A BID 1..* B B1 1
    } -cleanup {
	relvar constraint delete R1
	relvar destroy A B
    } -body {
	relvar eval {
	    relvar insert A {A1 a BID a}
	    relvar insert A {A1 b BID b}
	    relvar insert A {A1 c BID a}
	    relvar insert A {A1 d BID c}
	    relvar insert B {B1 a B2 foo}
	    relvar insert B {B1 b B2 foo}
	}
    } -result {for association R1(::ral::test::A [1..*] ==> [1] ::ral::test::B), in relvar ::ral::test::A
tuple {A1 d BID c} references no tuple} -returnCodes error

    test relvar-association-4.3 {many to one -- fail referred to} -setup {
	relvar create A {Relation {A1 string BID string} A1}
	relvar create B {Relation {B1 string B2 string} B1}
	relvar association R1 A BID 1..* B B1 1
    } -cleanup {
	relvar constraint delete R1
	relvar destroy A B
    } -body {
	relvar eval {
	    relvar insert A {A1 a BID a}
	    relvar insert A {A1 b BID b}
	    relvar insert A {A1 c BID a}
	    relvar insert A {A1 d BID b}
	    relvar insert B {B1 a B2 foo}
	    relvar insert B {B1 b B2 foo}
	    relvar insert B {B1 c B2 foo}
	}
    } -result {for association R1(::ral::test::A [1..*] ==> [1] ::ral::test::B), in relvar ::ral::test::B
tuple {B1 c B2 foo} is not referenced by any tuple} -returnCodes error

    test relvar-association-5.1 {many conditional to one} -setup {
	relvar create A {Relation {A1 string BID string} A1}
	relvar create B {Relation {B1 string B2 string} B1}
	relvar association R1 A BID 0..* B B1 1
    } -cleanup {
	relvar constraint delete R1
	relvar destroy A B
    } -body {
	relvar eval {
	    relvar insert A {A1 a BID a}
	    relvar insert A {A1 b BID b}
	    relvar insert A {A1 c BID a}
	    relvar insert A {A1 d BID b}
	    relvar insert B {B1 a B2 foo}
	    relvar insert B {B1 b B2 foo}
	    relvar insert B {B1 c B2 foo}
	}
    } -result {Relation {B1 string B2 string} B1 {{B1 a B2 foo} {B1 b B2 foo} {B1 c B2 foo}}}

    test relvar-association-5.2 {many to one conditional} -setup {
	relvar create A {Relation {A1 string BID string} A1}
	relvar create B {Relation {B1 string B2 string} B1}
	relvar association R1 A BID 1..* B B1 0..1
    } -cleanup {
	relvar constraint delete R1
	relvar destroy A B
    } -body {
	relvar eval {
	    relvar insert A {A1 a BID a}
	    relvar insert A {A1 b BID b}
	    relvar insert A {A1 c BID a}
	    relvar insert A {A1 d BID b}
	    relvar insert A {A1 e BID {}}
	    relvar insert B {B1 a B2 foo}
	    relvar insert B {B1 b B2 foo}
	}
    } -result {Relation {B1 string B2 string} B1 {{B1 a B2 foo} {B1 b B2 foo}}}

    test relvar-association-5.3 {many conditional to one conditional} -setup {
	relvar create A {Relation {A1 string BID string} A1}
	relvar create B {Relation {B1 string B2 string} B1}
	relvar association R1 A BID 0..* B B1 0..1
    } -cleanup {
	relvar constraint delete R1
	relvar destroy A B
    } -body {
	relvar eval {
	    relvar insert A {A1 a BID a}
	    relvar insert A {A1 b BID b}
	    relvar insert A {A1 c BID a}
	    relvar insert A {A1 d BID b}
	    relvar insert A {A1 e BID {}}
	    relvar insert B {B1 a B2 foo}
	    relvar insert B {B1 b B2 foo}
	    relvar insert B {B1 c B2 foo}
	}
    } -result {Relation {B1 string B2 string} B1 {{B1 a B2 foo} {B1 b B2 foo} {B1 c B2 foo}}}

    test relvar-association-6.1 {duplicate names} -setup {
	relvar create A {Relation {A1 string BID string} A1}
	relvar create B {Relation {B1 string B2 string} B1}
    } -body {
	relvar association R1 A BID 0..* B B1 0..1
	relvar association R1 A BID 0..* B B1 0..1
    } -cleanup {
	relvar constraint delete R1
	relvar destroy A B
    } -result {duplicate constraint name, "R1"} -returnCodes error

    test relvar-association-6.2 {bad cond / mult spec} -setup {
	relvar create A {Relation {A1 string BID string} A1}
	relvar create B {Relation {B1 string B2 string} B1}
    } -body {
	relvar association R1 A BID 0..X B B1 0..1
    } -cleanup {
	relvar destroy A B
    } -result {bad multiplicity specification "0..X": must be 1, 1..*, 0..1, or 0..*} -returnCodes error

    test relvar-association-6.3 {bad multiplicity} -setup {
	relvar create A {Relation {A1 string BID string} A1}
	relvar create B {Relation {B1 string B2 string} B1}
    } -body {
	relvar association R1 A BID 0..* B B1 0..*
    } -cleanup {
	relvar destroy A B
    } -result {referred to identifiers can not have non-singular multiplicities, "0..*"} -returnCodes error

    # relvar constraint subcommand
    test relvar-constraint-1.1 {constraint names} -setup {
	relvar create A {Relation {A1 string BID1 string BID2 int} A1}
	relvar create B {Relation {B1 string B2 int} {B1 B2}}
	relvar association R3 A BID1 0..* B B1 0..1
	relvar association R4 A BID2 0..* B B2 0..1
    } -cleanup {
	relvar constraint delete R3 R4
	relvar destroy A B
    } -body {
	lsort [relvar constraint names]
    } -result {R3 R4}

    test relvar-constraint-2.1 {constraint info -- association} -setup {
	relvar create A {Relation {A1 string BID1 string BID2 int} A1}
	relvar create B {Relation {B1 string B2 int} {B1 B2}}
	relvar association R3 A BID1 0..* B B1 0..1
    } -cleanup {
	relvar constraint delete R3
	relvar destroy A B
    } -body {
	relvar constraint info R3
    } -result {association R3 ::ral::test::A BID1 0..* ::ral::test::B B1 0..1}

    test relvar-constraint-2.2 {constraint info -- partition} -setup {
	relvar create A {Relation {A1 string} A1}
	relvar create B {Relation {B1 string} B1}
	relvar create C {Relation {C1 string} C1}
	relvar partition R1 A A1 B B1 C C1
    } -cleanup {
	relvar constraint delete R1
	relvar destroy A B C
    } -body {
	relvar constraint info R1
    } -result {partition R1 ::ral::test::A A1 ::ral::test::B B1 ::ral::test::C C1}

    # relvar create subcommand
    test relvar-create-1.0 {single attribute} -body {
	relvar create N {Relation {Name string} Name}
    } -cleanup {
	relvar destroy N
    } -result {Relation {Name string} Name {}} -match relation

    # relvar delete subcommand
    test relvar-delete-1.0 {expression is false} -setup {
	relvar create X {
	    Relation
	    {Name string Status int}
	    Name
	}
	relvar insert X\
	    {Name George Status 20}\
	    {Name Fred Status 30}\
	    {Status 40 Name Alice}
    } -cleanup {
	relvar destroy X
    } -body {
	relvar delete X t {0}
    } -result {0}

    test relvar-delete-2.0 {expression is true} -setup {
	relvar create X {
	    Relation
	    {Name string Status int}
	    Name
	}
	relvar insert X\
	    {Name George Status 20}\
	    {Name Fred Status 30}\
	    {Status 40 Name Alice}
    } -cleanup {
	relvar destroy X
    } -body {
	relvar delete X t {1}
    } -result {3}

    test relvar-delete-3.0 {subset is deleted} -setup {
	relvar create X {
	    Relation
	    {Name string Status int}
	    Name
	}
	relvar insert X\
	    {Name George Status 20}\
	    {Name Fred Status 30}\
	    {Status 40 Name Alice}
    } -cleanup {
	relvar destroy X
    } -body {
	relvar delete X t {[tuple extract $t Name] eq "George"}
    } -result {1}

    # relvar deleteone subcommand
    test relvar-deleteone-1.0 {no match} -setup {
	relvar create X {
	    Relation
	    {Name string Status int}
	    Name
	}
	relvar insert X\
	    {Name George Status 20}\
	    {Name Fred Status 30}\
	    {Status 40 Name Alice}
    } -cleanup {
	relvar destroy X
    } -body {
	relvar deleteone X Name Jane
    } -result {0}

    test relvar-deleteone-2.0 {match} -setup {
	relvar create X {
	    Relation
	    {Name string Status int}
	    Name
	}
	relvar insert X\
	    {Name George Status 20}\
	    {Name Fred Status 30}\
	    {Status 40 Name Alice}
    } -cleanup {
	relvar destroy X
    } -body {
	relvar deleteone X Name Fred
    } -result {1}

    test relvar-deleteone-3.0 {bad identifier} -setup {
	relvar create X {
	    Relation
	    {Name string Status int}
	    Name
	}
	relvar insert X\
	    {Name George Status 20}\
	    {Name Fred Status 30}\
	    {Status 40 Name Alice}
    } -cleanup {
	relvar destroy X
    } -body {
	relvar deleteone X Status 30
    } -result {attributes do not constitute an identifier, "during find operation"}\
    -returnCodes error

    # relvar partition subcommand
    test relvar-partition-1.1 {simple partition} -setup {
	relvar create A {Relation {A1 string} A1}
	relvar create B {Relation {B1 string} B1}
	relvar create C {Relation {C1 string} C1}
    } -cleanup {
	relvar constraint delete R1
	relvar destroy A B C
    } -body {
	relvar partition R1 A A1 B B1 C C1
    } -result {}

    test relvar-partition-1.2 {unknown relvar} -setup {
	relvar create A {Relation {A1 string} A1}
	relvar create B {Relation {B1 string} B1}
    } -cleanup {
	relvar destroy A B
    } -body {
	relvar partition R1 A A1 B B1 C C1
    } -result {unknown relvar name, "C"} -returnCodes error

    test relvar-partition-1.3 {unknown attribute} -setup {
	relvar create A {Relation {A1 string} A1}
	relvar create B {Relation {B1 string} B1}
	relvar create C {Relation {C1 string} C1}
    } -cleanup {
	relvar destroy A B C
    } -body {
	relvar partition R1 A A1 B B1 C C2
    } -result {unknown attribute name, "C2"} -returnCodes error

    test relvar-partition-1.4 {not an identifier } -setup {
	relvar create A {Relation {A1 string A2 int} A1}
	relvar create B {Relation {B1 string} B1}
	relvar create C {Relation {C1 string} C1}
    } -cleanup {
	relvar destroy A B C
    } -body {
	relvar partition R1 A A2 B B1 C C2
    } -result {referred to attributes do not form an identifier, "A2"}\
    -returnCodes error

    test relvar-partition-2.1 {passes constraints} -setup {
	relvar create A {Relation {A1 string} A1}
	relvar create B {Relation {B1 string} B1}
	relvar create C {Relation {C1 string} C1}
	relvar partition R1 A A1 B B1 C C1
    } -cleanup {
	relvar constraint delete R1
	relvar destroy A B C
    } -body {
	relvar eval {
	    relvar insert A {A1 b} {A1 c}
	    relvar insert B {B1 b}
	    relvar insert C {C1 c}
	}
    } -result {Relation {C1 string} C1 {{C1 c}}}

    test relvar-partition-2.2 {missing subtype} -setup {
	relvar create A {Relation {A1 string} A1}
	relvar create B {Relation {B1 string} B1}
	relvar create C {Relation {C1 string} C1}
	relvar partition R1 A A1 B B1 C C1
    } -cleanup {
	relvar constraint delete R1
	relvar destroy A B C
    } -body {
	relvar eval {
	    relvar insert A {A1 b} {A1 c}
	    relvar insert B {B1 b}
	}
    } -result {for partition R1(::ral::test::A is partitioned [::ral::test::B | ::ral::test::C]), in relvar ::ral::test::A
tuple {A1 c} is not referred to by any tuple}\
    -returnCodes error

    test relvar-partition-2.3 {extra super type reference} -setup {
	relvar create A {Relation {A1 string} A1}
	relvar create B {Relation {B1 string} B1}
	relvar create C {Relation {C1 string} C1}
	relvar partition R1 A A1 B B1 C C1
    } -cleanup {
	relvar constraint delete R1
	relvar destroy A B C
    } -body {
	relvar eval {
	    relvar insert A {A1 b}
	    relvar insert B {B1 b}
	    relvar insert C {C1 b}
	}
    } -result {for partition R1(::ral::test::A is partitioned [::ral::test::B | ::ral::test::C]), in relvar ::ral::test::A
tuple {A1 b} is referred to by multiple tuples}\
    -returnCodes error

    # relvar set subcommand
    test relvar-set-1.0 {single attribute} -body {
	relvar create SV {
	    Relation
	    {S# string SNAME string STATUS int CITY string}
	    S#
	}
	relvar set SV $S
    } -cleanup {
	relvar destroy SV
    } -result {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
	{
	    {S# S1 SNAME Smith STATUS 20 CITY London}
	    {S# S2 SNAME Jones STATUS 10 CITY Paris}
	    {S# S3 SNAME Blake STATUS 30 CITY Paris}
	    {S# S4 SNAME Clark STATUS 20 CITY London}
	    {S# S5 SNAME Adams STATUS 30 CITY Athens}
	}
    } -match relation

    # relvar eval subcommand
    test relvar-eval-1.0 {simple body} -setup {
	relvar create SV {
	    Relation
	    {S# string SNAME string STATUS int CITY string}
	    S#
	}
    } -body {
	relvar eval {
	    relvar set SV $S
	}
    } -cleanup {
	relvar destroy SV
    } -result {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
	{
	    {S# S1 SNAME Smith STATUS 20 CITY London}
	    {S# S2 SNAME Jones STATUS 10 CITY Paris}
	    {S# S3 SNAME Blake STATUS 30 CITY Paris}
	    {S# S4 SNAME Clark STATUS 20 CITY London}
	    {S# S5 SNAME Adams STATUS 30 CITY Athens}
	}
    } -match relation

    test relvar-eval-1.1 {break out of eval} -setup {
	relvar create SV {
	    Relation
	    {S# string SNAME string STATUS int CITY string}
	    S#
	}
    } -body {
	while 1 {
	    relvar eval {
		relvar insert SV {S# S1 SNAME Smith STATUS 20 CITY London}
		if {[catch {relvar insert SV\
		    {S# S1 SNAME Smith STATUS 20 CITY London}}]} {
		    break ;
		}
	    }
	}
	set SV
    } -cleanup {
	relvar destroy SV
    } -result {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
	{
	    {S# S1 SNAME Smith STATUS 20 CITY London}
	}
    } -match relation

    test relvar-eval-1.2 {continue out of eval} -setup {
	relvar create SV {
	    Relation
	    {S# string SNAME string STATUS int CITY string}
	    S#
	}
    } -body {
	set id 0
	foreach status {10 20 30} {
	    relvar eval {
		if {$status == 20} {
		    continue ;
		}
		relvar insert SV [list\
		    S# S[incr id] SNAME Smith STATUS $status CITY London\
		]
	    }
	}
	set SV
    } -cleanup {
	relvar destroy SV
    } -result {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
	{
	    {S# S1 SNAME Smith STATUS 10 CITY London}
	    {S# S2 SNAME Smith STATUS 30 CITY London}
	}
    } -match relation

    test relvar-eval-1.3 {return out of eval} -setup {
	relvar create SV {
	    Relation
	    {S# string SNAME string STATUS int CITY string}
	    S#
	}
    } -body {
	while 1 {
	    relvar eval {
		relvar insert SV {S# S1 SNAME Smith STATUS 20 CITY London}
		if {[catch {relvar insert SV\
		    {S# S1 SNAME Smith STATUS 20 CITY London}}]} {
		    return $SV
		}
	    }
	}
    } -cleanup {
	relvar destroy SV
    } -result {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
	{
	    {S# S1 SNAME Smith STATUS 20 CITY London}
	}
    } -match relation

    # relvar insert subcommand
    test relvar-insert-1.0 {insert single tuple} -setup {
	relvar create N {Relation {Name string Age int City string} Name}
    } -cleanup {
	relvar destroy N
    } -body {
	relvar insert N {Name Andrew Age 20 City Sunnyvale}
    } -result {
	Relation
	{Name string Age int City string}
	Name
	{
	    {Name Andrew Age 20 City Sunnyvale}
	}
    } -match relation

    test relvar-insert-2.0 {insert multiple tuples} -setup {
	relvar create N {Relation {Name string Age int City string} Name}
    } -cleanup {
	relvar destroy N
    } -body {
	relvar insert N\
	    {Name Andrew Age 20 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {Name Fred City Saratoga Age 20}
    } -result {
	Relation
	{Name string Age int City string}
	Name
	{
	    {Name Andrew Age 20 City Sunnyvale}
	    {Name George Age 20 City {San Jose}}
	    {Name Fred Age 20 City Saratoga}
	}
    } -match relation

    test relvar-insert-3.0 {duplicate tuple} -setup {
	relvar create N {Relation {Name string Age int City string} Name}
    } -cleanup {
	relvar destroy N
    } -body {
	relvar insert N\
	    {Name Andrew Age 20 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {Name Andrew City Sunnyvale Age 20}
    } -result {duplicate tuple, "Name Andrew City Sunnyvale Age 20"}\
    -returnCodes error

    test relvar-insert-4.0 {value preserved on error} -setup {
	relvar create N {Relation {Name string Age int City string} Name}
	relvar insert N\
	    {Name Andrew Age 20 City Sunnyvale}\
	    {Age 20 Name George City {San Jose}}\
	    {Name Fred City Saratoga Age 20}
    } -cleanup {
	relvar destroy N
    } -body {
	catch {relvar insert N {Name Andrew Age 20 City Sunnyvale}}
	relvar set N
    } -result {
	Relation
	{Name string Age int City string}
	Name
	{
	    {Name Andrew Age 20 City Sunnyvale}
	    {Name George Age 20 City {San Jose}}
	    {Name Fred Age 20 City Saratoga}
	}
    } -match relation

    # relvar names subcommand
    test relvar-names-1.0 {simple list of names} -setup {
	relvar create SV {
	    Relation
	    {S# string SNAME string STATUS int CITY string}
	    S#
	}
	relvar create PV {
	    Relation
	    {P# string PNAME string COLOR string WEIGHT double CITY string}
	    P#
	}
	relvar create SPV {
	    Relation
	    {S# string P# string QTY int}
	    {{S# P#}}
	}
    } -body {
	lsort [relvar names]
    } -cleanup {
	relvar destroy SV PV SPV
    } -result {::ral::test::PV ::ral::test::SPV ::ral::test::SV}

    # examples from the Date book
    test date-example-1.0 {Get suppliers who supply all parts} -body {
	set pnums [relation project $P P#]
	relation restrict $S sx\
	    {[relation is\
		[relation project\
		    [relation restrict $SP spx\
		    {[tuple extract $spx S#] eq [tuple extract $sx S#]}] P#]\
	    equal $pnums]}
    } -result {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
	{
	    {S# S1 SNAME Smith STATUS 20 CITY London}
	}
    } -match relation

    test date-example-2.0 {Get suppliers who supply all parts (divide)}\
    -body {
	relation join\
	    [relation divide\
		[relation project $S S#]\
		[relation project $P P#]\
		[relation project $SP S# P#]] $S
    } -result {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
	{
	    {S# S1 SNAME Smith STATUS 20 CITY London}
	}
    } -match relation

    test date-example-3.0\
	{Get supplier names for suppliers who supply part P2} -body {
	relation project\
	    [relation restrictwith [relation join $SP $S]\
		{${P#} eq "P2"}] SNAME
    } -result {
	Relation
	{SNAME string}
	SNAME
	{
	     {SNAME Smith}
	     {SNAME Jones}
	     {SNAME Blake}
	     {SNAME Clark}
	}
    } -match relation

    test date-example-3.1\
	{Get supplier names for suppliers who supply part P2} -body {
	# use semijoin
	set p2 [relation restrictwith $P {${P#} eq "P2"}]
	relation project [relation semijoin $p2 $SP $S] SNAME
    } -result {
	Relation
	{SNAME string}
	SNAME
	{
	     {SNAME Smith}
	     {SNAME Jones}
	     {SNAME Blake}
	     {SNAME Clark}
	}
    } -match relation

    test date-example-4.0 {Get supplier name for suppliers who supply at\
    least one red part} -body {
	relation project\
	    [relation join\
		[relation project\
		    [relation join\
			[relation restrictwith $P {$COLOR eq "Red"}]\
			$SP]\
		    S#]\
		$S]\
	    SNAME
    } -result {
	Relation
	{SNAME string}
	SNAME
	{
	     {SNAME Smith}
	     {SNAME Jones}
	     {SNAME Clark}
	}
    } -match relation

    test date-example-4.1 {Get supplier name for suppliers who supply at\
    least one red part} -body {
	# use semijoin
	set redPart [relation restrictwith $P {$COLOR eq "Red"}]
	relation project [relation semijoin $redPart $SP $S] SNAME
    } -result {
	Relation
	{SNAME string}
	SNAME
	{
	     {SNAME Smith}
	     {SNAME Jones}
	     {SNAME Clark}
	}
    } -match relation

    test date-example-6.0 {Get all pairs of supplier numbers such that\
	the suppliers concerned are colocated} -body {
	relation project\
	    [relation restrictwith\
		[relation join\
		    [relation project [relation rename $S S# SA] SA CITY]\
		    [relation project [relation rename $S S# SB] SB CITY]\
		]\
		{[string compare $SA $SB] < 0}\
	    ]\
	SA SB
    } -result {
	Relation
	{SA string SB string}
	{{SA SB}}
	{
	    {SA S1 SB S4}
	    {SA S2 SB S3}
	}
    } -match relation

    test date-example-7.0 {Get supplier info for suppliers who supply part P2}\
    -body {
	relation semijoin\
	    [relation restrict $SP r1 {[tuple extract $r1 P#] eq "P2"}] $S
    } -result {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
	{
	    {S# S1 SNAME Smith STATUS 20 CITY London}
	    {S# S2 SNAME Jones STATUS 10 CITY Paris}
	    {S# S3 SNAME Blake STATUS 30 CITY Paris}
	    {S# S4 SNAME Clark STATUS 20 CITY London}
	}
    } -match relation

    test date-example-8.0 {Get supplier info for suppliers who do not\
	supply part P2} -body {
	relation semiminus [relation restrictwith $SP {${P#} eq "P2"}] $S
    } -result {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
	{
	    {S# S5 SNAME Adams STATUS 30 CITY Athens}
	}
    } -match relation

    cleanupTests
}

namespace delete ::ral::test
