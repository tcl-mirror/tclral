<html><head>
<title>relation - Relation Operators</title>
<style type="text/css"><!--
    HTML {
	background: 	#FFFFFF;
	color: 		black;
    }
    BODY {
	background: 	#FFFFFF;
	color:	 	black;
    }
    DIV.doctools {
	margin-left:	10%;
	margin-right:	10%;
    }
    DIV.doctools H1,DIV.doctools H2 {
	margin-left:	-5%;
    }
    H1, H2, H3, H4 {
	margin-top: 	1em;
	font-family:	sans-serif;
	font-size:	large;
	color:		#005A9C;
	background: 	transparent;
	text-align:		left;
    }
    H1.title {
	text-align: center;
    }
    UL,OL {
	margin-right: 0em;
	margin-top: 3pt;
	margin-bottom: 3pt;
    }
    UL LI {
	list-style: disc;
    }
    OL LI {
	list-style: decimal;
    }
    DT {
	padding-top: 	1ex;
    }
    UL.toc,UL.toc UL, UL.toc UL UL {
	font:		normal 12pt/14pt sans-serif;
	list-style:	none;
    }
    LI.section, LI.subsection {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding: 	0em;
    }
    PRE {
	display: 	block;
	font-family:	monospace;
	white-space:	pre;
	margin:		0%;
	padding-top:	0.5ex;
	padding-bottom:	0.5ex;
	padding-left:	1ex;
	padding-right:	1ex;
	width:		100%;
    }
    PRE.example {
	color: 		black;
	background: 	#f5dcb3;
	border:		1px solid black;
    }
    UL.requirements LI, UL.syntax LI {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding:	0em;
    }
    DIV.synopsis {
	color: 		black;
	background: 	#80ffff;
	border:		1px solid black;
	font-family:	serif;
	margin-top: 	1em;
	margin-bottom: 	1em;
    }
    UL.syntax {
	margin-top: 	1em;
	border-top:	1px solid black;
    }
    UL.requirements {
	margin-bottom: 	1em;
	border-bottom:	1px solid black;
    }
--></style>
</head>
<! -- Generated from file 'relation.man' by tcllib/doctools with format 'html'
   -->
<! -- Copyright &copy; 2004 - 2015 by G. Andrew Mangogna
   -->
<! -- CVS: $Id$ relation.n
   -->
<body><div class="doctools">
<hr> [
   <a href="../toc.html">Table Of Contents</a>
| <a href="../index.html">Keyword Index</a>
 ] <hr>
<h1 class="title">relation(n) 0.11.6 ral &quot;Relation Operators&quot;</h1>
<div id="name" class="section"><h2><a name="name">Name</a></h2>
<p>relation - Operators for Relation Values</p>
</div>
<div id="toc" class="section"><h2><a name="toc">Table Of Contents</a></h2>
<ul class="toc">
<li class="section"><a href="#toc">Table Of Contents</a></li>
<li class="section"><a href="#synopsis">Synopsis</a></li>
<li class="section"><a href="#section1">Description</a></li>
<li class="section"><a href="#section2">STRING REPRESENTATION</a></li>
<li class="section"><a href="#section3">SET OPERATIONS</a></li>
<li class="section"><a href="#section4">EXAMPLE</a></li>
<li class="section"><a href="#section5">COMMANDS</a></li>
<li class="section"><a href="#see-also">See Also</a></li>
<li class="section"><a href="#keywords">Keywords</a></li>
<li class="section"><a href="#copyright">Copyright</a></li>
</ul>
</div>
<div id="synopsis" class="section"><h2><a name="synopsis">Synopsis</a></h2>
<div class="synopsis">
<ul class="requirements">
<li>package require <b class="pkgname">ral <span class="opt">?0.11.6?</span></b></li>
</ul>
<ul class="syntax">
<li><a href="#1"><b class="cmd">::ral::relation array</b> <i class="arg">relationValue</i> <i class="arg">arrayVarName</i> <i class="arg">keyAttr</i> <i class="arg">valueAttr</i></a></li>
<li><a href="#2"><b class="cmd">::ral::relation assign</b> <i class="arg">relationValue</i> <span class="opt">?attrName | attr-var-pair ...?</span></a></li>
<li><a href="#3"><b class="cmd">::ral::relation attributes</b> <i class="arg">relationValue</i></a></li>
<li><a href="#4"><b class="cmd">::ral::relation body</b> <i class="arg">relationValue</i></a></li>
<li><a href="#5"><b class="cmd">::ral::relation cardinality</b> <i class="arg">relationValue</i></a></li>
<li><a href="#6"><b class="cmd">::ral::relation compose</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?-using attrList?</span> <span class="opt">?relationValue3 ...?</span></a></li>
<li><a href="#7"><b class="cmd">::ral::relation create</b> <i class="arg">header</i> <span class="opt">?<i class="arg">tuple1 tuple2 ...</i>?</span></a></li>
<li><a href="#8"><b class="cmd">::ral::relation degree</b> <i class="arg">relationValue</i></a></li>
<li><a href="#9"><b class="cmd">::ral::relation dict</b> <i class="arg">relationValue</i> <i class="arg">keyAttr</i> <i class="arg">valueAttr</i></a></li>
<li><a href="#10"><b class="cmd">::ral::relation divide</b> <i class="arg">dividend</i> <i class="arg">divisor</i> <i class="arg">mediator</i></a></li>
<li><a href="#11"><b class="cmd">::ral::relation dunion</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?relationValue3 ...?</span></a></li>
<li><a href="#12"><b class="cmd">::ral::relation eliminate</b> <i class="arg">relationValue</i> <span class="opt">?attribute ...?</span></a></li>
<li><a href="#13"><b class="cmd">::ral::relation emptyof</b> <i class="arg">relationValue</i></a></li>
<li><a href="#14"><b class="cmd">::ral::relation extend</b> <i class="arg">relationValue</i> <i class="arg">tupleVariable</i> <span class="opt">?attr1 type1 expr1 attr2 type2 expr2 ...?</span></a></li>
<li><a href="#15"><b class="cmd">::ral::relation extract</b> <i class="arg">relationValue</i> <i class="arg">attrName</i> <span class="opt">?<i class="arg">attrName2 ...</i>?</span></a></li>
<li><a href="#16"><b class="cmd">::ral::relation foreach</b> <i class="arg">relationVariable</i> <i class="arg">relationValue</i> <span class="opt">?-ascending | -descending?</span> <span class="opt">?attr-list?</span> <i class="arg">script</i></a></li>
<li><a href="#17"><b class="cmd">::ral::relation fromdict</b> <i class="arg">dictValue</i> <i class="arg">keyattr</i> <i class="arg">keytype</i> <i class="arg">valattr</i> <i class="arg">valtype</i></a></li>
<li><a href="#18"><b class="cmd">::ral::relation fromlist</b> <i class="arg">listValue</i> <i class="arg">attrname</i> <i class="arg">attrtype</i></a></li>
<li><a href="#19"><b class="cmd">::ral::relation group</b> <i class="arg">relationValue</i> <i class="arg">newattribute</i> <span class="opt">?attr1 attr2 ...?</span></a></li>
<li><a href="#20"><b class="cmd">::ral::relation heading</b> <i class="arg">relationValue</i></a></li>
<li><a href="#21"><b class="cmd">::ral::relation insert</b> <i class="arg">relationValue</i> <span class="opt">?<i class="arg">name-value-list1 name-value-list2 ...</i>?</span></a></li>
<li><a href="#22"><b class="cmd">::ral::relation intersect</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?relationValue3 ...?</span></a></li>
<li><a href="#23"><b class="cmd">::ral::relation is</b> <i class="arg">relationValue1</i> <i class="arg">compareop</i> <i class="arg">relationValue2</i></a></li>
<li><a href="#24"><b class="cmd">::ral::relation isempty</b> <i class="arg">relationValue</i></a></li>
<li><a href="#25"><b class="cmd">::ral::relation isnotempty</b> <i class="arg">relationValue</i></a></li>
<li><a href="#26"><b class="cmd">::ral::relation issametype</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i></a></li>
<li><a href="#27"><b class="cmd">::ral::relation join</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?-using attrList?</span> <span class="opt">?relationValue3 ...?</span> <span class="opt">?-using attrList2?</span></a></li>
<li><a href="#28"><b class="cmd">::ral::relation list</b> <i class="arg">relationValue</i> <span class="opt">?<i class="arg">attrName</i>?</span> <span class="opt">?<span class="opt">?-ascending|-descending?</span> sortAttrList?</span></a></li>
<li><a href="#29"><b class="cmd">::ral::relation minus</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i></a></li>
<li><a href="#30"><b class="cmd">::ral::relation project</b> <i class="arg">relationValue</i> <span class="opt">?attr1 attr2 ...?</span></a></li>
<li><a href="#31"><b class="cmd">::ral::relation rank</b> <i class="arg">relationValue</i> <span class="opt">?<i class="arg">-ascending | -descending</i>?</span> <i class="arg">rankAttr</i> <i class="arg">newAttr</i></a></li>
<li><a href="#32"><b class="cmd">::ral::relation rename</b> <i class="arg">relationValue</i> <span class="opt">?oldname newname ...?</span></a></li>
<li><a href="#33"><b class="cmd">::ral::relation restrict</b> <i class="arg">relationValue</i> <i class="arg">tupleVariable</i> <i class="arg">expression</i></a></li>
<li><a href="#34"><b class="cmd">::ral::relation restrictwith</b> <i class="arg">relationValue</i> <i class="arg">expression</i></a></li>
<li><a href="#35"><b class="cmd">::ral::relation semijoin</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?-using attrList?</span> <span class="opt">?relationValue3 ...?</span></a></li>
<li><a href="#36"><b class="cmd">::ral::relation semiminus</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?-using attrList?</span> <span class="opt">?relationValue3 ...?</span></a></li>
<li><a href="#37"><b class="cmd">::ral::relation summarize</b> <i class="arg">relationValue</i> <i class="arg">perRelation</i> <i class="arg">relationVarName</i> <i class="arg">attr</i> <i class="arg">type</i> <i class="arg">expression</i> <span class="opt">?<i class="arg">attr</i> <i class="arg">type</i> <i class="arg">expression</i> ...?</span></a></li>
<li><a href="#38"><b class="cmd">::ral::relation summarizeby</b> <i class="arg">relationValue</i> <i class="arg">attrList</i> <i class="arg">relationVarName</i> <i class="arg">attr</i> <i class="arg">type</i> <i class="arg">expression</i> <span class="opt">?<i class="arg">attr</i> <i class="arg">type</i> <i class="arg">expression</i> ...?</span></a></li>
<li><a href="#39"><b class="cmd">::ral::relation table</b> <i class="arg">heading</i> <i class="arg"><span class="opt">?value-list1 value-list2 ...?</span></i></a></li>
<li><a href="#40"><b class="cmd">::ral::relation tag</b> <i class="arg">relationValue</i> <i class="arg">attrName</i> <span class="opt">?<i class="arg">-ascending | -descending sort-attr-list</i>?</span> <span class="opt">?<i class="arg">-within attr-list</i>?</span></a></li>
<li><a href="#41"><b class="cmd">::ral::relation tclose</b> <i class="arg">relationValue</i></a></li>
<li><a href="#42"><b class="cmd">::ral::relation times</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?relationValue3 ...?</span></a></li>
<li><a href="#43"><b class="cmd">::ral::relation tuple</b> <i class="arg">relationValue</i></a></li>
<li><a href="#44"><b class="cmd">::ral::relation uinsert</b> <i class="arg">relationValue</i> <span class="opt">?<i class="arg">name-value-list1 name-value-list2 ...</i>?</span></a></li>
<li><a href="#45"><b class="cmd">::ral::relation ungroup</b> <i class="arg">relationValue</i> <i class="arg">attribute</i></a></li>
<li><a href="#46"><b class="cmd">::ral::relation union</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?relationValue3 ...?</span></a></li>
<li><a href="#47"><b class="cmd">::ral::relation unwrap</b> <i class="arg">relationValue</i> <i class="arg">attribute</i></a></li>
<li><a href="#48"><b class="cmd">::ral::relation update</b> <i class="arg">relationValue</i> <i class="arg">tupleVarName</i> <i class="arg">expr</i> <i class="arg">script</i></a></li>
<li><a href="#49"><b class="cmd">::ral::relation wrap</b> <i class="arg">relationValue</i> <i class="arg">tupleattr</i> <span class="opt">?<i class="arg">attr1 attr2 ...</i>?</span></a></li>
</ul>
</div>
</div>
<div id="section1" class="section"><h2><a name="section1">Description</a></h2>
<p>This manpage describes the <b class="cmd">relation</b> command.
The <b class="cmd">relation</b>
command is part of the Tcl Relational Algebra Library (ral) package.
The <b class="cmd">relation</b> command defines a set of operators on relations that
constitute the formal algebra of relations that is supported by TclRAL.
The algebra is patterned after that described by Date (Date, C.J.,
<em>An Introduction to Database Systems</em>, 8th ed, Pearson Education, 2004,
ISBN 0-321-19784-4, chap. 7)</p>
<p>Formally a relation has a heading and a body.
The heading, like a tuple heading, defines the attribute names and
data types of the components of the relation.
The body consists of tuples, all of which match the heading.
Because relations are fundamentally sets, several things should be noted:</p>
<ol class="enumerated">
<li><p>There is no left to right ordering of the attributes.
Like tuples, relations have no real left to right ordering.
The implementation may choose to store attributes in any order
and users should not depend upon certain string representations
nor operate on relations with any operators other than those given here.</p></li>
<li><p>There is no top to bottom ordering of tuples.
Again the implementation is free to store tuples in any order it chooses.
There are no access operations that depend upon a tuple at some fixed
offset or location.</p></li>
<li><p>There are no duplicate tuples in the body of a relation value
and there is no concept of a NULL value.
Relations are sets and sets do not have duplicates.
All attributes of all tuples of a relation must contain a valid value of
the data type defined for that attribute.</p></li>
</ol>
<p>Note that all the operators are <em>read only</em> in the sense that
they operate on relation values without modifying them.
All of these operators return either a new relation or scalar value and
do not modify the relation arguments.
Only the <b class="cmd"><a href="relvar.html">relvar</a></b> command can modify, in place,
the relation value that is held in a relation variable.</p>
</div>
<div id="section2" class="section"><h2><a name="section2">STRING REPRESENTATION</a></h2>
<p>Like any Tcl value, relations have a string representation.
The string representation of a relations is a specially formatted list
consisting of two elements:</p>
<ol class="enumerated">
<li><p>The relation heading.</p></li>
<li><p>The relation body.</p></li>
</ol>
<p>The relation heading is a list containing an even number of elements
consisting of alternating
attribute names and attribute data types.
It is the same form as a tuple heading.</p>
<p>The body of a relation consists of a list of tuples.
Each tuple in the body is in a list containing an even number of elements
consisting alternately of an
attribute name and its corresponding attribute value.</p>
<p>The following is a literal string representation of a relation with
one tuple in its body.</p>
<pre class="example">
{DogName string Breed string} {{DogName Fido Breed Poodle}}
</pre>
</div>
<div id="section3" class="section"><h2><a name="section3">SET OPERATIONS</a></h2>
<p>Several set-like operation are supported by TclRAL
(<em>e.g.</em> union and intersection).
These operations work in much the same way as the familiar mathematical
operations on sets.
When applied to relation values, there is a special consideration.
In order to perform set-like operations on relations they must
have the same heading.
This means that the headings must have the same attribute names and
the corresponding attributes must have the same data type.</p>
</div>
<div id="section4" class="section"><h2><a name="section4">EXAMPLE</a></h2>
<p>In the command descriptions that follow,
we will often refer to the example data given below.
We assume that the relation is contained in a Tcl variable with the
same name as the tables given below.
For brevity we assume that the necessary commands have been imported into
the namespace of the example.</p>
<pre class="example">
% set DOG {
  {DogName string Breed string} {
      {DogName Fido Breed Poodle}
      {DogName Sam Breed Collie}
      {DogName Spot Breed Terrier}
      {DogName Rover Breed Retriever}
      {DogName Fred Breed Spaniel}
      {DogName Jumper Breed Mutt}
  }
}
% relformat $DOG DOG
+-------+---------+
|DogName|Breed    |
|string |string   |
+-------+---------+
|Fido   |Poodle   |
|Sam    |Collie   |
|Spot   |Terrier  |
|Rover  |Retriever|
|Fred   |Spaniel  |
|Jumper |Mutt     |
+-------+---------+
DOG
---
% set OWNER {
  {OwnerName string Age int City string} {
      {OwnerName Sue Age 24 City Cupertino}
      {OwnerName George Age 35 City Sunnyvale}
      {OwnerName Alice Age 30 City {San Jose}}
      {OwnerName Mike Age 50 City {San Jose}}
      {OwnerName Jim Age 42 City {San Francisco}}
  }
}
% relformat $OWNER OWNER
+---------+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+---------+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+---------+---+-------------+
OWNER
-----
% set OWNERSHIP {
  {OwnerName string DogName string Acquired string} {
    {OwnerName Sue DogName Fido Acquired 2001}
    {OwnerName Sue DogName Sam Acquired 2000}
    {OwnerName George DogName Fido Acquired 2001}
    {OwnerName George DogName Sam Acquired 2000}
    {OwnerName Alice DogName Spot Acquired 2001}
    {OwnerName Mike DogName Rover Acquired 2002}
    {OwnerName Jim DogName Fred Acquired 2003}
  }
}
% relformat $OWNERSHIP OWNERSHIP
+---------+-------+--------+
|OwnerName|DogName|Acquired|
|string   |string |string  |
+---------+-------+--------+
|Sue      |Fido   |2001    |
|Sue      |Sam    |2000    |
|George   |Fido   |2001    |
|George   |Sam    |2000    |
|Alice    |Spot   |2001    |
|Mike     |Rover  |2002    |
|Jim      |Fred   |2003    |
+---------+-------+--------+
OWNERSHIP
---------
</pre>
</div>
<div id="section5" class="section"><h2><a name="section5">COMMANDS</a></h2>
<dl class="definitions">
<dt><a name="1"><b class="cmd">::ral::relation array</b> <i class="arg">relationValue</i> <i class="arg">arrayVarName</i> <i class="arg">keyAttr</i> <i class="arg">valueAttr</i></a></dt>
<dd><p>The <b class="cmd">array</b> subcommand converts the relation value
given by <i class="arg">relationValue</i> into an array variable named <i class="arg">arrayVarName</i>.
The values of <i class="arg">keyAttr</i> are used as the array indices and the corresponding
values of <i class="arg">valueAttr</i> are the array value.
Note, that if the values of the <i class="arg">keyAttr</i> attribute are not unique then it
is possible that more than one tuple in <i class="arg">relationValue</i> will have the same
value for <i class="arg">keyAttr</i>.
In this case the array value from <i class="arg">valueAttr</i>
corresponding to duplicated values of
<i class="arg">keyAttr</i> is arbitrarily chosen by the implementation.
Thus the safe approach is to project the relation value that is to be converted
into an array to be a binary relation or to tag the relation and use the tag
attribute name as <i class="arg">keyAttr</i> thereby insure that no duplicated array indices
can occur.</p>
<pre class="example">
% relation array $DOG dogarray DogName Breed
% parray dogarray
dogarray(Fido)   = Poodle
dogarray(Fred)   = Spaniel
dogarray(Jumper) = Mutt
dogarray(Rover)  = Retriever
dogarray(Sam)    = Collie
dogarray(Spot)   = Terrier
</pre>
</dd>
<dt><a name="2"><b class="cmd">::ral::relation assign</b> <i class="arg">relationValue</i> <span class="opt">?attrName | attr-var-pair ...?</span></a></dt>
<dd><p>The <b class="cmd">assign</b> subcommand is short hand for
<b class="cmd">tuple assign [relation tuple <i class="arg">relationValue</i>] ?...?</b>.
This allow moving the values of a relation with a single tuple into
ordinary Tcl variable.</p>
<pre class="example">
% relation foreach d $DOG -descending DogName {
    relation assign $d DogName
    puts $DogName
}
Spot
Sam
Rover
Jumper
Fred
Fido
</pre>
</dd>
<dt><a name="3"><b class="cmd">::ral::relation attributes</b> <i class="arg">relationValue</i></a></dt>
<dd><p>The <b class="cmd">attributes</b> subcommand returns the names of the attributes of
<i class="arg">relationValue</i> as a list.</p>
<pre class="example">
% relation attributes $DOG
DogName Breed
% relation attributes $OWNER
OwnerName Age City
</pre>
</dd>
<dt><a name="4"><b class="cmd">::ral::relation body</b> <i class="arg">relationValue</i></a></dt>
<dd><p>The <b class="cmd"><a href="../index.html#key4">body</a></b> subcommand returns the body of the relation value
given by <i class="arg">relationValue</i>.
The body is a list of tuple values, each tuple value being in turn
a list of attribute name / attribute value pairs.
The order of the tuple values in the body list is arbitrary.</p>
<pre class="example">
% foreach t [relation body $DOG] {puts $t}
DogName Fido Breed Poodle
DogName Sam Breed Collie
DogName Spot Breed Terrier
DogName Rover Breed Retriever
DogName Fred Breed Spaniel
DogName Jumper Breed Mutt
</pre>
</dd>
<dt><a name="5"><b class="cmd">::ral::relation cardinality</b> <i class="arg">relationValue</i></a></dt>
<dd><p>The <b class="cmd">cardinality</b> subcommand returns the number tuples contained
in the body of <i class="arg">relationValue</i>.</p>
<pre class="example">
% relation cardinality $DOG
6
% relation cardinality $OWNERSHIP
7
</pre>
</dd>
<dt><a name="6"><b class="cmd">::ral::relation compose</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?-using attrList?</span> <span class="opt">?relationValue3 ...?</span></a></dt>
<dd><p>The <b class="cmd">compose</b> subcommand computes the join of <i class="arg">relationValue1</i>
and <i class="arg">relationValue2</i> but eliminates all of the attributes used in the
join.
The returned relation has a heading the same as the union of the headings
of <i class="arg">relationValue1</i> and <i class="arg">relationValue2</i> minus all of the
join attributes from the two relations.
The returned relation has a body that is the same as that of the
<b class="cmd">join</b> minus any duplicated tuples that result when the join
attributes are eliminated.
As with <b class="cmd">join</b>, if the <i class="arg">-using</i> argument are missing, the
join is computed across the attributes in <i class="arg">relationValue1</i> and
<i class="arg">relationValue2</i> that are named the same.
Otherwise the <i class="arg">attrList</i> argument is treated the same as for the
<b class="cmd">join</b> subcommand.</p></dd>
<dt><a name="7"><b class="cmd">::ral::relation create</b> <i class="arg">header</i> <span class="opt">?<i class="arg">tuple1 tuple2 ...</i>?</span></a></dt>
<dd><p>The <b class="cmd">create</b> subcommand returns the relation value described by
the <i class="arg">header</i> and <i class="arg">tupleN</i> arguments.
The <i class="arg">header</i> argument is a list of attribute name / attribute type pairs.
Any tuples given by the <span class="opt">?<i class="arg">tupleN</i>?</span> arguments are inserted into the
relation value.
Each <i class="arg">tupleN</i> argument is a list of attribute name / attribute value pairs.
This command allows for creating a relation value without having knowledge of
the string representation of a relation value. Compare with the
<b class="cmd">::ral::tuple create</b> command.</p>
<pre class="example">
% relation create {DogName string Breed string} {DogName Fido Breed Poodle}
{DogName string Breed string} {{DogName Fido Breed Poodle}}
</pre>
</dd>
<dt><a name="8"><b class="cmd">::ral::relation degree</b> <i class="arg">relationValue</i></a></dt>
<dd><p>The <b class="cmd">degree</b> subcommand returns the number of attributes in the
heading of <i class="arg">relationValue</i></p>
<pre class="example">
% relation degree $DOG
2
</pre>
</dd>
<dt><a name="9"><b class="cmd">::ral::relation dict</b> <i class="arg">relationValue</i> <i class="arg">keyAttr</i> <i class="arg">valueAttr</i></a></dt>
<dd><p>The <b class="cmd">dict</b> subcommand returns a dictionary object whose keys are
the values of the <i class="arg">keyAttr</i> and whose values are the values of the
<i class="arg">valueAttr</i>.
Like the <b class="cmd">relation array</b> command,
the values of the <i class="arg">keyAttr</i> attribute should be unique
to be assured that the correct corresponding values of the <i class="arg">valueAttr</i>
attribute are in the resulting dictionary.</p>
<pre class="example">
% dict for {name breed} [relation dict $::DOG DogName Breed] {
  puts &quot;$name ==&gt; $breed&quot;
  }
Fred ==&gt; Spaniel
Sam ==&gt; Collie
Rover ==&gt; Retriever
Spot ==&gt; Terrier
Fido ==&gt; Poodle
Jumper ==&gt; Mutt
</pre>
</dd>
<dt><a name="10"><b class="cmd">::ral::relation divide</b> <i class="arg">dividend</i> <i class="arg">divisor</i> <i class="arg">mediator</i></a></dt>
<dd><p>The <b class="cmd">divide</b> subcommand implements the relational divide operation.
The headings of <i class="arg">dividend</i> and <i class="arg">divisor</i> must be disjoint and
the heading of <i class="arg">mediator</i> must be the union of the <i class="arg">dividend</i>
and <i class="arg">divisor</i> headings.
The returned result is a new relation that has the same heading as
<i class="arg">dividend</i> and contains all the tuples from <i class="arg">dividend</i> whose
corresponding tuples in <i class="arg">mediator</i> include all the tuples in
<i class="arg">divisor</i>.
Stated another way,
the result of <b class="cmd">divide</b> subcommand is the maximal set of tuples
from <i class="arg">dividend</i> whose Cartesian product with <i class="arg">divisor</i> is
completely contained in <i class="arg">mediator</i>.
Using the data from our ongoing example, then the following example shows
how division can be used to find all the Dogs owned by both Sue and George.</p>
<pre class="example">
% set dividend [relation project $::DOG DogName]
{DogName string} {\ 
{DogName Fido}\ 
{DogName Sam}\ 
{DogName Spot}\ 
{DogName Rover}\ 
{DogName Fred}\ 
{DogName Jumper}}
% puts [relformat $dividend Dividend:]
+-------+
|DogName|
|string |
+-------+
|Fido   |
|Sam    |
|Spot   |
|Rover  |
|Fred   |
|Jumper |
+-------+
Dividend:
---------
% set divisor [relation project [relation restrict $::OWNER t\ 
  {[tuple extract $t OwnerName] eq &quot;Sue&quot; ||\ 
  [tuple extract $t OwnerName] eq &quot;George&quot;}] OwnerName]
{OwnerName string} {{OwnerName Sue} {OwnerName George}}
% puts [relformat $divisor Divisor:]
+---------+
|OwnerName|
|string   |
+---------+
|Sue      |
|George   |
+---------+
Divisor:
--------
% set mediator [relation eliminate $::OWNERSHIP Acquired]
{OwnerName string DogName string} {\ 
{OwnerName Sue DogName Fido}\ 
{OwnerName Sue DogName Sam}\ 
{OwnerName George DogName Fido}\ 
{OwnerName George DogName Sam}\ 
{OwnerName Alice DogName Spot}\ 
{OwnerName Mike DogName Rover}\ 
{OwnerName Jim DogName Fred}}
% puts [relformat $mediator Mediator:]
+---------+-------+
|OwnerName|DogName|
|string   |string |
+---------+-------+
|Sue      |Fido   |
|Sue      |Sam    |
|George   |Fido   |
|George   |Sam    |
|Alice    |Spot   |
|Mike     |Rover  |
|Jim      |Fred   |
+---------+-------+
Mediator:
---------
% set quotient [relation divide $dividend $divisor $mediator]
{DogName string} {{DogName Fido} {DogName Sam}}
% puts [relformat $quotient &quot;All dogs owned by both Sue and George&quot;]
+-------+
|DogName|
|string |
+-------+
|Fido   |
|Sam    |
+-------+
All dogs owned by both Sue and George
-------------------------------------
</pre>
</dd>
<dt><a name="11"><b class="cmd">::ral::relation dunion</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?relationValue3 ...?</span></a></dt>
<dd><p>The <b class="cmd">dunion</b> subcommand returns the set union of two or more relations.
However, unlike the <b class="cmd">relation union</b> command, the <b class="cmd">dunion</b>
command insists that all the relation values be disjoint.
All relations must be of the same type.
The result relation has a heading that is the same as any of the arguments
and has a body consisting of all tuples present in any of the
<i class="arg">relationValue</i> arguments.
However, if any duplicated tuples are found, then an error results.
Since the dunion operation is both associative and commutative,
the order of the <i class="arg">relationValue</i> arguments has no effect the result.</p></dd>
<dt><a name="12"><b class="cmd">::ral::relation eliminate</b> <i class="arg">relationValue</i> <span class="opt">?attribute ...?</span></a></dt>
<dd><p>The <b class="cmd">eliminate</b> subcommand returns a new relation that has a heading
equal to that of the <i class="arg">relationValue</i> minus any attributes whose names
are given in the <i class="arg">attribute</i> arguments.
The body of the new relation is the same as the body of <i class="arg">relationValue</i>
removing any tuples that might be duplicated as a result of removing the
attributes.
The <b class="cmd">eliminate</b> subcommand complements the <b class="cmd">project</b> command
in the sense that <b class="cmd">eliminate</b> specifies which attributes
to discard and <b class="cmd">project</b> specifies which attribute to keep.</p>
<pre class="example">
% relformat [relation eliminate $::DOG Breed]
+-------+
|DogName|
|string |
+-------+
|Fido   |
|Sam    |
|Spot   |
|Rover  |
|Fred   |
|Jumper |
+-------+
</pre>
</dd>
<dt><a name="13"><b class="cmd">::ral::relation emptyof</b> <i class="arg">relationValue</i></a></dt>
<dd><p>The <b class="cmd">emptyof</b> subcommand returns a new relation that has the same
heading as <i class="arg">relationValue</i> but whose cardinality is zero.</p></dd>
<dt><a name="14"><b class="cmd">::ral::relation extend</b> <i class="arg">relationValue</i> <i class="arg">tupleVariable</i> <span class="opt">?attr1 type1 expr1 attr2 type2 expr2 ...?</span></a></dt>
<dd><p>The <b class="cmd">extend</b> subcommand returns a new relation which has the same
heading as <i class="arg">relationValue</i> with zero or more additional attributes.
The first additional attribute is given by <i class="arg">attr1</i> which has
type <i class="arg">type1</i> and its value is
set to the result returned by passing <i class="arg">expr1</i> to the <b class="cmd">expr</b> command.
Subsequent attributes are treated similarly.
As each tuple in the body of <i class="arg">relationValue</i> is considered, its
value is set into the variable whose name is given by the <i class="arg">tupleVariable</i>
argument.
This variable is accessible to the extending expressions so that the
current tuple values of <i class="arg">relationValue</i> are available for computing
the values of the new attributes.</p>
<pre class="example">
% relformat [relation extend $::OWNER o AgeInMonths int {[tuple extract $o Age] * 12}]
+---------+---+-------------+-----------+
|OwnerName|Age|City         |AgeInMonths|
|string   |int|string       |int        |
+---------+---+-------------+-----------+
|Sue      |24 |Cupertino    |288        |
|George   |35 |Sunnyvale    |420        |
|Alice    |30 |San Jose     |360        |
|Mike     |50 |San Jose     |600        |
|Jim      |42 |San Francisco|504        |
+---------+---+-------------+-----------+
</pre>
</dd>
<dt><a name="15"><b class="cmd">::ral::relation extract</b> <i class="arg">relationValue</i> <i class="arg">attrName</i> <span class="opt">?<i class="arg">attrName2 ...</i>?</span></a></dt>
<dd><p>The <b class="cmd">extract</b> subcommand is short hand for
<b class="cmd">tuple extract [relation tuple <i class="arg">relationValue</i>] <i class="arg">attrName</i> ?...?</b>.
This command obtains one or more attribute values from a relation that
is of cardinality one.</p></dd>
<dt><a name="16"><b class="cmd">::ral::relation foreach</b> <i class="arg">relationVariable</i> <i class="arg">relationValue</i> <span class="opt">?-ascending | -descending?</span> <span class="opt">?attr-list?</span> <i class="arg">script</i></a></dt>
<dd><p>The <b class="cmd">foreach</b> subcommand provides a means to iterate through the
body of a relation.
For each tuple in the body of <i class="arg">relationValue</i>,
the <i class="arg">relationVariable</i> variable is successively set to a relation
value that contains a single tuple from <i class="arg">relationValue</i> and then
<i class="arg">script</i> is executed.
The order in which the tuples are considered is unspecified unless
a list of sorting attributes is specified by the <i class="arg">attr-list</i> argument.
In this case,
the tuples are visited in the <i class="arg">-ascending</i> order of
the values of the sorting attibutes if the direction option
of <i class="arg">-ascending</i> is supplied or if no direction option is given.
Tuples can be visited in descending order of the sorting attributes if
the <i class="arg">-descending</i> option is given.</p>
<pre class="example">
% relation foreach d $DOG -descending DogName {
    puts [tuple extract [relation tuple $d] DogName]
}
Spot
Sam
Rover
Jumper
Fred
Fido
</pre>
</dd>
<dt><a name="17"><b class="cmd">::ral::relation fromdict</b> <i class="arg">dictValue</i> <i class="arg">keyattr</i> <i class="arg">keytype</i> <i class="arg">valattr</i> <i class="arg">valtype</i></a></dt>
<dd><p>The <b class="cmd">fromdict</b> subcommand returns a relation value of degree two
that contains all the keys and values from <i class="arg">dictValue</i>.
The heading of the returned relation will have two attributes
names <i class="arg">keyattr</i> and <i class="arg">valattr</i> of the corresponding types,
<i class="arg">keytype</i> and <i class="arg">valtype</i>.
All the key / value pairs from the dictionary are inserted as tuples in the
returned relation value.
This command provides a simpler means to move data from core Tcl types
into relation values.
Compare with <b class="cmd">relation dict</b> which extracts relation attribute values
into Tcl dictionaries.</p>
<pre class="example">
% set d [dict create Fido Poodle Sam Collie Spot Terrier]
% relformat [relation fromdict $d DogName string Breed string]
+-------+-------+
|DogName|Breed  |
|string |string |
+-------+-------+
|Fido   |Poodle |
|Sam    |Collie |
|Spot   |Terrier|
+-------+-------+
</pre>
</dd>
<dt><a name="18"><b class="cmd">::ral::relation fromlist</b> <i class="arg">listValue</i> <i class="arg">attrname</i> <i class="arg">attrtype</i></a></dt>
<dd><p>The <b class="cmd">fromlist</b> subcommand returns a relation value of degree one
that contains the values in the list given by <i class="arg">listValue</i>.
The heading of the returned relation contains a single attribute named,
<i class="arg">attrname</i>, whose type is given by, <i class="arg">attrtype</i>.
Since relations are sets and sets do not have duplicated values,
any duplicated values in <i class="arg">listValue</i> are silently excluded from the
returned relation value.
Comparing the cardinality of the returned relation with the length of
<i class="arg">listValue</i> can be used to determine of any elements of <i class="arg">listValue</i>
were excluded.
This command provides a simpler means to convert lists into a relation value.
Compare with <b class="cmd">relation list</b> which extracts relation attribute values
into Tcl lists.</p></dd>
<dt><a name="19"><b class="cmd">::ral::relation group</b> <i class="arg">relationValue</i> <i class="arg">newattribute</i> <span class="opt">?attr1 attr2 ...?</span></a></dt>
<dd><p>The <b class="cmd">group</b> subcommand creates a new relation from <i class="arg">relationValue</i>
that contains an attribute which is of type <em>Relation</em>.
The <i class="arg">newattribute</i> argument gives the name of the relation valued
attribute and
the <i class="arg">attrN</i> arguments give the names of attributes in
<i class="arg">relationValue</i> that are to be assembled into a relation value.
The returned relation has a heading that is the same as <i class="arg">relationValue</i>
minus the attributes given in the <i class="arg">attrN</i> arguments plus the
new relation attribute given by <i class="arg">newattribute</i>.
The resulting body has tuples for each unique set of values for the
remaining ungrouped attributes in the original relation with the
corresponding part of the tuple placed in the new relation valued attribute.
See also the <b class="cmd">ungroup</b> subcommand for the complementary operation.</p>
<pre class="example">
% relformat [relation group $::OWNERSHIP DogAcquisition DogName Acquired]
+---------+------------------+
|OwnerName|DogAcquisition    |
|string   |Relation          |
+---------+------------------+
|Sue      |+-------+--------+|
|         ||DogName|Acquired||
|         ||string |string  ||
|         |+-------+--------+|
|         ||Fido   |2001    ||
|         ||Sam    |2000    ||
|         |+-------+--------+|
|George   |+-------+--------+|
|         ||DogName|Acquired||
|         ||string |string  ||
|         |+-------+--------+|
|         ||Fido   |2001    ||
|         ||Sam    |2000    ||
|         |+-------+--------+|
|Alice    |+-------+--------+|
|         ||DogName|Acquired||
|         ||string |string  ||
|         |+-------+--------+|
|         ||Spot   |2001    ||
|         |+-------+--------+|
|Mike     |+-------+--------+|
|         ||DogName|Acquired||
|         ||string |string  ||
|         |+-------+--------+|
|         ||Rover  |2002    ||
|         |+-------+--------+|
|Jim      |+-------+--------+|
|         ||DogName|Acquired||
|         ||string |string  ||
|         |+-------+--------+|
|         ||Fred   |2003    ||
|         |+-------+--------+|
+---------+------------------+
</pre>
</dd>
<dt><a name="20"><b class="cmd">::ral::relation heading</b> <i class="arg">relationValue</i></a></dt>
<dd><p>The <b class="cmd">heading</b> subcommand returns the relation heading of the
<i class="arg">relationValue</i>.
The heading is a list consisting attributes and corresponding data types.</p>
<pre class="example">
% relation heading $DOG
DogName string Breed string
</pre>
</dd>
<dt><a name="21"><b class="cmd">::ral::relation insert</b> <i class="arg">relationValue</i> <span class="opt">?<i class="arg">name-value-list1 name-value-list2 ...</i>?</span></a></dt>
<dd><p>The <b class="cmd">insert</b> command returns a new relation value whose heading
is the same as <i class="arg">relationValue</i> and whose body includes all the
tuples of <i class="arg">relationValue</i> plus all the tuples given as the
<i class="arg">name-value-listN</i> arguments.
If inserting any of the <i class="arg">name-value-listN</i> arguments would result
in a duplicate tuple,
then an error is thrown.</p></dd>
<dt><a name="22"><b class="cmd">::ral::relation intersect</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?relationValue3 ...?</span></a></dt>
<dd><p>The <b class="cmd">intersect</b> subcommand returns the set intersection of two or
more relations.
All relations have equal headings.
The result relation has a heading that is the same as any of the arguments
and has a body consisting of all tuples present in all of the
<i class="arg">relationValue</i> arguments.
Since the intersection operation is both associative and commutative,
the order of the <i class="arg">relationValue</i> arguments has no effect the result.</p></dd>
<dt><a name="23"><b class="cmd">::ral::relation is</b> <i class="arg">relationValue1</i> <i class="arg">compareop</i> <i class="arg">relationValue2</i></a></dt>
<dd><p>The <b class="cmd">is</b> subcommand returns a boolean value based on performing a
comparison operation between two relation values.
Allowed values of <i class="arg">compareop</i> are:</p>
<dl class="definitions">
<dt><b class="cmd">equal | ==</b></dt>
<dd><p>Returns 1 if <i class="arg">relationValue1</i> is equal to <i class="arg">relationValue2</i>.</p></dd>
<dt><b class="cmd">notequal | !=</b></dt>
<dd><p>Returns 1 if <i class="arg">relationValue1</i> is not equal to <i class="arg">relationValue2</i>.</p></dd>
<dt><b class="cmd">propersubsetof | &lt;</b></dt>
<dd><p>Returns 1 if <i class="arg">relationValue1</i> is a proper subset of <i class="arg">relationValue2</i>.</p></dd>
<dt><b class="cmd">subsetof | &lt;=</b></dt>
<dd><p>Returns 1 if <i class="arg">relationValue1</i> is a subset of <i class="arg">relationValue2</i>.</p></dd>
<dt><b class="cmd">propersupersetof | &gt;</b></dt>
<dd><p>Returns 1 if <i class="arg">relationValue1</i> is a proper superset of <i class="arg">relationValue2</i>.</p></dd>
<dt><b class="cmd">supersetof | &gt;=</b></dt>
<dd><p>Returns 1 if <i class="arg">relationValue1</i> is a superset of <i class="arg">relationValue2</i>.</p></dd>
</dl>
<p>Both <i class="arg">relationValue1</i> and <i class="arg">relationValue2</i> must be of the same
type to be compared.</p>
<pre class="example">
% set sDogs [relation restrictwith $DOG {[string match S* $DogName]}]
{DogName string Breed string} {{DogName Sam Breed Collie} {DogName Spot Breed Terrier}}
% relation is $DOG == $sDogs
0
% relation is $DOG != $sDogs
1
% relation is $DOG supersetof $sDogs
1
% relation is $DOG &gt; $sDogs
1
% relation is $DOG propersubsetof $sDogs
0
% relation is $DOG &lt;= $sDogs
0
</pre>
</dd>
<dt><a name="24"><b class="cmd">::ral::relation isempty</b> <i class="arg">relationValue</i></a></dt>
<dd><p>The <b class="cmd">isempty</b> subcommand returns the boolean value &quot;1&quot; if the
body of <i class="arg">relationValue</i> does not contain any tuples and &quot;0&quot; otherwise.
The <b class="cmd">isempty</b> subcommand is a convenient short hand for the the command
<b class="cmd">expr {[::ral::relation cardinality <i class="arg">relationValue</i>] == 0}</b>.</p></dd>
<dt><a name="25"><b class="cmd">::ral::relation isnotempty</b> <i class="arg">relationValue</i></a></dt>
<dd><p>The <b class="cmd">isnotempty</b> subcommand returns the boolean value &quot;1&quot; if the
body of <i class="arg">relationValue</i> contains any tuples and &quot;0&quot; otherwise.
The <b class="cmd">isnotempty</b> subcommand is a convenient short hand for the the command
<b class="cmd">expr {[::ral::relation cardinality <i class="arg">relationValue</i>] != 0}</b>.</p></dd>
<dt><a name="26"><b class="cmd">::ral::relation issametype</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i></a></dt>
<dd><p>The <b class="cmd">issametype</b> subcommand returns the boolean value &quot;1&quot; if the
headings of <i class="arg">relationValue1</i> is the same as that of <i class="arg">relationValue2</i>
and &quot;0&quot; otherwise.
Since the relation headings do not have any intrinsic ordering,
using string comparison of relation headings to determine equality
is not reliable and therefore the <b class="cmd">issametype</b> command should be used
to determine type equality.</p></dd>
<dt><a name="27"><b class="cmd">::ral::relation join</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?-using attrList?</span> <span class="opt">?relationValue3 ...?</span> <span class="opt">?-using attrList2?</span></a></dt>
<dd><p>The <b class="cmd">join</b> subcommand performs the <em>natural</em> join of
<i class="arg">relationValue1</i> with <i class="arg">relationValue2</i>.
The join is performed across the given <i class="arg">attrList</i>.
If no <i class="arg">attrList</i> are given, then the join is performed across
attributes with the same name in both relations
(because of the <b class="cmd">rename</b> subcommand it is always possible to arrange
for the relations to have common names for the join attributes).
If present, the <i class="arg">attrList</i> is a list of pairs of attribute names.
The even numbered elements
give the name of a join attribute in <i class="arg">relationValue1</i> and the
odd numbered elements give the name of the corresponding
join attribute in <i class="arg">relationValue2</i>.
The heading of the resulting relation consists of all the attibutes of
<i class="arg">relationValue1</i> plus all the attributes of <i class="arg">relationValue2</i>
minus any of the join attributes from <i class="arg">relationValue2</i>.
The body of the resulting relation consists all tuples composed from the
tuples in both <i class="arg">relationValue1</i> and <i class="arg">relationValue2</i> where the values of
the join attributes in <i class="arg">relationValue1</i> equal those of <i class="arg">relationValue2</i>.
Several relations can be joined by optionally listing them as additional
<i class="arg">relationValueN</i> arguments.
Additional <span class="opt">?-using?</span> arguments may be given for each pair of
<i class="arg">relationValue</i> arguments to specify the attributes across which the
join is to be performed.
The <span class="opt">?-using?</span> options are a convenient short hand for having to
<b class="cmd">rename</b> attributes to achieve common attribute names.
The join operation is both associative and commutative and so the order
of the <i class="arg">relationValueN</i> does not affect the result.</p>
<pre class="example">
% relformat [relation join $OWNERSHIP $DOG]
+---------+-------+--------+---------+
|OwnerName|DogName|Acquired|Breed    |
|string   |string |string  |string   |
+---------+-------+--------+---------+
|Sue      |Fido   |2001    |Poodle   |
|Sue      |Sam    |2000    |Collie   |
|George   |Fido   |2001    |Poodle   |
|George   |Sam    |2000    |Collie   |
|Alice    |Spot   |2001    |Terrier  |
|Mike     |Rover  |2002    |Retriever|
|Jim      |Fred   |2003    |Spaniel  |
+---------+-------+--------+---------+
</pre>
</dd>
<dt><a name="28"><b class="cmd">::ral::relation list</b> <i class="arg">relationValue</i> <span class="opt">?<i class="arg">attrName</i>?</span> <span class="opt">?<span class="opt">?-ascending|-descending?</span> sortAttrList?</span></a></dt>
<dd><p>The <b class="cmd">list</b> subcommand returns the values of a single attribute
from all the tuples of <i class="arg">relationValue</i> as a proper Tcl list.
If <i class="arg">attrName</i> is not given, then
<i class="arg">RelationValue</i> must be of degree one or an error is returned.
Otherwise the attribute values of <i class="arg">attrName</i> are returned.
Since lists are ordered and tuples in a relation values are not,
an optional <i class="arg">sortAttrList</i> may be specified.
In this case,
the returned list is in the same order as the corresponding values
of the attributes given in <i class="arg">sortAttrList</i>.
By default the sorting is <i class="arg">-ascending</i> unless otherwise specified.
If no sorting arguments are given, the returned order is arbitrary
and unspecified.
Note that the list returned from a relation of degree one is necessarily a set
and may be used with the <b class="package">struct::set</b> package.
In this case if the values of the <i class="arg">attrName</i> attribute are not
unique then, in general, the returned list is not a set and may include
duplicated values.</p>
<pre class="example">
% relation list [relation project $OWNERSHIP Acquired]]
2001 2000 2002 2003
% relation list $OWNERSHIP Acquired -ascending {OwnerName DogName}
2001 2001 2000 2003 2002 2001 2000
</pre>
</dd>
<dt><a name="29"><b class="cmd">::ral::relation minus</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i></a></dt>
<dd><p>The <b class="cmd">minus</b> subcommand returns the set difference between two relations.
The <i class="arg">relationValue</i> arguments must be of the same type and that is the
type of the result relation.
The body of the result consists of those tuples present in
<i class="arg">relationValue1</i> but not present in <i class="arg">relationValue2</i>.
Note that the order of the <i class="arg">relationValue1</i> and <i class="arg">relationValue2</i>
arguments is significant to the result,
<em>i.e.</em> <b class="cmd">minus</b> is <em>not</em> a commutative operation.</p></dd>
<dt><a name="30"><b class="cmd">::ral::relation project</b> <i class="arg">relationValue</i> <span class="opt">?attr1 attr2 ...?</span></a></dt>
<dd><p>The <b class="cmd">project</b> subcommand returns a relation whose heading consists of
only those attributes listed in the <i class="arg">attrN</i> arguments.
The body of the result consists of tuples the corresponding tuples from
<i class="arg">relationValue</i>, removing any duplicates created by considering only
a subset of the attributes.</p>
<pre class="example">
% relformat [relation project $OWNER City]
+-------------+
|City         |
|string       |
+-------------+
|Cupertino    |
|Sunnyvale    |
|San Jose     |
|San Francisco|
+-------------+
</pre>
</dd>
<dt><a name="31"><b class="cmd">::ral::relation rank</b> <i class="arg">relationValue</i> <span class="opt">?<i class="arg">-ascending | -descending</i>?</span> <i class="arg">rankAttr</i> <i class="arg">newAttr</i></a></dt>
<dd><p>The <b class="cmd">rank</b> subcommand returns a new relation whose heading is the same
as <i class="arg">relationValue</i> extending by an attribute named <i class="arg">newAttr</i>.
The type of <i class="arg">newAttr</i> will be <b class="type">int</b> and its value will be set
to the number of tuples in <i class="arg">relationValue</i> where the value of
<i class="arg">rankAttr</i> is less than or equal to (<span class="opt">?-descending?</span>) or
greater than or equal to (<span class="opt">?-ascending?</span>) that of the given tuple.
The default ranking is <i class="arg">-ascending</i>.
The type of <i class="arg">rankAttr</i> must be <b class="type">int</b>, <b class="type">double</b>, or <b class="type">string</b>.
The <b class="cmd">rank</b> command is useful when it is desirable to limit the
number of tuples in the result.
For example, to find the names and ages of the two oldest owners:</p>
<pre class="example">
% set ro [relation rank $OWNER -descending Age AgeRank]
{OwnerName string Age int City string AgeRank int} {\ 
{OwnerName Sue Age 24 City Cupertino AgeRank 5}\ 
{OwnerName George Age 35 City Sunnyvale AgeRank 3}\ 
{OwnerName Alice Age 30 City {San Jose} AgeRank 4}\ 
{OwnerName Mike Age 50 City {San Jose} AgeRank 1}\ 
{OwnerName Jim Age 42 City {San Francisco} AgeRank 2}}
% relformat [relation project [relation restrictwith $ro {$AgeRank &lt;= 2}] OwnerName Age]
+---------+---+
|OwnerName|Age|
|string   |int|
+---------+---+
|Mike     |50 |
|Jim      |42 |
+---------+---+
</pre>
</dd>
<dt><a name="32"><b class="cmd">::ral::relation rename</b> <i class="arg">relationValue</i> <span class="opt">?oldname newname ...?</span></a></dt>
<dd><p>The <b class="cmd">rename</b> subcommand returns a relation whose heading has each
<i class="arg">oldname</i> attribute changed to <i class="arg">newname</i> and whose body is the
same as <i class="arg">relationValue</i>.
An arbitrary number of <i class="arg">oldname / newname</i> pairs may be given.
Renaming is processed from left to right in the command arguments
and it is not an error to change the name of any given attribute multiple times.
However, <i class="arg">oldname</i> must always be the name of an attribute at the
time the rename takes place.
The <b class="cmd">rename</b> subcommand is useful for manipulating the attribute names
of a relation to prevent naming conflicts in certain operations (<em>e.g.</em>
<b class="cmd">times</b> and <b class="cmd">join</b>).</p>
<pre class="example">
% relformat [relation rename $OWNER City Town]
+---------+---+-------------+
|OwnerName|Age|Town         |
|string   |int|string       |
+---------+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+---------+---+-------------+
% relformat [relation rename $OWNER City Town City Village]
unknown attribute name, &quot;City&quot;
</pre>
</dd>
<dt><a name="33"><b class="cmd">::ral::relation restrict</b> <i class="arg">relationValue</i> <i class="arg">tupleVariable</i> <i class="arg">expression</i></a></dt>
<dd><p>The <b class="cmd">restrict</b> subcommand returns a new relation that is a
subset (possibly improper) of <i class="arg">relationValue</i>.
Each tuple in the body of <i class="arg">relationValue</i> is successively assigned
to <i class="arg">tupleVariable</i> and <i class="arg">expression</i> is evaluated.
The resulting relation has a heading that is the same as <i class="arg">relationValue</i>
and a body consisting of all tuples where <i class="arg">expression</i> evaluated to true.</p>
<pre class="example">
% relformat [relation restrict $DOG d {[string match S* [tuple extract $d DogName]]}]
+-------+-------+
|DogName|Breed  |
|string |string |
+-------+-------+
|Sam    |Collie |
|Spot   |Terrier|
+-------+-------+
</pre>
</dd>
<dt><a name="34"><b class="cmd">::ral::relation restrictwith</b> <i class="arg">relationValue</i> <i class="arg">expression</i></a></dt>
<dd><p>The <b class="cmd">restrictwith</b> subcommand behaves like the <b class="cmd">restrict</b> subcommand
except that the values of the tuple attributes are
placed in Tcl variables that have
the same name as the attributes.
Each tuple in the body of <i class="arg">relationValue</i> is successively considered
and each attribute of the tuple is assigned to a Tcl variable that is the
same name as the attribute and <i class="arg">expression</i> is evaluated.
The resulting relation has a heading that is the same as <i class="arg">relationValue</i>
and a body consisting of all tuples where <i class="arg">expression</i> evaluated to true.
The <b class="cmd">restrictwith</b> subcommand is roughly equal to performing a
<b class="cmd">tuple assign</b> command on each tuple in <i class="arg">relationValue</i> before
evaluating <i class="arg">expression</i>.
The attribute variables are created if needed and will overwrite the values
of any variables that are named the same.
Also, the variables are deleted after the command completes.
Also note that <b class="cmd">restrictwith</b> will not function correctly if nested
with a more complex expression that also contains a <b class="cmd">restrictwith</b>
command for a <i class="arg">relationValue</i> with the same heading. In this case
the invocation of one <b class="cmd">restrictwith</b> may very well overwrite the
variables of a separate invocation.
With that restriction in mind,
the <b class="cmd">restrictwith</b> subcommand is often more convenient than
performing all the required <b class="cmd">tuple extract</b> commands that are
otherwise required.</p>
<pre class="example">
% relformat [relation restrictwith $DOG {[string match S* $DogName]}]
+-------+-------+
|DogName|Breed  |
|string |string |
+-------+-------+
|Sam    |Collie |
|Spot   |Terrier|
+-------+-------+
% puts $DogName
can't read &quot;DogName&quot;: no such variable
</pre>
</dd>
<dt><a name="35"><b class="cmd">::ral::relation semijoin</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?-using attrList?</span> <span class="opt">?relationValue3 ...?</span></a></dt>
<dd><p>The <b class="cmd">semijoin</b> subcommand computes the join of <i class="arg">relationValue1</i>
and <i class="arg">relationValue2</i> but eliminates all of the attributes of
<i class="arg">relationValue1</i>
(or alternatively speaking, projecting all attributes of <i class="arg">relationValue2</i>).
The returned relation has a heading the same as <i class="arg">relationValue2</i>
and a body consisting of those tuples in <i class="arg">relationValue2</i> that
would have been included in the natural join with <i class="arg">relationValue1</i>.
As with <b class="cmd">join</b>, if the <i class="arg">-using</i> argument are missing, the
join is computed across the attributes in <i class="arg">relationValue1</i> and
<i class="arg">relationValue2</i> that are named the same.
Otherwise the <i class="arg">attrList</i> argument is treated the same as for the
<b class="cmd">join</b> subcommand.
Also like the <b class="cmd">join</b> subcommand,
additional <i class="arg">relationValue</i> arguments may be given and the
result is computed in left to right order.
This implies that the type of the result is always the type of the right
most <i class="arg">relationValue</i>.
<em>N.B.</em> the sense of this command is inverted from previous versions of
this library.
For example, to find all the dogs that have some owner:</p>
<pre class="example">
% relformat [relation semijoin $OWNERSHIP $DOG]
+-------+---------+
|DogName|Breed    |
|string |string   |
+-------+---------+
|Fido   |Poodle   |
|Sam    |Collie   |
|Spot   |Terrier  |
|Rover  |Retriever|
|Fred   |Spaniel  |
+-------+---------+
</pre>
</dd>
<dt><a name="36"><b class="cmd">::ral::relation semiminus</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?-using attrList?</span> <span class="opt">?relationValue3 ...?</span></a></dt>
<dd><p>The <b class="cmd">semiminus</b> subcommand computes the difference between
<i class="arg">relationValue2</i> and the semijoin of <i class="arg">relationValue1</i> and
<i class="arg">relationValue2</i>.
The returned relation has a heading equal to that of <i class="arg">relationValue2</i>
and a body consisting of those tuples from <i class="arg">relationValue2</i> which would
<em>not</em> have been included in the natural join of <i class="arg">relationValue1</i>
and <i class="arg">relationValue2</i>.
The optional <i class="arg">-using</i> argument is treated in the same way as for
the <b class="cmd">join</b> subcommand.
Also like the <b class="cmd">semijoin</b> subcommand, additional <i class="arg">relationValue</i>
arguments may be given.
<em>N.B.</em> the sense of this command is inverted from previous versions of
this library.
For example, to find all dogs that have no owner:</p>
<pre class="example">
% relformat [relation semiminus $OWNERSHIP $DOG]
+-------+------+
|DogName|Breed |
|string |string|
+-------+------+
|Jumper |Mutt  |
+-------+------+
</pre>
</dd>
<dt><a name="37"><b class="cmd">::ral::relation summarize</b> <i class="arg">relationValue</i> <i class="arg">perRelation</i> <i class="arg">relationVarName</i> <i class="arg">attr</i> <i class="arg">type</i> <i class="arg">expression</i> <span class="opt">?<i class="arg">attr</i> <i class="arg">type</i> <i class="arg">expression</i> ...?</span></a></dt>
<dd><p>The <b class="cmd">summarize</b> subcommand allows for computations across sets of tuples.
The <i class="arg">perRelation</i> must be of the same type as a projection of
<i class="arg">relationValue</i>.
The returned relation has the same heading as <i class="arg">perRelation</i> extended
by <i class="arg">attr</i>.
The <i class="arg">attr</i> gives the name of the new attribute.
The name of the new attribute may not match any existing attributes in
<i class="arg">perRelation</i>.
The <i class="arg">type</i> argument is data type of the new attribute.
Several new attributes may be added in one <b class="cmd">summarize</b> command.
The body of the returned relation consists of all the tuples of
<i class="arg">perRelation</i> with values for the new attributes.
Those values are computed by evaluating the <i class="arg">summmary</i> arguments
as an expression.
Before evaluating <i class="arg">expression</i> for a tuple in <i class="arg">perRelation</i>,
<i class="arg">relationVarName</i> is set to a relation value consisting of
all the tuples in <i class="arg">relationValue</i> whose attributes match the
corresponding attributes in <i class="arg">perRelation</i>.
The <i class="arg">expression</i> expression may then access the value of that relation
using the given <i class="arg">relationVarName</i> variable name.
The <i class="arg">expression</i> must return a result that matches the
type of the new attribute.
In this example we determine the years when dogs were acquired and the
number of dogs acquired in each year.</p>
<pre class="example">
% set ac [relation project $OWNERSHIP Acquired]
{Acquired string} {{Acquired 2001} {Acquired 2000} {Acquired 2002} {Acquired 2003}}
% relformat [relation summarize $OWNERSHIP $ac s NumAcquired int {[relation cardinality $s]}]
+--------+-----------+
|Acquired|NumAcquired|
|string  |int        |
+--------+-----------+
|2001    |3          |
|2000    |2          |
|2002    |1          |
|2003    |1          |
+--------+-----------+
</pre>
<p>The <b class="cmd">summarize</b> command can also be used to perform
more complicated computations. In the case of summarizing over the
<em>dee</em> relation gives the ability to compute overall totals or
averages.
In this example we compute the average age of the owners.</p>
<pre class="example">
proc ravg {rel attr} {
    set sum 0
    relation foreach r $rel {
        tuple assign [relation tuple $r]
        incr sum $Age
    }
    return [expr {$sum / [relation cardinality $rel]}]
}
% set dee {{} {{}}}
{} {{}}
% relformat [relation summarize $OWNER $dee o AverageAge int {[ravg $o Age]}]
+----------+
|AverageAge|
|int       |
+----------+
|36        |
+----------+
</pre>
</dd>
<dt><a name="38"><b class="cmd">::ral::relation summarizeby</b> <i class="arg">relationValue</i> <i class="arg">attrList</i> <i class="arg">relationVarName</i> <i class="arg">attr</i> <i class="arg">type</i> <i class="arg">expression</i> <span class="opt">?<i class="arg">attr</i> <i class="arg">type</i> <i class="arg">expression</i> ...?</span></a></dt>
<dd><p>The <b class="cmd">summarizeby</b> subcommand is a more convenient form of
<b class="cmd">summarize</b> where the <em>per</em> relation is a projection of the
relation value that is to be summarized.
Rather than supplying a <em>per</em> relation, instead a list of attributes
is given by the <i class="arg">attrList</i> argument and <i class="arg">relationValue</i> is
projected on those attributes and used as the <i class="arg">per</i> relation.
The arguments and results are otherwise the same as for the <b class="cmd">summarize</b>
command.</p>
<pre class="example">
% relformat [relation summarizeby $OWNERSHIP Acquired s\ 
    NumAcquired int {[relation cardinality $s]}]
+--------+-----------+
|Acquired|NumAcquired|
|string  |int        |
+--------+-----------+
|2001    |3          |
|2000    |2          |
|2002    |1          |
|2003    |1          |
+--------+-----------+
</pre>
</dd>
<dt><a name="39"><b class="cmd">::ral::relation table</b> <i class="arg">heading</i> <i class="arg"><span class="opt">?value-list1 value-list2 ...?</span></i></a></dt>
<dd><p>The <b class="cmd">table</b> subcommand creates a new relation whose heading
is given by <i class="arg">heading</i> and tuples of the body are given by the
<i class="arg">value-listN</i> arguments.
The <i class="arg">heading</i> is an list containing an even number of elements
consisting of alternating attribute names and attribute data types.
The <i class="arg">value-listN</i> arguments are a list of attribute values.
It is assumed that the attribute values are given in the same order as
the attributes of the <i class="arg">heading</i> argument.
This command is a convenience command that is much like <b class="cmd">relation create</b>
but avoids having to give the attribute name for each attribute value
when specifying the tuples of the body.
This allows literal relation values to be specified in a tabular layout.</p>
<pre class="example">
set o [relation table {\ 
    OwnerName string   Age int     City string     } {
    Sue                24          Cupertino       } {
    George             35          Sunnyvale       } {
    Alice              30          {San Jose}      }]
</pre>
</dd>
<dt><a name="40"><b class="cmd">::ral::relation tag</b> <i class="arg">relationValue</i> <i class="arg">attrName</i> <span class="opt">?<i class="arg">-ascending | -descending sort-attr-list</i>?</span> <span class="opt">?<i class="arg">-within attr-list</i>?</span></a></dt>
<dd><p>The <b class="cmd">tag</b> subcommand creates a new relation which has the same heading
as <i class="arg">relationValue</i> extended by a new attribute named <i class="arg">attrName</i>.
The type of <i class="arg">attrName</i> will be <b class="type">int</b> and will have the values
between 0 and the cardinality of <i class="arg">relationValue</i> minus one.
The tuples in <i class="arg">relationValue</i> will be extended in either <i class="arg">ascending</i>
or <i class="arg">descending</i> order of the <i class="arg">sort-attr-list</i>.
If no <i class="arg">sort-attr-list</i> argument is given,
then the tagging order is arbitrary.
If the <span class="opt">?<i class="arg">-within</i>?</span> argument is given then
the values of <i class="arg">attrName</i> attribute will be unique within the subset of
tuples which match the values of <i class="arg">attr-list</i>.
The <b class="cmd">tag</b> command is useful when a full ordering needs to be placed
on a relation.
For example, tagging a relation will allow projecting both the tag and
another attribute without losing any values.</p>
<pre class="example">
% relformat [relation tag $DOG -ascending DogName DogId]
+-------+---------+-----+
|DogName|Breed    |DogId|
|string |string   |int  |
+-------+---------+-----+
|Fido   |Poodle   |0    |
|Fred   |Spaniel  |1    |
|Jumper |Mutt     |2    |
|Rover  |Retriever|3    |
|Sam    |Collie   |4    |
|Spot   |Terrier  |5    |
+-------+---------+-----+
% relformat [relation tag $OWNERSHIP -ascending OwnerName -within DogName DogId]
+---------+-------+--------+-----+
|OwnerName|DogName|Acquired|DogId|
|string   |string |string  |int  |
+---------+-------+--------+-----+
|Alice    |Spot   |2001    |0    |
|George   |Fido   |2001    |0    |
|George   |Sam    |2000    |0    |
|Jim      |Fred   |2003    |0    |
|Mike     |Rover  |2002    |0    |
|Sue      |Fido   |2001    |1    |
|Sue      |Sam    |2000    |1    |
+---------+-------+--------+-----+
</pre>
</dd>
<dt><a name="41"><b class="cmd">::ral::relation tclose</b> <i class="arg">relationValue</i></a></dt>
<dd><p>The <b class="cmd">tclose</b> subcommand returns a new relation value that is the
transitive closure of <i class="arg">relationValue</i>.
The <i class="arg">relationValue</i> must be a binary relation and each attribute must
be of the same type.
The returned relation has a heading that is the same as <i class="arg">relationValue</i>.
The pairs of attribute values in <i class="arg">relationValue</i> may be considered as
defining the edges of a graph.
The body of the transitive closure will contain all pairs of the two
attributes where there exists some path between the vertices in the implied
graph.
The original <i class="arg">relationValue</i> is necessarily a subset of the transitive
closure relation.
The <b class="cmd">tclose</b> subcommand often useful when there is a hierarchical
relationship among the data values.
Consider the employee / supervisor reporting relationship.
If we are interested in all people who report directly or indirectly
to John, then we have:</p>
<pre class="example">
% set REPORTS_TO {
  {Employee string Supervisor string}
  {
    {Employee Sue Supervisor John}
    {Employee Bob Supervisor John}
    {Employee Jane Supervisor Sue}
    {Employee Joe Supervisor Sue}
    {Employee Carl Supervisor Bob}
    {Employee James Supervisor Alice}
  }
}
% relformat [relation project [relation restrictwith\ 
[relation tclose $REPORTS_TO] {$Supervisor eq &quot;John&quot;}] Employee]\ 
&quot;Direct/Indirect Reports to John&quot;
+--------+
|Employee|
|string  |
+--------+
|Sue     |
|Bob     |
|Jane    |
|Joe     |
|Carl    |
+--------+
Direct/Indirect Reports to John
-------------------------------
</pre>
</dd>
<dt><a name="42"><b class="cmd">::ral::relation times</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?relationValue3 ...?</span></a></dt>
<dd><p>The <b class="cmd">times</b> subcommand returns the extended Cartesian product of two or
more relations.
The heading of the result is the union of the headings of all
the <i class="arg">relationValue</i> arguments.
The body of the result consists of a tuple for all combinations of the tuples
in all the <i class="arg">relationValue</i> arguments.
Since the relational multiplication operation is both
associative and commutative,
the order of the <i class="arg">relationValue</i> arguments has no effect on the result.</p>
<pre class="example">
% relformat [relation times $DOG $OWNER]
+-------+---------+---------+---+-------------+
|DogName|Breed    |OwnerName|Age|City         |
|string |string   |string   |int|string       |
+-------+---------+---------+---+-------------+
|Fido   |Poodle   |Sue      |24 |Cupertino    |
|Fido   |Poodle   |George   |35 |Sunnyvale    |
|Fido   |Poodle   |Alice    |30 |San Jose     |
|Fido   |Poodle   |Mike     |50 |San Jose     |
|Fido   |Poodle   |Jim      |42 |San Francisco|
|Sam    |Collie   |Sue      |24 |Cupertino    |
|Sam    |Collie   |George   |35 |Sunnyvale    |
|Sam    |Collie   |Alice    |30 |San Jose     |
|Sam    |Collie   |Mike     |50 |San Jose     |
|Sam    |Collie   |Jim      |42 |San Francisco|
|Spot   |Terrier  |Sue      |24 |Cupertino    |
|Spot   |Terrier  |George   |35 |Sunnyvale    |
|Spot   |Terrier  |Alice    |30 |San Jose     |
|Spot   |Terrier  |Mike     |50 |San Jose     |
|Spot   |Terrier  |Jim      |42 |San Francisco|
|Rover  |Retriever|Sue      |24 |Cupertino    |
|Rover  |Retriever|George   |35 |Sunnyvale    |
|Rover  |Retriever|Alice    |30 |San Jose     |
|Rover  |Retriever|Mike     |50 |San Jose     |
|Rover  |Retriever|Jim      |42 |San Francisco|
|Fred   |Spaniel  |Sue      |24 |Cupertino    |
|Fred   |Spaniel  |George   |35 |Sunnyvale    |
|Fred   |Spaniel  |Alice    |30 |San Jose     |
|Fred   |Spaniel  |Mike     |50 |San Jose     |
|Fred   |Spaniel  |Jim      |42 |San Francisco|
|Jumper |Mutt     |Sue      |24 |Cupertino    |
|Jumper |Mutt     |George   |35 |Sunnyvale    |
|Jumper |Mutt     |Alice    |30 |San Jose     |
|Jumper |Mutt     |Mike     |50 |San Jose     |
|Jumper |Mutt     |Jim      |42 |San Francisco|
+-------+---------+---------+---+-------------+
</pre>
</dd>
<dt><a name="43"><b class="cmd">::ral::relation tuple</b> <i class="arg">relationValue</i></a></dt>
<dd><p>The <b class="cmd"><a href="tuple.html">tuple</a></b> subcommand returns the body of <i class="arg">relationValue</i> as a tuple.
The cardinality of <i class="arg">relationValue</i> must be one or an error is returned.</p></dd>
<dt><a name="44"><b class="cmd">::ral::relation uinsert</b> <i class="arg">relationValue</i> <span class="opt">?<i class="arg">name-value-list1 name-value-list2 ...</i>?</span></a></dt>
<dd><p>The <b class="cmd">uinsert</b> subcommand operates in the same fashion as the
<b class="cmd">insert</b> subcommand, except that attempts to insert duplicate
tuples are silently ignored.
Thus the <b class="cmd">uinsert</b> subcommand has union type semantics.</p></dd>
<dt><a name="45"><b class="cmd">::ral::relation ungroup</b> <i class="arg">relationValue</i> <i class="arg">attribute</i></a></dt>
<dd><p>The <b class="cmd">ungroup</b> subcommand maps relations that have relation valued
attributes to relations that have scalar valued attributes.
It is the complementary operation to the <b class="cmd">group</b> command.
The <i class="arg">attribute</i> argument must be the name of a relation valued
attribute of <i class="arg">relationValue</i>.
The returned relation has a heading consisting of all the attributes of
<i class="arg">relationValue</i> minus <i class="arg">attribute</i> plus all the attributes of the
<i class="arg">attribute</i> relation.
The body of the returned relation consists of tuples composed of pairing
each tuple from the <i class="arg">attribute</i> attribute with its corresponding
components from <i class="arg">relationValue</i>.</p>
<pre class="example">
set OwnerContacts {
    {OwnerName string Contact {Relation {Type string Number string} Type}} {
	{OwnerName Sue Contact {
	    {Type Home Number 555-1212}
	    {Type Work Number 555-6635}}
	}
	{OwnerName George Contact {
	    {Type Home Number 555-8810}
	    {Type Work Number 555-1177}
	    {Type Mobile Number 555-3399}}
	}
    }
}
% relformat $OwnerContacts
+---------+-----------------+
|OwnerName|Contact          |
|string   |Relation         |
+---------+-----------------+
|Sue      |+------+--------+|
|         ||Type  |Number  ||
|         ||string|string  ||
|         |+------+--------+|
|         ||Home  |555-1212||
|         ||Work  |555-6635||
|         |+------+--------+|
|George   |+------+--------+|
|         ||Type  |Number  ||
|         ||string|string  ||
|         |+------+--------+|
|         ||Home  |555-8810||
|         ||Work  |555-1177||
|         ||Mobile|555-3399||
|         |+------+--------+|
+---------+-----------------+
% relformat [relation ungroup $OwnerContacts Contact]
+---------+------+--------+
|OwnerName|Type  |Number  |
|string   |string|string  |
+---------+------+--------+
|Sue      |Home  |555-1212|
|Sue      |Work  |555-6635|
|George   |Home  |555-8810|
|George   |Work  |555-1177|
|George   |Mobile|555-3399|
+---------+------+--------+
</pre>
</dd>
<dt><a name="46"><b class="cmd">::ral::relation union</b> <i class="arg">relationValue1</i> <i class="arg">relationValue2</i> <span class="opt">?relationValue3 ...?</span></a></dt>
<dd><p>The <b class="cmd">union</b> subcommand returns the set union of two or more relations.
All relations must be of the same type.
The result relation has a heading that is the same as any of the arguments
and has a body consisting of all tuples present in any of the
<i class="arg">relationValue</i> arguments.
Since the union operation is both associative and commutative,
the order of the <i class="arg">relationValue</i> arguments has no effect the result.</p></dd>
<dt><a name="47"><b class="cmd">::ral::relation unwrap</b> <i class="arg">relationValue</i> <i class="arg">attribute</i></a></dt>
<dd><p>The <b class="cmd">unwrap</b> subcommand operates on relation values in a manner similar to
the way that the <b class="cmd">tuple unwrap</b> command operates on tuple values.
The <i class="arg">attribute</i> argument is the name of a tuple valued attribute.
The result relation has the same heading as <i class="arg">relationValue</i> minus
the <i class="arg">attribute</i> plus all the attributes contained in the
tuple valued attribute, <i class="arg">attribute</i>.
In essense the tuple valued attribute, <i class="arg">attribute</i>, is flattened
by one level.</p></dd>
<dt><a name="48"><b class="cmd">::ral::relation update</b> <i class="arg">relationValue</i> <i class="arg">tupleVarName</i> <i class="arg">expr</i> <i class="arg">script</i></a></dt>
<dd><p>The <b class="cmd">update</b> subcommand returns a new relation value that has the
same heading as <i class="arg">relationValue</i> and whose tuple have been modified.
Each tuple in <i class="arg">relationValue</i> is assigned to the Tcl variable
given by <i class="arg">tupleVarName</i> and <i class="arg">expr</i> is evaluated.
If <i class="arg">expr</i> is true then <i class="arg">script</i> is evaluated.
The return value of <i class="arg">script</i> is added to the result relation and it
must be a tuple that has the same heading as <i class="arg">relationValue</i>.
If <i class="arg">expr</i> is false then the unmodified tuple from <i class="arg">relationValue</i>
is added to the result.
This command serves the same role for relation values as the
<b class="cmd">relvar update</b> command does for relvars.</p></dd>
<dt><a name="49"><b class="cmd">::ral::relation wrap</b> <i class="arg">relationValue</i> <i class="arg">tupleattr</i> <span class="opt">?<i class="arg">attr1 attr2 ...</i>?</span></a></dt>
<dd><p>The <b class="cmd">wrap</b> subcommand operates on relation values in a manner similar
to the way that the <b class="cmd">tuple wrap</b> command operates on tuple values.
The result relation has a heading that is the same as <i class="arg">relationValue</i>
plus an attribute named, <i class="arg">tupleattr</i>, minus the <i class="arg">attrN</i> attributes.
The values of the <i class="arg">attrN</i> attributes are converted into a tuple
valued attribute that is stored in <i class="arg">tupleattr</i>.</p>
<pre class="example">
% set r {
    {Name string Street string City string State string Zip string} {
        {Name Arnold Street Main City Sacramento State CA Zip 94444}
        {Name Mary Street Elm City Stockton State CA Zip 95555}
    }
}
% relformat [relation wrap $r Address Street City State Zip]
+------+---------------------------------+
|Name  |Address                          |
|string|Tuple                            |
+------+---------------------------------+
|Arnold|+------+----------+------+------+|
|      ||Street|City      |State |Zip   ||
|      ||string|string    |string|string||
|      |+------+----------+------+------+|
|      ||Main  |Sacramento|CA    |94444 ||
|      |+------+----------+------+------+|
|Mary  |+------+--------+------+------+  |
|      ||Street|City    |State |Zip   |  |
|      ||string|string  |string|string|  |
|      |+------+--------+------+------+  |
|      ||Elm   |Stockton|CA    |95555 |  |
|      |+------+--------+------+------+  |
+------+---------------------------------+
</pre>
</dd>
</dl>
</div>
<div id="see-also" class="section"><h2><a name="see-also">See Also</a></h2>
<p><a href="relvar.html">relvar</a>, <a href="tuple.html">tuple</a></p>
</div>
<div id="keywords" class="section"><h2><a name="keywords">Keywords</a></h2>
<p><a href="../index.html#key4">body</a>, <a href="../index.html#key1">relation</a>, <a href="../index.html#key2">tuple</a></p>
</div>
<div id="copyright" class="section"><h2><a name="copyright">Copyright</a></h2>
<p>Copyright &copy; 2004 - 2015 by G. Andrew Mangogna</p>
</div>
</div></body></html>
