[manpage_begin relvar n 0.8]
[comment {
# This software is copyrighted 2004, 2005, 2006 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
# 
#  *++
# MODULE:
#   relvar.man -- documentation for the ::ral::relvar command
# ABSTRACT:
#   This file contains the documentation for the ::ral::relvar command.
#   This command is part of TclRAL. This file is in Tcl Markup Language
#   format.
# $RCSfile: relvar.man,v $
# $Revision: 1.4 $
# $Date: 2006/07/17 03:55:46 $
#  *--
}]
[moddesc "Relvar Operators"]
[titledesc "Operators for Relation Variables"]
[copyright "2004 by G. Andrew Mangogna"]
[require ral [opt 0.8]]
[description]
This manpage describes the [cmd relvar] command.
The [cmd relvar] command is part of the Tcl Relational Algebra Library
(ral) package.

[para]
TclRAL defines a variable space for relation variables.
Relation variables hold relation values and the subcommands of the
[cmd relvar] command generally operate directly on the values storing
the results back into the relation variables.
For this reason, most of the [cmd relvar] subcommands
take the name of a relation variable as an argument.

[para]
In the relational model as it applies to database management systems,
relation variables play the important role of
representing the persistent data base values.
Relation variables are the leaves of the
expression tree that perform the desired query and represent
the core data from which results may be computed.
That computation is usually expressed as a single, sometimes complex expression.
This allows for a non-procedural way of specifying the computation and
allows optimizers to find the most efficient manner of computing the result.

[para]
In the TclRAL implementation of the relational model,
relation variables serve a similar role although there
is no implicit persistence supplied by the library.
Relation values may be stored in Tcl variables like any other Tcl object.
This does abandon the non-procedural nature of relational expressions
as usually accomplished in the relational model, but is a better fit
to the Tcl way of doing things.

[para]
Since it is possible to store a relation value in an ordinary Tcl variable
and since Tcl variables are convenient to use when formulating expressions,
creating a relvar also creates a corresponding Tcl variable by the same name.

[section "RELVAR NAMES"]

The namespace of relvar names follows the familiar Tcl method of naming
ordinary Tcl variables.
Thus relvars have Tcl namespace-like names.
For example, a relvar named [var Dog] created at the global level
will be named [var ::Dog].
Thus it is possible and indeed encouraged to group related relvars
together in a namespace.
If an application uses only one set of relvars,
then the global namespace of relvars is most convenient.
Using several distinct sets of relvars is best accomplished if each
set is placed in their own relvar namespace.

[section CONSTRAINTS]

TclRAL supports the notion of [emph constraints] as a means of
insuring integrity among a set of relvars.
There are many types of constraints that might be used to insure integrity,
but TclRAL supports two types of declarative constraints.
[list_begin definitions]

[lst_item Association]
Association constraints define a referential association between two relvars.
In this context,
an association declares that a set of attributes in one relvar refers to
an identifier of another relvar.
Thus for all the tuples in a given relvar,
the given attribute values must match the corresponding attribute values
of the identifier of the associated relvar.
The association also declares the number of times that such matches may
occur and if it is allowed not to match at all.

[lst_item Partition]
Partition constraints define a complete and disjoint
referential partitioning between one relvar,
known as the super set,
and a given set of relvars,
known as the sub sets.
This constraint declares that every tuple of the super set relvar is
referred to by exactly one tuple from among all the tuples in the
sub set relvars.

[list_end]

At the end of each [cmd ::ral::eval] command (see below) or,
if outside of an [cmd eval] command,
at the end of any command that modifies a relvar
that participates in a constraint,
all of the constraints defined for the modified relvars are evaluated.
If any of the constraints fail, the relvar modifications are discarded
and the relvar values are returned to the values they had before
the modifications.

Like relvars, constraints have names.
Constraints names follow the same pattern as relvar names, i.e.
unresolved names are created in the current namespace.
Thus you are able to keep the relvars and their constraints organized
together in namespace like groups.

[section COMMANDS]
[list_begin definitions]
[call [cmd "::ral::relvar association"] [arg name]\
    [arg refrngRelvar] [arg refrngAttrList] [arg refToSpec]\
    [arg refToRelvar] [arg refToAttrList] [arg refrngSpec]\
]

The [cmd association] subcommand creates a referential association
between two relvars called [arg name].
The return value of [cmd association] is the empty string.
Associations declare that one relvar has attributes that refer to
an identifier of another relvar.
The referring relvar name is given by the [arg refrngRelvar] argument
and the referring attributes are given by [arg refrngAttrList] argument.
The referred to relvar name is given by [arg refToRelvar] and the
attributes that are referred to by [arg refToAttrList]. The referring
and referred to attribute lists are ordered and referring attributes
refer to the corresponding referred to attribute.
The set of attributes given by [arg refToAttrList] must constitute
and identifier for [arg refToRelvar].
The [arg refToSpec] argument defines
the multiplicity and conditionality of the reference.
It can be one of:

[list_begin definitions]

[lst_item *]
Each tuple in [arg refToRelvar] is referred to zero or more times by
the tuples in [arg refrngRelvar].

[lst_item +]
Each tuple in [arg refToRelvar] is referred to one or more times by
the tuples in [arg refrngRelvar].

[lst_item 1]
Each tuple in [arg refToRelvar] is referred to exactly once by
the tuples in [arg refrngRelvar].

[lst_item ?]
Each tuple in [arg refToRelvar] is referred to zero or one times by
the tuples in [arg refrngRelvar].

[list_end]

Similarly [arg refrngSpec] defines the multiplicity and conditionality
associated with the references to [arg refToRelvar].
Necessarily, [arg refrngSpec] may only be "1" or "?" implying:
[list_begin definitions]

[lst_item 1]
Each tuple in [arg refrngRelvar] refers to exactly one tuple in
[arg refToRelvar].

[lst_item ?]
Each tuple in [arg refrngRelvar] refers to at most one tuple
(and possibly none at all) in [arg refToRelvar].

[list_end]

The symbols for [arg refrngSpec] and [arg refToSpec] were chosen
by analogy to the use of those symbols in regular expression syntax.

[example {
% relvar association A1 OWNERSHIP OwnerName + OWNER OwnerName 1
% relvar association A2 OWNERSHIP DogName * DOG DogName 1
}]

In this example,
A1 declares that for every tuple in OWNERSHIP,
the value of OWNERSHIP.OwnerName matches the value of OWNER.OwnerName
in exactly one tuple of OWNER and that for every tuple in OWNER the
value of OWNER.OwnerName matches the value of OWNERSHIP.OwnerName in
at least one tuple of OWNERSHIP and possibly more.
In the semantics of this example, the concepts of being an OWNER
and that of OWNERSHIP of a DOG are unconditionally associated since
no tuple of OWNER may exist without there being at least one associated
tuple of OWNERSHIP.
Also this constraint allows for OWNERS that may own more than one DOG.

Compare this to the case of A2.
A2 states that every tuple in OWNERSHIP must have a corresponding tuple
in DOG, but that tuples in DOG may not be reference by any tuple in OWNERSHIP.
OWNERSHIP and DOG are conditionally associated
and in the semantics of this problem, it is possible to have dogs that 
are not owned at all and to have dogs that are owned multiple times.

[call [cmd "::ral::relvar constraint delete"]\
	[opt "[arg name1] [arg name2] ..."]]
The [cmd "constraint delete"] subcommand deletes all the
constraints given by the [arg nameN] arguments.
The return value is the empty string.

[call [cmd "::ral::relvar constraint info"] [arg name]]
The [cmd "constraint info"] subcommand returns the detailed information
about the constraint named [arg name].
The information returned is of the same format as the command used
to create the partition minus the superfluous leading [cmd relvar].
Also the relvar names and constraint names are returned in fully qualified
form.

[example {
% relvar constraint info A1
association ::A1 ::OWNERSHIP OwnerName + ::OWNER OwnerName 1
% relvar constraint info ::P1
partition ::P1 ::Lamp SerialNo ::TableLamp SerialNo ::FloorLamp SerialNo
% relvar constraint info G
unknown constraint name, "G"
}]

[call [cmd "::ral::relvar constraint names"] [opt [arg pattern]]]

The [cmd "constraint names"] subcommand returns a list of constraint names.
If the optional [arg pattern] is present,
then only those constraint names that match [arg pattern] are returned.
Name matching happens in the same manner as for the [cmd "string match"].
The returned names are fully qualified.

[example {
% relvar constraint names
::A1 ::A2
% relvar constraint names *2
::A2
}]

[call [cmd "::ral::relvar create"] [arg relvarName] [arg heading]]

The [cmd create] subcommand creates a new relation variable whose name is given
by [arg relvarName] and that has the relation value heading given
by the [arg heading] argument.
The subcommand returns the relation value of the newly created relvar,
which necessarily will have cardinality of 0.
The [arg heading] argument is a valid relation value heading
as described for the [cmd ::ral::relation] commands or
as returned from [cmd "::ral::relation heading"].
If [arg relvarName] name begins with "::", then it is interpreted
as a fully resolved name and will be created in the given namespace.
Othersize [arg relvarName] is interpreted relative the to current
namespace and will be created in the current namespace.
In either case,
an ordinary Tcl variable is also created by the same fully resolved
name as the relvar.
This implies that any namespaces referenced in [arg relvarName]
must already exist.

[example {
% relvar create OWNER {
>       Relation
>       {OwnerName string Age int City string}
>       OwnerName
>     }
Relation {OwnerName string Age int City string} OwnerName {}
% puts [relformat $::OWNER]
+=========+---+------+
|OwnerName|Age|City  |
|string   |int|string|
+=========+---+------+
+=========+---+------+
% relvar create DOG {
>       Relation
>       {DogName string Breed string}
>       DogName
>     }
Relation {DogName string Breed string} DogName {}
% relvar create OWNERSHIP {
>       Relation
>       {OwnerName string DogName string Acquired string}
>       {{OwnerName DogName}}
>     }
Relation {OwnerName string DogName string Acquired string} {{OwnerName DogName}} {}
}]

[call [cmd "::ral::relvar delete"] [arg relvarName]\
    [arg tupleVarName] [arg expression]]

The [cmd delete] subcommands deletes tuples from the relation variable
given by the [arg relvarName] argument.
Each tuple in the body of [arg relvarName] is successively
assigned to the tuple variable named [arg tupleVarName] and
[arg expression] is evaluated.
If [arg expression] returns true, then that tuple is deleted, directly
modifying the value contained in [arg relvarName].
The return value of the subcommand is the number of tuples deleted.

[example {
% puts [relformat $::OWNER "Before deleting Sue"]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
Before deleting Sue
-------------------
% relvar delete OWNER o {[tuple extract $o OwnerName] eq "Sue"}
1
% puts [relformat $::OWNER "After deleting Sue"]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
After deleting Sue
------------------
}]

[call [cmd "::ral::relvar deleteone"] [arg relvarName]\
    [opt "attr1 value1 attr2 value2 ..."]]

The [cmd deleteone] subcommand deletes at most one tuple from the
relation variable given by the [arg relvarName] argument.
The [arg "attrN valueN"] arguments must be given in pairs
and are the attribute names and values that determine which tuple
is deleted from the relation value held in [arg relvarName].
The set of attribute names in the [arg "attrN valueN"] arguments
must form one of the identifiers of [arg relvarName].
If [arg relvarName] contains a tuple whose attribute values match those
in given then that tuple is deleted and [arg relvarName]
is modified in place.
Otherwise [arg relvarName] is unchanged.
This subcommand is useful in those contexts where the attribute values of an
identifier are known and evaluating an expression over all the tuples
in [arg relvarName] is superfluous.
The return value of the subcommand is the number of tuples deleted which will
necessarily be either 1 or 0.

[example {
% puts [relformat $::OWNER "Before deleting Mike"]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
Before deleting Mike
--------------------
% relvar deleteone OWNER OwnerName Mike
1
% puts [relformat $::OWNER "After deleting Mike"]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
After deleting Mike
-------------------
% relvar deleteone OWNER OwnerName Alfonse
0
% puts [relformat $::OWNER]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
}]

[call [cmd "::ral::relvar eval"] [arg arg] [opt "arg ..."]]

The [cmd eval] subcommand concatenates it arguments together and evaluates
the resulting script as a relvar transaction.
The return value of [cmd eval] is the return value of the last
command executed in the script.
At the end of the script,
the constraints associated with any relvar that was modified
by the script are evaluated.
If either the script generates an error or any of the constraints fail,
then the values of the modified relvars are returned to the values
they held before the [cmd eval] command.
It is an error to attempt to create relvars or constraints in the
script executed by [cmd eval].

[example {
% puts [relformat $::OWNER]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
% relvar eval {
>       relvar insert OWNER {OwnerName Tom Age 22 City Tulsa}
> }
for association ::A1(::OWNERSHIP [+] ==> [1] ::OWNER), in relvar ::OWNER
tuple {OwnerName Tom Age 22 City Tulsa} is not referenced by any tuple

% puts [relformat $::OWNER]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
% relvar eval {
>       relvar insert OWNER {OwnerName Tom Age 22 City Tulsa}
>       relvar insert OWNERSHIP {OwnerName Tom DogName Skippy Acquired 2006}
> }
for association ::A2(::OWNERSHIP [*] ==> [1] ::DOG), in relvar ::OWNERSHIP
tuple {OwnerName Tom DogName Skippy Acquired 2006} references no tuple

% puts [relformat $::OWNER]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
% relvar eval {
>       relvar insert OWNER {OwnerName Tom Age 22 City Tulsa}
>       relvar insert OWNERSHIP {OwnerName Tom DogName Jumper Acquired 2006}
>       return
> }
% puts [relformat $::OWNER]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
|Tom      |22 |Tulsa        |
+=========+---+-------------+
}]

[call [cmd "::ral::relvar insert"] [arg relvarName]\
    [opt "name-value-list ..."]]

The [cmd insert] subcommand inserts the tuples given by [arg name-value-list]
arguments into the value of the relation stored in [arg relvarName].
The value of [arg relvarName] is modified in place.
The subcommand has no return value.
It is an error to attempt to insert a duplicate tuple or a tuple whose
heading does not match the relation heading.
All values of the tuple must be specfied with a valid value representation of
the type associated with the attribute.

[example {
% relvar insert DOG {DogName Skippy Breed Dalmation}
Relation {DogName string Breed string} DogName {{DogName Fido Breed Poodle} {DogName Sam Breed Collie} {DogName Spot Breed Terrier} {DogName Rover Breed Retriever} {DogName Fred Breed Spaniel} {DogName Jumper Breed Mutt} {DogName Skippy Breed Dalmation}}
% relvar insert OWNER {OwnerName Tom Age 22 City Tulsa}
for association ::A1(::OWNERSHIP [+] ==> [1] ::OWNER), in relvar ::OWNER
tuple {OwnerName Tom Age 22 City Tulsa} is not referenced by any tuple

}]


[call [cmd "::ral::relvar names"] [opt pattern]]

The [cmd names] subcommand returns a list of the currently defined
relation variables.
If the [arg pattern] argument is specified then only those names matching
[arg pattern] are returned.
Name matching is performed as for the [cmd "string match"] command.
The returned names are fully qualified.

[example {
% relvar names
::DOG ::OWNERSHIP ::OWNER
% relvar names ::D*
::DOG
}]

[call [cmd "::ral::relvar partition"] [arg name] [arg super]\
	[arg superAttrList] [arg sub1] [arg sub1AttrList]\
	[opt "sub2 sub2AttrList sub3 sub3AttrList ..."]]

The [cmd partition] subcommand defines a partition constraint named
[arg name].
The relvar named [arg super] must have as one of its identifiers the
attributes named in the [arg superAttrList] argument.
The remaining arguments define the sub set relvars named [arg subN]
and the attributes in those relvars that reference the super set relvar
are given by the [arg subNAttrList] arguments.
A partition constraint declares that every tuple in the [arg subN]
relvars references exactly one tuple in the [arg super] relvar and that
every tuple in the [arg super] relvar is referred to by exactly one
tuple contained in one of the [arg subN] relvars.
This constraint implies that the tuples in the [arg super] relvar are
completely partitioned into the disjoint sub sets given by the the
[arg subN] relvars.

[example {
% relvar create Lamp {
>       Relation
>       {SerialNo string ModelNo string Make string}
>       SerialNo
>     }
Relation {SerialNo string ModelNo string Make string} SerialNo {}
% relvar create TableLamp {
>       Relation
>       {SerialNo string Shade string}
>       SerialNo
>     }
Relation {SerialNo string Shade string} SerialNo {}
% relvar create FloorLamp {
>       Relation
>       {SerialNo string Height int Sockets int}
>       SerialNo
>     }
Relation {SerialNo string Height int Sockets int} SerialNo {}
% relvar partition P1 Lamp SerialNo TableLamp SerialNo FloorLamp SerialNo
% relvar insert Lamp {SerialNo NF100 ModelNo FCN-22  Make Falcon}
for partition ::P1(::Lamp is partitioned [::TableLamp | ::FloorLamp]), in relvar ::Lamp
tuple {SerialNo NF100 ModelNo FCN-22 Make Falcon} is not referred to by any tuple

% relvar eval {
>       relvar insert Lamp {SerialNo NF100 ModelNo FCN-22  Make Falcon}
>       relvar insert TableLamp {SerialNo NF100  Shade Blue}
>       return
>     }
% relvar insert FloorLamp {SerialNo NF100 Height 72 Sockets 3}
for partition ::P1(::Lamp is partitioned [::TableLamp | ::FloorLamp]), in relvar ::Lamp
tuple {SerialNo NF100 ModelNo FCN-22 Make Falcon} is referred to by multiple tuples

% relvar insert FloorLamp {SerialNo NF101 Height 72 Sockets 3}
for partition ::P1(::Lamp is partitioned [::TableLamp | ::FloorLamp]), in relvar ::FloorLamp
tuple {SerialNo NF101 Height 72 Sockets 3} references no tuple

}]


[call [cmd "::ral::relvar set"] [arg relvarName] [opt relationValue]]

The [cmd set] subcommand replaces the current value held by the relation
variable named [arg relvarName] with the value given by
[arg relationValue].
It is an error to attempt to assign a relation value to a relation variable
that is of a different type than the type of the value
that the variable currently holds.
In other words, it is not possible to change the type of a relvar
by assignment.
The return value of the subcommand the current value
held by [arg relvarName].
If the [arg relationValue] argument is missing, then no attempt is made to
change the value of [arg relvarName].
This command operates in a manner analogous to the [cmd set] command for
ordinary Tcl variables.

[example {
% relvar create PUPPY {
>       Relation
>       {PuppyName string Dame string Sire string}
>       PuppyName
>     }
Relation {PuppyName string Dame string Sire string} PuppyName {}
% relvar set PUPPY {
>       Relation
>       {PuppyName string Dame string Sire string}
>       PuppyName
>       {
>           {PuppyName Bitsy Dame Spot Sire Jumper}
>       }
>     }
Relation {PuppyName string Dame string Sire string} PuppyName {{PuppyName Bitsy Dame Spot Sire Jumper}}
% relvar set PUPPY $::DOG
headings not equal, "Relation {DogName string Breed string} DogName"
}]

[call [cmd "::ral::relvar unset"] [opt "relvarName ..."]]

The [cmd unset] deletes all the relation variables whose names are given
as the subcommand arguments.
The corresponding Tcl variables that were created when the relvar
was created are also [cmd unset].
This command operates in a manner analogous to the [cmd unset] command for
ordinary Tcl variables.
It is an error to attempt to [cmd unset] a relvar that is associated
with any constraints.

[call [cmd "::ral::relvar update"] [arg relvarName] [arg tupleVarName]\
    [arg expression] [arg script]]

The [cmd update] subcommand modifies the values of tuples in the relation
value contained in the relation variable given by [arg relvarName].
Each tuple in [arg relvarName] is successively assigned to the tuple
variable given by [arg tupleVarName] and [arg expression] is evaluated.
If the result of the evaluation is true,
then [arg script] is evaluated.
The value of [arg tupleVarName] at the end of executing
[arg script] is then updated into [arg relvarName].
Typically, [arg script] will invoke [cmd "::ral::tuple update"]
to modify the value of [arg tupleVarName].
The return value of the subcommand is the number of tuples updated.

[example {
% puts [relformat $::OWNER]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
% relvar update OWNER o {[tuple extract $o OwnerName] eq "Sue"} {
>       tuple update o Age [expr {[tuple extract $o Age] + 1}]
>     }
1
% puts [relformat $::OWNER]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |25 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
% relvar update OWNER o {[tuple extract $o OwnerName] eq "George"} {
>       tuple update o OwnerName Alfonse
>     }
for association ::A1(::OWNERSHIP [+] ==> [1] ::OWNER), in relvar ::OWNER
tuple {OwnerName Alfonse Age 35 City Sunnyvale} is not referenced by any tuple
for association ::A1(::OWNERSHIP [+] ==> [1] ::OWNER), in relvar ::OWNERSHIP
tuple {OwnerName George DogName Fido Acquired 2001} references no tuple
tuple {OwnerName George DogName Sam Acquired 2000} references no tuple

% puts [relformat $::OWNER]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |25 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
}]

[call [cmd "::ral::relvar updateone"] [arg relvarName]\
    [arg id-name-value-list] [arg name-value-list]]

The [cmd updateone] subcommand modifies at most one tuple from the
relation variable given by the [arg relvarName] argument.
The [arg id-name-value-list] must be list containing an even number of elements
which are attribute names alternating with attribute values.
The set of attribute names in [arg id-name-value-list] must form one of the
identifiers of [arg relvarName].
If [arg relvarName] contains a tuple whose attribute values match those
in [arg name-value-list] then
then the attributes whose names are mentioned in the [arg name-value-list]
are set to the corresponding values and [arg relvarName]
is modified in place.
Otherwise [arg relvarName] is unchanged.
This subcommand is useful in those contexts where the attribute values of an
identifier are known and evaluating an expression over all the tuples
in [arg relvarName] is superfluous.
The return value of the subcommand is the number of tuples updated
which will necessarily be either 0 or 1.

[example {
% puts [relformat $::OWNER]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
% relvar updateone OWNER {OwnerName George} {Age 37 City {New York}}
1
% puts [relformat $::OWNER]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |24 |Cupertino    |
|George   |37 |New York     |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
}]

[list_end]

[see_also tuple relation]

[keywords relation variable]

[manpage_end]
