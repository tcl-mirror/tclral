[manpage_begin relvar n 0.8]
[comment {
# This software is copyrighted 2004 by G. Andrew Mangogna.  The following
# terms apply to all files associated with the software unless explicitly
# disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
# 
#  *++
# MODULE:
# 
# ABSTRACT:
# 
# $RCSfile: relvar.man,v $
# $Revision: 1.2 $
# $Date: 2006/07/09 03:48:13 $
#  *--
}]
[moddesc "Relvar Operators"]
[titledesc "Operators for Relation Variables"]
[copyright "2004 by G. Andrew Mangogna"]
[require ral 0.8]
[description]
This manpage describes the [cmd relvar] command.
The [cmd relvar] command is part of the Tcl Relational Algebra Library
(ral) package.

[para]
TclRAL defines a variable space for relation variables.
Relation variables hold relation values and the subcommands of the
[cmd relvar] command generally operate directly on the values storing
the results back into the relation variables.
For this reason, most of the [cmd relvar] subcommands
take the name of a relation variable as an argument.

[para]
In the relational model, relation variables play the important role of
representing the persistent data base values.
Relation variables are the leaves of the
expression tree that performs the desired computation and represent
the core data from which results may be computed.
That computation is expressed as a single, sometimes complex expression.
This allows for a non-procedural way of specifying the computation and
allows optimizers to find the most efficient manner of computing the result.

[para]
In the TclRAL implementation,
relation variables serve a similar role although there
is no implicit persistence supplied by the library.
Relation values may be stored in Tcl variables like any other Tcl object.
This does abandon the non-procedural nature of relational expressions
as usually accomplished in the relational model, but is a better fit
to the Tcl way of doing things.

[para]
Since it is possible to store a relation value in an ordinary Tcl variable
and since Tcl variables are convenient to use,
all relvars have corresponding Tcl variables.

[section "RELVAR NAMES"]

[section CONSTRAINTS]

[para]
Constraints may be defined to exist between relvars.
The type of constraints supported by TclRAL are declarative in nature
and are used to implement referential integrity.


[section COMMANDS]
[list_begin definitions]
[call [cmd "::ral::relvar association"] [arg name]\
    [arg refrngRelvar] [arg refrngAttrList] [arg refrngSpec]\
    [arg refToRelvar] [arg refToAttrList] [arg refToSpec]\
]

The [cmd association] subcommand creates a referential association
between two relvars called [arg name].
The return value of [cmd association] is the empty string.
Associations declare that one relvar has attributes that refer to
an identifier of another relvar.
The referring relvar name is given by the [arg refrngRelvar] argument
and the referring attributes are given by [arg refrngAttrList] argument.
The referred to relvar name is given by [arg refToRelvar] and the
attributes that are referred to by [arg refToAttrList]. The referring
and referred to attribute lists are ordered and referring attributes
refer to the corresponding referred to attribute.
The set of attributes given by [arg refToAttrList] must constitute
and identifier for [arg refToRelvar].
The [arg refrngSpec] argument defines the multiplicity and conditionality
of the reference.
It can be one of:

[list_begin definitions]

[lst_item *]
Zero or more references.
[lst_item +]
One or more references.
[lst_item 1]
Exactly one reference.
[lst_item ?]
Zero or one reference.

[list_end]

Similarly [arg refToSpec] defines the multiplicity and conditionality
associated with the references to [arg refToRelvar].
Necessarily, [arg refToSpec] may only be "1" or "?" implying that
all the tuples of [arg refToRelvar] are referred to by [arg refrngRelvar]
or at least one tuple of [arg refToRelvar] is not referred to.

The symbols for [arg refrngSpec] and [arg refToSpec] were chosen to
by analogy to the use of those symbols in regular expression syntax.

[example {
% relvar association R1-Owner OWNERSHIP OwnerName + OWNER OwnerName 1
% relvar association R1-Dog OWNERSHIP DogName * DOG DogName ?
}]


[call [cmd "::ral::relvar constraint delete"]\
	[opt "[arg name1] [arg name2] ..."]]
[call [cmd "::ral::relvar constraint info"] [arg name]]
[call [cmd "::ral::relvar constraint names"] [opt [arg pattern]]]

[call [cmd "::ral::relvar create"] [arg relationVariable] [arg heading]]

The [cmd create] subcommand creates a new relation variable whose name is given
by [arg relationVariable] and that has the relation value heading given
by the [arg heading] argument.
The subcommand returns the relation value of the newly created relvar,
which necessarily will have cardinality of 0.
The [arg heading] argument is a valid relation value heading
as described for the [cmd ::ral::relation] commands or
as returned from [cmd "::ral::relation heading"].

[example {
% relvar create OWNER {Relation {OwnerName string Age int City string} OwnerName}
Relation {OwnerName string Age int City string} OwnerName {}
% relvar create DOG {Relation {DogName string Breed string} DogName}
Relation {DogName string Breed string} DogName {}
% relvar create OWNERSHIP {Relation {OwnerName string DogName string Acquired string} {{OwnerName DogName}}}
Relation {OwnerName string DogName string Acquired string} {{OwnerName DogName}} {}
}]


[call [cmd "::ral::relvar delete"] [arg relationVariable]\
    [arg tupleVariable] [arg expression]]

The [cmd delete] subcommands deletes tuples from the relation variable
given by the [arg relationVariable] argument.
Each tuple in the body of [arg relationVariable] is assigned to the
tuple variable named [arg tupleVariable] and [arg expression] is evaluated.
If [arg expression] returns true, then that tuple is deleted, directly
modifying the value contained in [arg relationVariable].
The return value of the subcommand is the number of tuples deleted.

[example {
% puts [relformat $::OWNER "Before deleting Sue"]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
Before deleting Sue
-------------------
% relvar delete OWNER o {[tuple extract $o OwnerName] eq "Sue"}
1
% puts [relformat $::OWNER "After deleting Sue"]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
After deleting Sue
------------------
}]


[call [cmd "::ral::relvar deleteone"] [arg relationVariable]\
    [opt "attr1 value1 attr2 value2 ..."]]

The [cmd deleteone] subcommand deletes at most one tuple from the
relation variable given by the [arg relationVariable] argument.
The [arg "attrN valueN"] arguments must be given and pairs
and are the attribute names and values that determine which tuple
is deleted from the relation value held in [arg relationVariable].
The set of attribute names in the [arg "attrN valueN"] arguments
must form one of the identifiers of [arg relationVariable].
If [arg relationVariable] contains a tuple whose attribute values match those
in given then that tuple is deleted and [arg relationVariable]
is modified in place.
Otherwise [arg relationVariable] is unchanged.
This subcommand is useful in those contexts where the attribute values of an
identifier are known and evaluating an expression over all the tuples
in [arg relationVariable] is superfluous.
The return value of the subcommand is the number of tuples deleted which will
necessarily be either 1 or 0.

[example {
% puts [relformat $::OWNER "Before deleting Mike"]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Mike     |50 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
Before deleting Mike
--------------------
% relvar deleteone OWNER OwnerName Mike
1
% puts [relformat $::OWNER "After deleting Mike"]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
After deleting Mike
-------------------
% relvar deleteone OWNER OwnerName Alfonse
0
% puts [relformat $::OWNER]
+=========+---+-------------+
|OwnerName|Age|City         |
|string   |int|string       |
+=========+---+-------------+
|Sue      |24 |Cupertino    |
|George   |35 |Sunnyvale    |
|Alice    |30 |San Jose     |
|Jim      |42 |San Francisco|
+=========+---+-------------+
}]


[call [cmd "::ral::relvar eval"]]

[call [cmd "::ral::relvar insert"] [arg relationVariable]\
    [opt "name-value-list ..."]]

The [cmd insert] subcommand inserts the tuples given by [arg name-value-list]
arguments into the value of the relation stored in [arg relationVariable].
The value is modified in place.
The subcommand has no return value.
It is an error to attempt to insert a duplicate tuple or a tuple whose
heading does not match the relation heading.
All values of the tuple must be specfied with a valid value representation of
the type associated with the attribute.

[example {
relvar insert OWNER\
    {OwnerName Sue Age 20 City {New York}}\
    {City {San Francisco} Age 32 OwnerName Frank}
}]

[call [cmd "::ral::relvar names"] [opt pattern]]

The [cmd names] subcommand returns a list of the currently defined
relation variables.
If the [arg pattern] argument is specified then only those names matching
[arg pattern] are returned.
Name matching is performed as for the [cmd "string match"] command.

[call [cmd "::ral::relvar partition"] [arg name] [arg super]\
	[arg superAttrList] [arg sub1] [arg sub1AttrList]\
	[opt "sub2 sub2AttrList sub3 sub3AttrList ..."]]

[call [cmd "::ral::relvar set"] [arg relationVariable] [opt relationValue]]

The [cmd set] subcommand replaces the current value held by the relation
variable named [arg relationVariable] with the value given by
[arg relationValue].
It is an error to attempt to assign a relation value to a relation variable
that is of a different type than the type of the value
that the variable currently holds.
In other words, it is not possible to change the type of a relvar
by assignment.
The return value of the subcommand the current value
held by [arg relationVariable].
If the [arg relationValue] argument is missing, then no attempt is made to
change the value of [arg relationVariable].
This command operates in a manner analogous to the [cmd set] command for
ordinary Tcl variables.

[call [cmd "::ral::relvar unset"] [opt "relationVariable ..."]]

The [cmd unset] deletes all the relation variables whose names are given
as the subcommand arguments.

[call [cmd "::ral::relvar update"] [arg relvarName] [arg tupleVarName]\
    [arg expression] [arg script]]

The [cmd update] subcommand modifies the values of tuples in the relation
value contained in the relation variable given by [arg relationVariable].
Each tuple in [arg relationVariable] is successively assigned to the tuple
variable given by [arg tupleVariable] and [arg expression] is evaluated.
If the result of the evaluation is true,
then the attributes whose names are mentioned in the [arg name-value-list]
are set to the corresponding values.
The [arg name-value-list] argument consists of alternating attribute names
and attribute values.
The return value of the subcommand is the number of tuples updated.
The example below updates Sue's Age to be 20.
[example {
relvar update OWNER o {[tuple extract $o OwnerName] eq "Sue"} {Age 20}
}]

[call [cmd "::ral::relvar updateone"] [arg relationVariable]\
    [arg id-name-value-list] [arg name-value-list]]

The [cmd updateone] subcommand modifies at most one tuple from the
relation variable given by the [arg relationVariable] argument.
The [arg id-name-value-list] must be list containing an even number of elements
which are attribute names alternating with attribute values.
The set of attribute names in [arg id-name-value-list] must form one of the
identifiers of [arg relationVariable].
If [arg relationVariable] contains a tuple whose attribute values match those
in [arg name-value-list] then
then the attributes whose names are mentioned in the [arg name-value-list]
are set to the corresponding values and [arg relationVariable]
is modified in place.
Otherwise [arg relationVariable] is unchanged.
This subcommand is useful in those contexts where the attribute values of an
identifier are known and evaluating an expression over all the tuples
in [arg relationVariable] is superfluous.
The return value of the subcommand is the number of tuples updated.

[list_end]

[see_also tuple relation]

[keywords relation variable]

[manpage_end]
