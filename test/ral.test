#!/bin/sh
# \
exec tclsh "$0" "$@"
# This software is copyrighted 2004, 2005, 2006, 2007, 2008, 2009
# by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
# 
#  *++
# MODULE:
#   ral.test -- test cases for the Tcl Relational Algebra Library
# 
# ABSTRACT:
#   This file contains a set of test cases suitable for execution via
#   "tcltest" to test the code associated with the TCL Relational
#   Algebra library.
# 
# $RCSfile: ral.test,v $
# $Revision: 1.54 $
# $Date: 2011/01/16 23:18:42 $
#  *--

package require tcltest 2.2
package require ral
package require struct::set

eval tcltest::configure $argv

if {[package vsatisfies [package require Tcl] 8.5]} {
    ::tcltest::testConstraint tcl8.5 1
    ::tcltest::testConstraint haveDict 1
} elseif {[package vsatisfies [package require Tcl] 8.4]} {
    ::tcltest::testConstraint tcl8.4 1
    if {![catch {package require dict}]} {
        ::tcltest::testConstraint haveDict 1
    }
} else {
    error "TclRAL has only been tested against Tcl 8.4 and 8.5"
}

namespace eval ::ral::test {
    namespace import ::tcltest::*
    namespace import ::ral::*

    proc tupleMatch {expected actual} {
        return [::ral::tuple equal $expected $actual]
    }
    customMatch tuple [namespace current]::tupleMatch

    proc relationMatch {expected actual} {
        return [::ral::relation is $expected == $actual]
    }
    customMatch relation [namespace current]::relationMatch

    proc setMatch {expected actual} {
        return [::struct::set equal $expected $actual]
    }
    customMatch set [namespace current]::setMatch

    if {[testConstraint haveDict]} {
        proc dictMatch {expected actual} {
            if {[dict size $expected] != [dict size $actual]} {
                return 0
            }
            dict for {exKey exVal} $expected {
                if {[dict get $actual $exKey] != $exVal} {
                    return 0
                }
            }
            return 1
        }
    } else {
        proc dictMatch {expected actual} {return 0}
    }
    customMatch dict [namespace current]::dictMatch

    set DEE {{} {{}}}
    set DUM {{} {}}

    # The Date example relations.
    set S {{S# string SNAME string STATUS int CITY string} {
            {S# S1 SNAME Smith STATUS 20 CITY London}
            {S# S2 SNAME Jones STATUS 10 CITY Paris}
            {S# S3 SNAME Blake STATUS 30 CITY Paris}
            {S# S4 SNAME Clark STATUS 20 CITY London}
            {S# S5 SNAME Adams STATUS 30 CITY Athens}
        }
    }
    set P {{P# string PNAME string COLOR string WEIGHT double CITY string} {
            {P# P1 PNAME Nut COLOR Red WEIGHT 12.0 CITY London}
            {P# P2 PNAME Bolt COLOR Green WEIGHT 17.0 CITY Paris}
            {P# P3 PNAME Screw COLOR Blue WEIGHT 17.0 CITY Oslo}
            {P# P4 PNAME Screw COLOR Red WEIGHT 14.0 CITY London}
            {P# P5 PNAME Cam COLOR Blue WEIGHT 12.0 CITY Paris}
            {P# P6 PNAME Cog COLOR Red WEIGHT 19.0 CITY London}
        }
    }
    set SP {{S# string P# string QTY int} {
            {S# S1 P# P1 QTY 300}
            {S# S1 P# P2 QTY 200}
            {S# S1 P# P3 QTY 400}
            {S# S1 P# P4 QTY 200}
            {S# S1 P# P5 QTY 100}
            {S# S1 P# P6 QTY 100}
            {S# S2 P# P1 QTY 300}
            {S# S2 P# P2 QTY 400}
            {S# S3 P# P2 QTY 200}
            {S# S4 P# P2 QTY 200}
            {S# S4 P# P4 QTY 300}
            {S# S4 P# P5 QTY 400}
        }
    }
    # Some examples from the manual pages.
    set DOG {{DogName string Breed string} {
            {DogName Fido Breed Poodle}
            {DogName Sam Breed Collie}
            {DogName Spot Breed Terrier}
            {DogName Rover Breed Retriever}
            {DogName Fred Breed Spaniel}
            {DogName Jumper Breed Mutt}
        }
    }
    set OWNER {{OwnerName string Age int City string} {
            {OwnerName Sue Age 24 City Cupertino}
            {OwnerName George Age 35 City Sunnyvale}
            {OwnerName Alice Age 30 City {San Jose}}
            {OwnerName Mike Age 50 City {San Jose}}
            {OwnerName Jim Age 42 City {San Francisco}}
        }
    }
    set OWNERSHIP {{OwnerName string DogName string Acquired string} {
            {OwnerName Sue DogName Fido Acquired 2001}
            {OwnerName Sue DogName Sam Acquired 2000}
            {OwnerName George DogName Fido Acquired 2001}
            {OwnerName George DogName Sam Acquired 2000}
            {OwnerName Alice DogName Spot Acquired 2001}
            {OwnerName Mike DogName Rover Acquired 2002}
            {OwnerName Jim DogName Fred Acquired 2003}
        }
    }

    # Basic tests on the tuple string representation
    test tuple-strrep-1.0 {no attributes} -body {
        tuple degree {{} {}}
    } -result 0

    test tuple-strrep-2.0 {single attributes} -body {
        tuple degree {{Name string} {Name Fred}}
    } -result 1

    test tuple-strrep-3.0 {multiple attributes} -body {
        tuple degree {{Name string Num int Street string}\
            {Name Fred Num 100 Street Main}}
    } -result 3

    test tuple-strrep-4.0 {Tuple valued attribute} -body {
        tuple degree {{Name string Addr {Tuple {Num int Street string}}}\
            {Name Fred Addr {Num 100 Street Main}}}
    } -result 2

    test tuple-strrep-5.0 {other data types} -body {
        tuple degree {{Name string Status int Position double}\
            {Name Fred Status 20 Position 1}}
    } -result 3

    test tuple-strrep-5.1 {other data types - wrong values} -body {
        tuple degree {{Name string Status int Position double}\
            {Name Fred Status 20.0 Position 1}}
    } -result {bad value type for value, "20.0"} -returnCodes error

    test tuple-strrep-5.2 {other data types - wrong values} -body {
        tuple degree {{Name string Status int Position double}\
            {Name Fred Status 20 Position foo}}
    } -result {bad value type for value, "foo"} -returnCodes error

    test tuple-strrep-6.0 {bad format -- extra list element} -body {
        tuple degree {{Name string} {Name Fred} {}}
    } -result {bad value format, "{Name string} {Name Fred} {}"}\
    -returnCodes error

    test tuple-strrep-6.1 {bad format -- missing list element} -body {
        tuple degree {Name}
    } -result {bad value format, "Name"} -returnCodes error

    test tuple-strrep-6.3 {bad format -- bad heading} -body {
        tuple degree {{Name string foo} {Name Fred}}
    } -result {bad list of pairs, "Name string foo"} -returnCodes error

    test tuple-strrep-6.4 {bad format -- duplicate attribute names} -body {
        tuple degree {{Name string Name int} {Name Fred Name George}}
    } -result {duplicate attribute name, "Name"} -returnCodes error

    test tuple-strrep-6.5 {bad format -- insufficient values} -body {
        tuple degree {{Name string Num int Street string}\
            {Name Fred Num 100}}
    } -result {wrong number of attributes specified, "Name Fred Num 100"}\
    -returnCodes error

    test tuple-strrep-6.6 {bad format -- too many values} -body {
        tuple degree {{Name string Num int Street string}\
            {Name Fred Num 100 Street Main Num 200}}
    } -result {wrong number of attributes specified,\
        "Name Fred Num 100 Street Main Num 200"}\
    -returnCodes error

    test tuple-strrep-6.7 {bad format -- value for unknown attribute} -body {
        tuple degree {{Name string Num int Street string}\
            {Name Fred Num 100 City Main}}
    } -result {unknown attribute name, "City"} -returnCodes error

    # Tuple Tests

    # tuple assign subcommand
    test tuple-assign-1.0 {single attribute} -body {
        tuple assign {{Name string} {Name Andrew}}
        expr {$Name eq "Andrew"}
    } -result 1

    test tuple-assign-2.0 {multiple attributes} -body {
        tuple assign {{Name string Age int} {Name Andrew Age 20}}
        expr {$Name eq "Andrew" && $Age == 20}
    } -result 1

    test tuple-assign-3.0 {no attributes} -body {
        tuple assign {{} {}}
    } -result 0

    test tuple-assign-4.0 {assign only some of attributes} -body {
        set n [tuple assign {{Name string Age int} {Name Andrew Age 20}} \
            Name]
        expr {$Name eq "Andrew" && $n == 1}
    } -result 1

    test tuple-assign-5.0 {assign to different named variable} -body {
        set n [tuple assign {{Name string Age int} {Name Andrew Age 20}} \
            {Name nm}]
        expr {$nm eq "Andrew" && $n == 1}
    } -result 1

    test tuple-assign-6.0 {error, no attribute} -body {
        tuple assign {{Name string Age int} {Name Andrew Age 20}} foo
    } -result {unknown attribute name, "foo"} -returnCodes error

    test tuple-assign-6.1 {error, bad attr-var-name list} -body {
        tuple assign {{Name string Age int} {Name Andrew Age 20}} \
            {Name nm foo}
    } -result {bad list of pairs, "Name nm foo"} -returnCodes error

    # tuple attributes subcommand
    test tuple-attributes-1.0 {single attribute} -body {
        tuple attributes [tuple create {Name string} {Name Andrew}]
    } -result {Name}

    test tuple-attributes-2.0 {multiple attributes} -body {
        lsort [tuple attributes\
            [tuple create {Name string Age int} {Name Fred Age 20}]]
    } -result {Age Name}

    test tuple-attributes-3.0 {no attributes} -body {
        tuple attributes [tuple create {} {}]
    } -result {}

    # tuple create subcommand
    test tuple-create-1.0 {single attribute} -body {
        tuple create {Name string} {Name Andrew}
    } -result {{Name string} {Name Andrew}} -match tuple

    test tuple-create-2.0 {multiple attributes} -body {
        set h {Name string Age int}
        tuple create $h {Name Andrew Age 20}
    } -result {{Name string Age int} {Name Andrew Age 20}} -match tuple

    test tuple-create-3.0 {bad format} -body {
        set h {Name string Age int}
        tuple create $h {Name Andrew foo}
    } -result {bad list of pairs, "Name Andrew foo"} -returnCodes error

    test tuple-create-4.0 {unknown attribute} -body {
        set h {Name string Age int}
        tuple create $h {Name Andrew foo 20}
    } -result {unknown attribute name, "foo"} -returnCodes error

    test tuple-create-5.0 {bad value type} -body {
        set h {Name string Age int}
        tuple create $h {Name Andrew Age foo}
    } -result {bad value type for value, "foo"} -returnCodes error

    test tuple-create-6.0 {multiple assignment} -body {
        set h {Name string Age int}
        tuple create $h {Name Andrew Name foo}
    } -result {duplicate attribute name, "Name"} -returnCodes error

    test tuple-create-7.0 {different ordering} -body {
        set h {Name string Age int}
        tuple create $h {Age 20 Name Andrew}
    } -result {{Name string Age int} {Name Andrew Age 20}}

    test tuple-create-8.0 {empty tuple} -body {
        tuple create {} {}
    } -result {{} {}} -match tuple

    # tuple degree subcommand
    test tuple-degree-1.0 {single attribute} -body {
        tuple degree {{Name string} {Name Andrew}}
    } -result 1

    test tuple-degree-2.0 {multiple attributes} -body {
        tuple degree {{Name string Age int} {Age 20 Name Andrew}}
    } -result 2

    test tuple-degree-3.0 {empty tuple} -body {
        tuple degree {{} {}}
    } -result 0

    # tuple eliminate subcommand
    test tuple-eliminate-1.0 {single attribute} -body {
        tuple eliminate {{Name string} {Name Andrew}} Name
    } -result {{} {}}

    test tuple-eliminate-2.0 {multiple attributes} -body {
        tuple eliminate {{Name string Age int Size double}\
            {Name Andrew Age 20 Size 1.0}} Age Size
    } -result {{Name string} {Name Andrew}}

    test tuple-eliminate-3.0 {non-existent attribute} -body {
        tuple eliminate {{Name string Age int Size double}\
            {Name Andrew Age 20 Size 1.0}} foo
    } -result {unknown attribute name, "foo"} -returnCodes error

    # tuple equal subcommand
    test tuple-equal-1.0 {single attribute, match} -body {
        set t1 {{Name string} {Name Andrew}}
        set t2 {{Name string} {Name Andrew}}
        tuple equal $t1 $t2
    } -result 1

    test tuple-equal-2.0 {multiple attributes, match} -body {
        set t1 {{Name string Age int} {Age 20 Name Andrew}}
        set t2 {{Name string Age int} {Name Andrew Age 20}}
        tuple equal $t1 $t2
    } -result 1

    test tuple-equal-3.0 {single attribute, value mismatch} -body {
        set t1 {{Name string} {Name Andrew}}
        set t2 {{Name string} {Name George}}
        tuple equal $t1 $t2
    } -result 0

    test tuple-equal-4.0 {single attribute, attribute name mismatch} -body {
        set t1 {{Name string} {Name Andrew}}
        set t2 {{name string} {name George}}
        tuple equal $t1 $t2
    } -result 0

    test tuple-equal-5.0 {single attribute, type mismatch} -body {
        set t1 {{Name string} {Name 20}}
        set t2 {{Name int} {Name 40}}
        tuple equal $t1 $t2
    } -result 0

    test tuple-equal-6.0 {multiple attributes, value mismatch} -body {
        set t1 {{Name string Age int} {Age 20 Name Andrew}}
        set t2 {{Name string Age int} {Name Andrew Age 30}}
        tuple equal $t1 $t2
    } -result 0

    test tuple-equal-7.0 {multiple attributes, match, out of order} -body {
        set t1 {{Name string Age int Size double}\
            {Name Andrew Age 20 Size 1.0}}
        set t2 {{Size double Name string Age int}\
            {Name Andrew Age 20 Size 1.0}}
        tuple equal $t1 $t2
    } -result 1

    test tuple-equal-8.0 {multiple attributes, match, value variations} -body {
        set t1 {{Name string Age int Size double}\
            {Name Andrew Age 0x20 Size 12.30}}
        set t2 {{Size double Name string Age int}\
            {Name Andrew Age 32 Size 1.23e1}}
        tuple equal $t1 $t2
    } -result 1

    # tuple extend subcommand
    test tuple-extend-1.0 {single attribute} -body {
        set t {{Name string} {Name Andrew}}
        tuple extend $t Age int 20
    } -result {{Name string Age int} {Name Andrew Age 20}} -match tuple

    test tuple-extend-2.0 {multiple attributes} -body {
        set t {{Name string} {Name Andrew}}
        tuple extend $t Age int 20 Size double 1.3
    } -result {{Name string Age int Size double}\
        {Name Andrew Age 20 Size 1.3}} -match tuple

    test tuple-extend-3.0 {duplicate name} -body {
        set t {{Name string} {Name Andrew}}
        tuple extend $t Name int 20
    } -result {duplicate attribute name, "Name"} -returnCodes error

    test tuple-extend-4.0 {bad value} -body {
        set t {{Name string} {Name Andrew}}
        tuple extend $t Age int foo
    } -result {bad value type for value, "foo"} -returnCodes error

    test tuple-extend-5.0 {bad type} -body {
        set t {{Name string} {Name Andrew}}
        tuple extend $t Age foo foo
    } -result {unknown data type, "foo"} -returnCodes error

    test tuple-extend-6.0 {tuple valued extended attribute} -body {
        set t {{Name string} {Name Andrew}}
        tuple extend $t Addr {Tuple {Number int Street string}}\
            {{Number int} {Number 100}}
    } -result {wrong number of attributes specified, "{Number int} {Number 100}"}\
    -returnCodes error

    # tuple extract subcommand
    test tuple-extract-1.0 {single attribute} -body {
        set t {{Name string} {Name Andrew}}
        tuple extract $t Name
    } -result {Andrew}

    test tuple-extract-2.0 {multiple attributes} -body {
        set t {{Name string Age int Size double}\
            {Name Andrew Age 20 Size 1.3}}
        tuple extract $t Age Size
    } -result {20 1.3}

    test tuple-extract-3.0 {unknown attribute} -body {
        set t {{Name string Age int Size double}\
            {Name Andrew Age 20 Size 1.3}}
        tuple extract $t foo
    } -result {unknown attribute name, "foo"} -returnCodes error

    # tuple get subcommand
    test tuple-get-1.0 {single attribute} -body {
        tuple get {{Name string} {Name Andrew}}
    } -result {Name Andrew}

    test tuple-get-2.0 {multiple attributes} -body {
        tuple get {{Name string Age int Size double}\
            {Name Andrew Age 20 Size 1.3}}
    } -result {Name Andrew Age 20 Size 1.3}

    # tuple heading subcommand
    test tuple-heading-1.0 {single attribute} -setup {
        set t [tuple create {Name string} {Name Andrew}]
    } -body {
        tuple heading $t
    } -result {Name string}

    test tuple-heading-2.0 {multiple attributes} -setup {
        set t [tuple create {Name string Age int Size double}\
            {Name Andrew Age 20 Size 3.0}]
    } -body {
        tuple heading $t
    } -result {Name string Age int Size double}

    # tuple project subcommand
    test tuple-project-1.0 {single attribute} -body {
        set t {{Name string} {Name Andrew}}
        tuple project $t Name
    } -result {{Name string} {Name Andrew}} -match tuple

    test tuple-project-2.0 {multiple attributes} -body {
        set t {{Name string Age int Size double}\
            {Name Andrew Age 20 Size 1.3}}
        tuple project $t Name Age
    } -result {{Name string Age int} {Name Andrew Age 20}} -match tuple

    test tuple-project-3.0 {project nothing} -body {
        set t {{Name string Age int} {Name Andrew Age 20}}
        tuple project $t
    } -result {{} {}} -match tuple

    test tuple-project-4.0 {project everything} -body {
        set t {{Name string Age int} {Name Andrew Age 20}}
        tuple project $t Name Age
    } -result {{Name string Age int} {Name Andrew Age 20}} -match tuple

    test tuple-project-5.0 {unknown attribute} -body {
        set t {{Name string Age int} {Name Andrew Age 20}}
        tuple project $t foo
    } -result {unknown attribute name, "foo"} -returnCodes error

    # tuple relation subcommand
    test tuple-relation-1.0 {single attribute} -setup {
        set t [tuple create {Name string} {Name Andrew}]
    } -body {
        tuple relation $t
    } -result {
        {Name string} {
            {Name Andrew}
        }
    } -match relation

    test tuple-relation-1.1 {multiple attributes} -setup {
        set t [tuple create {Name string Age int} {Name Fred Age 29}]
    } -body {
        tuple relation $t
    } -result {
        {Name string Age int} {
            {Name Fred Age 29}
        }
    } -match relation

    # tuple rename subcommand
    test tuple-rename-1.0 {single attribute} -setup {
        set t [tuple create {Name string} {Name Andrew}]
    } -body {
        tuple rename $t Name Age
    } -result {{Age string} {Age Andrew}} -match tuple

    test tuple-rename-2.0 {multiple attributes} -setup {
        set t [tuple create {Name string Age int} {Name Andrew Age 20}]
    } -body {
        tuple rename $t Name foo
    } -result {{foo string Age int} {foo Andrew Age 20}} -match tuple

    test tuple-rename-3.0 {unknown attribute} -setup {
        set t [tuple create {Name string Age int} {Name Andrew Age 20}]
    } -body {
        tuple rename $t foo Name
    } -result {unknown attribute name, "foo"} -returnCodes error

    test tuple-rename-4.0 {unpaired attributes} -setup {
        set t [tuple create {Name string Age int} {Name Andrew Age 20}]
    } -body {
        tuple rename $t foo Name bar
    } -result {bad list of pairs, "for oldname / newname arguments"}\
    -returnCodes error

    test tuple-rename-5.0 {multiple renamings} -setup {
        set t [tuple create {Name string Age int} {Name Andrew Age 20}]
    } -body {
        tuple rename $t Age bar Name foo
    } -result {{foo string bar int} {foo Andrew bar 20}} -match tuple

    test tuple-rename-6.0 {same attribute, multiple renamings} -setup {
        set t [tuple create {Name string Age int} {Name Andrew Age 20}]
    } -body {
        tuple rename $t Name foo foo bar bar baz
    } -result {{baz string Age int} {baz Andrew Age 20}} -match tuple

    test tuple-rename-7.0 {existing attribute} -setup {
        set t [tuple create {Name string Age int} {Name Andrew Age 20}]
    } -body {
        tuple rename $t Name Age
    } -result {duplicate attribute name, "Age"} -returnCodes error

    # tuple unwrap subcommand
    test tuple-unwrap-1.0 {unwrap multiple attributes} -setup {
        set t [tuple create\
            {Name string\
                Address {Tuple {Number int Street string City string}}}\
            {Name Andrew Address {Number 599 Street Blackwood City Sunnyvale}}]
    } -body {
        tuple unwrap $t Address
    } -result {{Name string Number int Street string City string}\
        {Name Andrew Number 599 Street Blackwood City Sunnyvale}}\
    -match tuple

    test tuple-unwrap-2.0 {unwrap single attribute} -setup {
        set t [tuple create\
            {Name string Address {Tuple {Number int}}}\
            {Name Andrew Address {Number 599}}]
    } -body {
        tuple unwrap $t Address
    } -result {{Name string Number int} {Name Andrew Number 599}}\
    -match tuple

    test tuple-unwrap-3.0 {unknown unwrap attribute} -setup {
        set t [tuple create\
            {Name string\
                Address {Tuple {Number int Street string City string}}}\
            {Name Andrew Address {Number 599 Street Blackwood City Sunnyvale}}]
    } -body {
        tuple unwrap $t foo
    } -result {unknown attribute name, "foo"} -returnCodes error

    test tuple-unwrap-4.0 {non-tuple unwrap attribute} -setup {
        set t [tuple create\
            {Name string\
                Address {Tuple {Number int Street string City string}}}\
            {Name Andrew Address {Number 599 Street Blackwood City Sunnyvale}}]
    } -body {
        tuple unwrap $t Name
    } -result {attribute must be of a Tuple type, "Name"} -returnCodes error

    # tuple update subcommand
    test tuple-update-1.0 {single attribute} -setup {
        set t [tuple create {Name string Age int Size double}\
            {Name Andrew Age 20 Size 3.0}]
    } -body {
        tuple update $t Age 40
    } -result {{Name string Age int Size double}\
            {Name Andrew Age 40 Size 3.0}} -match tuple

    test tuple-update-2.0 {multiple attributes} -setup {
        set t [tuple create {Name string Age int Size double}\
            {Name Andrew Age 20 Size 3.0}]
    } -body {
        tuple update $t Age 40 Size 33.0
    } -result {{Name string Age int Size double}\
            {Name Andrew Age 40 Size 33.0}} -match tuple

    test tuple-update-3.0 {unknown attribute} -setup {
        set t [tuple create {Name string Age int Size double}\
            {Name Andrew Age 20 Size 3.0}]
    } -body {
        tuple update $t foo 40
    } -result {unknown attribute name, "foo"} -returnCodes error

    test tuple-update-4.0 {bad type} -setup {
        set t [tuple create {Name string Age int Size double}\
            {Name Andrew Age 20 Size 3.0}]
    } -body {
        tuple update $t Age foo
    } -result {bad value type for value, "foo"} -returnCodes error

    test tuple-update-4.1 {bad tuple type} -setup {
        set t [tuple create {Name string Stats {Tuple {Age int Size double}}}\
            {Name Andrew Stats {Age 20 Size 3.0}}]
    } -body {
        tuple update $t Stats {Age 20 Date 5/5/2009}
    } -result {bad value type for value, "Age 20 Date 5/5/2009"}\
    -returnCodes error

    test tuple-update-4.2 {bad relatio type} -setup {
        set t [tuple create {Name string Addresses {Relation {Number int Street string}}}\
            {Name Andrew Addresses {{Number 20 Street Main} {Number 30 Street Elm}}}]
    } -body {
        tuple update $t Addresses {{Number 20 Date 5/5/2009}}
    } -result {bad value type for value, "{Number 20 Date 5/5/2009}"}\
    -returnCodes error

    # tuple wrap subcommand
    test tuple-wrap-1.0 {wrap 1 attribute} -setup {
        set t [tuple create {Name string Age int Size double}\
            {Age 20 Name Andrew Size 3.0}]
    } -body {
        tuple wrap $t Props Age
    } -result {{Name string Size double Props {Tuple {Age int}}}\
        {Name Andrew Size 3.0 Props {Age 20}}} -match tuple

    test tuple-wrap-2.0 {wrap multiple attributes} -setup {
        set t [tuple create {Name string Age int Size double}\
            {Age 20 Name Andrew Size 3.0}]
    } -body {
        tuple wrap $t Props Age Size
    } -result {{Name string Props {Tuple {Age int Size double}}}\
        {Name Andrew Props {Age 20 Size 3.0}}} -match tuple

    test tuple-wrap-3.0 {wrap all attributes} -setup {
        set t [tuple create {Name string Age int Size double}\
            {Age 20 Name Andrew Size 3.0}]
    } -body {
        tuple wrap $t Props Name Age Size
    } -result {{Props {Tuple {Name string Age int Size double}}}\
        {Props {Name Andrew Age 20 Size 3.0}}} -match tuple

    test tuple-wrap-4.0 {non-existent attribute to wrap} -setup {
        set t [tuple create {Name string Age int Size double}\
            {Age 20 Name Andrew Size 3.0}]
    } -body {
        tuple wrap $t Props foo
    } -result {unknown attribute name, "foo"} -returnCodes error

    test tuple-wrap-5.0 {wrap same attribute multiple times} -setup {
        set t [tuple create {Name string Age int Size double}\
            {Age 20 Name Andrew Size 3.0}]
    } -body {
        tuple wrap $t Props Name Age Name
    } -result {duplicate attribute name, "Name"} -returnCodes error

    test tuple-wrap-6.0 {wrap attribute is a duplicate} -setup {
        set t [tuple create {Name string Age int Size double}\
            {Age 20 Name Andrew Size 3.0}]
    } -body {
        tuple wrap $t Size Name Age
    } -result {duplicate attribute name, "Size"} -returnCodes error

    test tuple-wrap-7.0 {wrap no attributes at all} -setup {
        set t [tuple create {Name string Age int Size double}\
            {Age 20 Name Andrew Size 3.0}]
    } -body {
        tuple wrap $t Props
    } -result {{Name string Age int Size double Props {Tuple {}}}\
        {Age 20 Name Andrew Size 3.0 Props {}}} -match tuple

    test tuple-wrap-8.0 {
        tuple valued attribute is same name as wrapped attribute
    } -setup {
        set t [tuple create {Name string Age int Size double}\
            {Age 20 Name Andrew Size 3.0}]
    } -body {
        tuple wrap $t Age Age Size
    } -result {
        {Name string Age {Tuple {Age int Size double}}}
            {Age {Size 3.0 Age 20} Name Andrew}
    } -match tuple

    # tuple shimmering tests
    test tuple-shimmer-1.0 {
        tuple valued attribute regeneration
    } -setup {
        set t [tuple create {Name string Addr {Tuple {Num int Street string}}}\
            {Name Fred Addr {Num 100 Street Main}}]
    } -body {
        set t
    } -result {{Name string Addr {Tuple {Num int Street string}}} {Name Fred Addr {Num 100 Street Main}}}

    # relation shimmering tests
    test relation-shimmer-1.0 {dum relation} -body {
        relation cardinality $DUM
        string length $DUM
        set DUM
    } -result {{} {}} -match relation

    test relation-shimmer-2.0 {dee relation} -body {
        relation cardinality $DEE
        string length $DEE
        set DEE
    } -result {{} {{}}} -match relation

    test relation-shimmer-3.0 {degree 1, cardinality 0} -body {
        set r {{a1 string} {}}
        relation cardinality $r
        string length $r
        set r
    } -result {{a1 string} {}} -match relation

    test relation-shimmer-3.1 {degree 1, cardinality 1} -body {
        set r {{a1 string} {{a1 foo}}}
        relation cardinality $r
        string length $r
        set r
    } -result {{a1 string} {{a1 foo}}} -match relation

    test relation-shimmer-3.2 {degree 1, cardinality 2} -body {
        set r {{a1 string} {{a1 foo} {a1 bar}}}
        relation cardinality $r
        string length $r
        set r
    } -result {{a1 string} {{a1 foo} {a1 bar}}} -match relation

    test relation-shimmer-4.0 {tuple attr, degree 1, cardinality 0} -body {
        set r {{a1 {Tuple {t1 string t2 string}}} {}}
        relation cardinality $r
        string length $r
        set r
    } -result {{a1 {Tuple {t1 string t2 string}}} {}}\
    -match relation

    test relation-shimmer-4.1 {tuple attr, degree 1, cardinality 1} -body {
        set r {{a1 {Tuple {t1 string t2 string}}} {
                {a1 {t1 foo t2 bar}}
            }
        }
        relation cardinality $r
        string length $r
        set r
    } -result {{a1 {Tuple {t1 string t2 string}}} {
            {a1 {t1 foo t2 bar}}
        }
    } -match relation

    test relation-shimmer-4.2 {tuple attr, degree 1, cardinality 2} -body {
        set r {{a1 {Tuple {t1 string t2 string}}} {
                {a1 {t1 foo t2 bar}}
                {a1 {t1 foo2 t2 bar2}}
            }
        }
        relation cardinality $r
        string length $r
        set r
    } -result {{a1 {Tuple {t1 string t2 string}}} {
            {a1 {t1 foo t2 bar}}
            {a1 {t1 foo2 t2 bar2}}
        }
    } -match relation

    test relation-shimmer-5.0 {relation attr, degree 1, cardinality 0} -body {
        set r {{a1 {Relation {t1 string t2 string}}} {}}
        relation cardinality $r
        string length $r
        set r
    } -result {{a1 {Relation {t1 string t2 string}}} {}}\
    -match relation

    test relation-shimmer-5.1 {relation attr, degree 1, cardinality 1} -body {
        set r {{a1 {Relation {t1 string t2 string}}} {
                {a1 {{t1 foo t2 bar}}}
            }
        }
        relation cardinality $r
        string length $r
        set r
    } -result {{a1 {Relation {t1 string t2 string}}} {
            {a1 {{t1 foo t2 bar}}}
        }
    } -match relation

    test relation-shimmer-5.2 {relation attr, degree 1, cardinality 1} -body {
        set r {{a1 {Relation {t1 string t2 string}}} {
                {a1 {{t1 foo t2 bar} {t1 foo2 t2 bar2}}}
            }
        }
        relation cardinality $r
        string length $r
        set r
    } -result {{a1 {Relation {t1 string t2 string}}} {
            {a1 {{t1 foo t2 bar} {t1 foo2 t2 bar2}}}
        }
    } -match relation

    test relation-shimmer-6.0 {multiple identifiers} -body {
        set r {{a1 string a2 string a3 string} {
                {a1 a a2 b a3 c}
                {a1 d a2 e a3 f}
            }
        }
        relation cardinality $r
        string length $r
        set r
    } -result {{a1 string a2 string a3 string} {
            {a1 a a2 b a3 c}
            {a1 d a2 e a3 f}
        }
    } -match relation

    test relation-shimmer-7.1 {error in body} -body {
        set r {{a1 string a2 string a3 string} {
                {a1 a a2 b a3 c}
                {a1 d a2 e a4 f}
            }
        }
        relation cardinality $r
    } -result {unknown attribute name, "a4"} -returnCodes error

    # relation array subcommand
    test relation-array-1.0 {supplier number / city map} -constraints {
        haveDict
    } -body {
        relation array $S smap S# CITY
        array get smap
    } -cleanup {
        unset smap
    } -result {
            S1 London
            S2 Paris
            S3 Paris
            S4 London
            S5 Athens
    } -match dict

    # relation assign subcommand
    test relation-assign-1.0 {assign all attributes} -body {
        set s [relation restrictwith $S {${S#} eq "S1"}]
        relation assign $s
        expr {${S#} eq "S1" && $SNAME eq "Smith" && $STATUS == 20 &&\
            $CITY eq "London"}
    } -result 1

    test relation-assign-2.0 {assign some attributes} -body {
        set s [relation restrictwith $S {${S#} eq "S1"}]
        relation assign $s SNAME
        expr {$SNAME eq "Smith"}
    } -result 1

    test relation-assign-3.0 {assign attributes to different var name} -body {
        set s [relation restrictwith $S {${S#} eq "S1"}]
        relation assign $s {SNAME name}
        expr {$name eq "Smith"}
    } -result 1

    # relation attributes subcommand
    test relation-attributes-1.0 {DOG relation} -body {
        lsort [relation attributes $P]
    } -result {CITY COLOR P# PNAME WEIGHT}

    # relation body subcommand
    test relation-body-1.0 {DOG relation} -body {
        relation body $DOG
    } -result {{DogName Fido Breed Poodle}\
            {DogName Sam Breed Collie}\
            {DogName Spot Breed Terrier}\
            {DogName Rover Breed Retriever}\
            {DogName Fred Breed Spaniel}\
            {DogName Jumper Breed Mutt}}

    # relation cardinality subcommand
    test relation-cardinality-1.0 {dum relation} -body {
        relation cardinality $DUM
    } -result 0

    test relation-cardinality-2.0 {dee relation} -body {
        relation cardinality $DEE
    } -result 1

    test relation-cardinality-3.0 {relation with 1 attribute} -body {
        relation cardinality {{a1 string} {}}
    } -result 0

    test relation-cardinality-3.0 {relation with 4 attributes} -body {
        relation cardinality $S
    } -result 5

    # relation compose subcommand
    test relation-compose-1.0 {
        single common attribute
    } -body {
        set r1 {
            {
                XId string A2 int A3 string
            } {
                {A2 20 XId George A3 {San Jose}}
                {A3 Saratoga A2 10 XId Fred}
            }
        }
        set r2 {
            {
                XId string A4 int
            } {
                {A4 30 XId George}
                {XId Fred A4 10}
            }
        }
        relation compose $r1 $r2
    } -result {
        {
            A2 int A3 string A4 int
        } {
            {A2 20 A3 {San Jose} A4 30}
            {A2 10 A3 Saratoga A4 10}
        }
    } -match relation

    test relation-compose-2.0 {
        composing across self
    } -body {
        set r1 {
            {
                Id int Next int
            } {
                {Id 1 Next 2}
                {Id 2 Next 3}
                {Id 3 Next 1}
            }
        }
        relation compose $r1 $r1 -using {Id Next}
    } -result {
        {
            Id int Next int
        } {
            {Id 1 Next 3}
            {Id 2 Next 1}
            {Id 3 Next 2}
        }
    } -match relation

    test relation-compose-2.3 {
        composing across self -- twice get back to original
    } -body {
        set r1 {
            {
                Id int Next int
            } {
                {Id 1 Next 2}
                {Id 2 Next 3}
                {Id 3 Next 1}
            }
        }
        set r2 [relation compose $r1 $r1 -using {Id Next}]
        relation compose $r2 $r2 -using {Id Next}
    } -result {
        {
            Id int Next int
        } {
            {Id 1 Next 2}
            {Id 2 Next 3}
            {Id 3 Next 1}
        }
    } -match relation

    test relation-compose-2.1 {
        composing across self -- common attr
    } -body {
        set r1 {
            {
                Id int Next int
            } {
                {Id 1 Next 2}
                {Id 2 Next 3}
                {Id 3 Next 1}
            }
        }
        set r2 [relation rename $r1 Next NextNext]
        relation compose $r1 $r2
    } -result {
        {
            Next int NextNext int
        } {
            {Next 2 NextNext 2}
            {Next 3 NextNext 3}
            {Next 1 NextNext 1}
        }
    } -match relation

    test relation-compose-2.2 {
        multi-attribute identifiers
    } -body {
        set r1 {
            {
                X int Y int Z int
            } {
                {X 1 Y 1 Z 2}
                {X 3 Y 4 Z 7}
                {X 4 Y 4 Z 8}
            }
        }
        set r2 [relation eliminate $r1 Z]
        relation compose $r1 $r2
    } -result {
        {
            Z int
        } {
            {Z 2}
            {Z 7}
            {Z 8}
        }
    } -match relation

    test relation-compose-3.0 {
        composing across self yielding DEE
    } -body {
        set r1 {
            {
                Id int
            } {
                {Id 1}
                {Id 2}
                {Id 3}
            }
        }
        relation compose $r1 $r1
    } -result {{} {{}}} -match relation

    test relation-compose-3.1 {
        composing across self yielding DUM
    } -body {
        set r1 {
            {
                Id int
            } {
            }
        }
        relation compose $r1 $r1
    } -result {{} {}
    } -match relation

    test relation-compose-3.2 {
        compose degenerates to join
    } -body {
        set r1 {
            {
                Id int
            } {
                {Id 1}
                {Id 2}
                {Id 3}
            }
        }
        set r2 {
            {
                XId int
            } {
                {XId 1}
                {XId 2}
                {XId 3}
            }
        }
        relation compose $r1 $r2
    } -result {
        {
            Id int XId int
        } {
            {Id 1 XId 1}
            {Id 1 XId 2}
            {Id 1 XId 3}
            {Id 2 XId 1}
            {Id 2 XId 2}
            {Id 2 XId 3}
            {Id 3 XId 1}
            {Id 3 XId 2}
            {Id 3 XId 3}
        }
    } -match relation

    # relation create subcommand
    test relation-create-1.0 {one tuple} -body {
        relation create {A1 string} {A1 a1}
    } -result {{A1 string} {{A1 a1}}} -match relation

    test relation-create-2.0 {zero tuple} -body {
        relation create {A1 string}
    } -result {{A1 string} {}} -match relation

    # Test fix for Bug # 1893238
    # Empty relation valued and tuple valued attributes.
    test relation-create-3.0 {
        empty relation valued attribute
    } -body {
        relation create {A1 string A2 {Relation {B1 string}}}\
            {A1 foo A2 {}}
    } -result {
        {
            A1 string
            A2 {Relation {B1 string}}
        } {
            {A1 foo A2 {}}
        }
    } -match relation

    test relation-create-3.1 {
        tuple valued attribute
    } -body {
        relation create {A1 string A2 {Tuple {B1 string}}}\
            {A1 foo A2 {B1 bar}}
    } -result {
        {
            A1 string
            A2 {Tuple {B1 string}}
        } {
            {A1 foo A2 {B1 bar}}
        }
    } -match relation

    # relation table subcommand
    test relation-table-1.0 {one attribute - one tuple} -body {
        relation table {A1 string} a1
    } -result {{A1 string} {{A1 a1}}} -match relation

    test relation-table-2.0 {one attribute - multiple tuples} -body {
        relation table {A1 string} a1 a2 a3
    } -result {
        {A1 string} {
            {A1 a1}
            {A1 a2}
            {A1 a3}
        }
    } -match relation

    test relation-table-3.0 {multiple attributes and tuples} -body {
        relation table\
            {A1 string  B2 int  C3 double}\
            {a1         1       1.0}\
            {a2         2       2.0}\
            {a3         3       3}
    } -result {
        {A1 string B2 int C3 double} {
            {A1 a1 B2 1 C3 1.0}
            {A1 a2 B2 2 C3 2.0}
            {A1 a3 B2 3 C3 3.0}
        }
    } -match relation

    test relation-table-4.0 {tuple valued attributes} -body {
        relation table\
            {A1 string  B2 {Tuple {C3 int}}}\
            {a1         {C3 1}}\
            {a2         {C3 2}}\
            {a3         {C3 3}}
    } -result {
        {A1 string B2 {Tuple {C3 int}}} {
            {A1 a1 B2 {C3 1}}
            {A1 a2 B2 {C3 2}}
            {A1 a3 B2 {C3 3}}
        }
    } -match relation

    # relation degree subcommand
    test relation-degree-1.0 {dum relation} -body {
        relation degree $DUM
    } -result 0

    test relation-degree-2.0 {single attribute} -body {
        relation degree {{Name string} {}}
    } -result 1

    test relation-degree-3.0 {multiple attributes} -body {
        relation degree $S
    } -result 4

    # relation eliminate subcommand
    test relation-eliminate-1.0 {single attribute} -body {
        set r1 {{Name string Number int Street string IsMale string}
            {{Name Andrew Number 599 Street Blackwood IsMale true}
            {Name Jane Street Main Number 300 IsMale false}
            {Name Fred Street Maple Number 599 IsMale true}}}
        relation eliminate $r1 Name
    } -result {{Number int Street string IsMale string} {
        {Number 599 Street Blackwood IsMale true}
        {Number 300 Street Main IsMale false}
        {Number 599 Street Maple IsMale true}}
    } -match relation

    test relation-eliminate-2.0 {multiple attributes} -body {
        set r1 {{Name string Number int Street string IsMale string}
            {{Name Andrew Number 599 Street Blackwood IsMale true}
            {Name Jane Street Main Number 300 IsMale false}
            {Name Fred Street Maple Number 599 IsMale true}}}
        relation eliminate $r1 Number IsMale
    } -result {{Name string Street string} {
        {Name Andrew Street Blackwood}
        {Name Jane Street Main}
        {Name Fred Street Maple}}
    } -match relation

    test relation-eliminate-2.1 {multiple attributes} -body {
        set r1 {{Name string Number int Street string IsMale string}
            {{Name Andrew Number 599 Street Blackwood IsMale true}
            {Name Jane Street Main Number 300 IsMale false}
            {Name Fred Street Maple Number 599 IsMale true}}}
        relation eliminate $r1 Name Street
    } -result {{Number int IsMale string} {
        {Number 599 IsMale true}
        {Number 300 IsMale false}}
    } -match relation

    test relation-eliminate-3.0 {nullary eliminate, non-empty relation} -body {
        set r1 {{Name string Number int Street string IsMale string}
            {{Name Andrew Number 599 Street Blackwood IsMale true}
            {Name Jane Street Main Number 300 IsMale false}
            {Name Fred Street Maple Number 599 IsMale true}}}
        relation eliminate $r1
    } -result {{Name string Number int Street string IsMale string} {
        {Name Andrew Number 599 Street Blackwood IsMale true}
        {Name Jane Number 300 Street Main IsMale false}
        {Name Fred Number 599 Street Maple IsMale true}}
    } -match relation

    test relation-eliminate-4.0 {nullary eliminate, empty relation} -body {
        set r1 {
            {Name string Number int Street string IsMale string}
            {}
        }
        relation eliminate $r1
    } -result {
        {Name string Number int Street string IsMale string}
        {}
    } -match relation

    # relation dict subcommand
    test relation-dict-1.0 {supplier number / city map} -constraints {
        tcl8.5
    } -body {
        relation dict $S S# CITY
    } -result {
            S1 London
            S2 Paris
            S3 Paris
            S4 London
            S5 Athens
    } -match dict

    # relation divide subcommand
    test relation-divide-1.0 {suppliers who supply P1} -setup {
        set dend [relation project $S S#]
        set med [relation project $SP S# P#]
        set dsor [relation project\
            [relation restrictwith $P {${P#} eq "P1"}] P#]
    } -body {
        relation divide $dend $dsor $med
    } -result {{S# string} {
            {S# S1}
            {S# S2}
        }
    } -match relation

    test relation-divide-2.0 {suppliers who supply P2 and P4} -setup {
        set dend [relation project $S S#]
        set med [relation project $SP P# S#]
        set dsor [relation project\
            [relation restrictwith $P {${P#} eq "P2" || ${P#} eq "P4"}] P#]
    } -body {
        relation divide $dend $dsor $med
    } -result {{S# string} {
            {S# S1}
            {S# S4}
        }
    } -match relation

    test relation-divide-3.0 {suppliers who supply all parts} -setup {
        set dend [relation project $S S#]
        set med [relation project $SP P# S#]
        set dsor [relation project $P P#]
    } -body {
        relation divide $dend $dsor $med
    } -result {{S# string} {
            {S# S1}
        }
    } -match relation

    test relation-divide-4.0 {not disjoint dividend and divsor} -setup {
        set dend [relation project $S S#]
        set dsor $S
        set med [relation project $SP P# S#]
    } -body {
        relation divide $dend $dsor $med
    } -result {divisor heading must be disjoint from the dividend heading, "while computing quotient"}\
    -returnCodes error

    test relation-divide-5.0 {mediator not union dividend and divsor} -setup {
        set dend [relation project $S S#]
        set dsor [relation project $P P#]
        set med [relation project $SP S#]
    } -body {
        relation divide $dend $dsor $med
    } -result {mediator heading must be a union of the dividend and divisor headings, "while computing quotient"}\
    -returnCodes error

    test relation-divide-5.1 {
        mediator larger than union dividend and divsor
    } -setup {
        set dend [relation project $S S#]
        set dsor [relation project $P P#]
        set med [relation extend $SP sp Other int {"1"}]
    } -body {
        relation divide $dend $dsor $med
    } -result {mediator heading must be a union of the dividend and divisor headings, "while computing quotient"}\
    -returnCodes error

    # relation emptyof subcommand
    test relation-emptyof-1.0 {multiple attributes} -body {
        relation emptyof $S
    } -result {{S# string SNAME string STATUS int CITY string} {}
    } -match relation

    # relation extend subcommand
    test relation-extend-1.0 {multiple body tuples} -body {
        set r1 {{Name string Age int}
            {{Name Andrew Age 20}
            {Name George Age 20}
            {Name Fred Age 20}}}
        relation extend $r1 t AgeInMonths int {[tuple extract $t Age] * 12}
    } -result {
        {Name string Age int AgeInMonths int}
        {
            {Name Andrew Age 20 AgeInMonths 240}
            {Name George Age 20 AgeInMonths 240}
            {Name Fred Age 20 AgeInMonths 240}
        }
    } -match relation

    test relation-extend-2.0 {bad expression} -body {
        set r1 {{Name string Age int}
            {{Name Andrew Age 20}
            {Name George Age 20}
            {Name Fred Age 20}}}
        relation extend $r1 t AgeInMonths int {[tuple extract $t foo] * 12}
    } -result {unknown attribute name, "foo"} -returnCodes error

    # Test to confirm correcting problem when relation valued attribute values
    # on an extend operation do not match the header for the extended
    # attribute.
    test relation-extend-3.0 {relation valued attribute} -body {
        set r1 {{Name string Age int}
            {{Name Andrew Age 20}
            {Name George Age 20}
            {Name Fred Age 20}}}
        relation extend $r1 t AgeInMonths {Relation {A1 int A2 string}} {
            {{A1 int} {{A1 3} {A1 4}}}
        }
    } -result {wrong number of attributes specified, "A1 int"}\
    -returnCodes error

    test relation-extend-3.1 {relation valued attribute} -body {
        set r1 {{Name string Age int}
            {{Name Andrew Age 20}
            {Name George Age 20}
            {Name Fred Age 20}}}
        relation extend $r1 t AgeInMonths {Relation {A1 int A2 string}} {
            [relation create {A1 int} {A1 3} {A1 4}]
        }
    } -result {headings not equal, "{A1 int} {{A1 3} {A1 4}}"}\
    -returnCodes error

    # relation extract subcommand
    test relation-extract-1.0 {single attribute} -body {
        set t {
            {Name string}
            {
                {Name Andrew}
            }
        }
        relation extract $t Name
    } -result {Andrew}

    test relation-extract-2.0 {multiple attributes} -body {
        set t {
            {Name string Age int Size double}
            {
                {Name Andrew Age 20 Size 1.3}
            }
        }
        relation extract $t Age Size
    } -result {20 1.3}

    test relation-extract-3.0 {unknown attribute} -body {
        set t {
            {Name string Age int Size double}
            {
                {Name Andrew Age 20 Size 1.3}
            }
        }
        relation extract $t foo
    } -result {unknown attribute name, "foo"} -returnCodes error

    test relation-extract-4.0 {non-singular relation} -body {
        set t {
            {Name string Age int Size double}
            {
                {Name Andrew Age 20 Size 1.3}
                {Name Bob Age 30 Size 4.3}
            }
        }
        relation extract $t Size
    } -result {relation must have cardinality of one, "
            {Name string Age int Size double}
            {
                {Name Andrew Age 20 Size 1.3}
                {Name Bob Age 30 Size 4.3}
            }
        "} -returnCodes error

    # relation foreach subcommand
    test relation-foreach-1.0 {simple visit of suppliers} -body {
        set nameList [list]
        relation foreach sup $S {
            lappend nameList [relation extract $sup SNAME]
        }
        lsort $nameList
    } -result {Adams Blake Clark Jones Smith}

    test relation-foreach-2.0 {visit of suppliers ascending order} -body {
        set nameList [list]
        relation foreach sup $S -ascending SNAME {
            lappend nameList [relation extract $sup SNAME]
        }
        set nameList
    } -result {Adams Blake Clark Jones Smith}

    test relation-foreach-3.0 {visit of suppliers descending order} -body {
        set nameList [list]
        relation foreach sup $S -descending SNAME {
            lappend nameList [relation extract $sup SNAME]
        }
        set nameList
    } -result {Smith Jones Clark Blake Adams}

    test relation-foreach-3.1 {visit parts order by weight} -body {
        set nameList [list]
        relation foreach part $P -descending WEIGHT {
            lappend weightList [relation extract $part WEIGHT]
        }
        set weightList
    } -result {19.0 17.0 17.0 14.0 12.0 12.0}

    test relation-foreach-4.0 {visit of suppliers ordered by multiple} -body {
        set nameList [list]
        relation foreach sup $S -ascending {CITY SNAME} {
            lappend nameList [relation extract $sup SNAME]
        }
        set nameList
    } -result {Adams Clark Smith Blake Jones}

    test relation-foreach-5.0 {unset tuple variable} -body {
        set nameList [list]
        relation foreach sup $S {
            unset sup
        }
        set S
    } -result {
        {S# string SNAME string STATUS int CITY string}
        {
            {S# S1 SNAME Smith STATUS 20 CITY London}
            {S# S2 SNAME Jones STATUS 10 CITY Paris}
            {S# S3 SNAME Blake STATUS 30 CITY Paris}
            {S# S4 SNAME Clark STATUS 20 CITY London}
            {S# S5 SNAME Adams STATUS 30 CITY Athens}
        }
    } -match relation

    test relation-foreach-5.1 {update tuple variable} -body {
        set nameList [list]
        relation foreach sup $S {
            set t [relation tuple $sup]
            tuple update $t CITY Sunnyvale
        }
        set S
    } -result {
        {S# string SNAME string STATUS int CITY string}
        {
            {S# S1 SNAME Smith STATUS 20 CITY London}
            {S# S2 SNAME Jones STATUS 10 CITY Paris}
            {S# S3 SNAME Blake STATUS 30 CITY Paris}
            {S# S4 SNAME Clark STATUS 20 CITY London}
            {S# S5 SNAME Adams STATUS 30 CITY Athens}
        }
    } -match relation

    # relation fromdict subcommand
    test relation-fromdict-1.0 {
        empty dict
    } -constraints {
        tcl8.5
    } -body {
        relation fromdict {} A int B string
    } -result {
        {A int B string} {}
    } -match relation

    test relation-fromdict-2.0 {
        single key / value pair
    } -constraints {
        tcl8.5
    } -body {
        relation fromdict {27 fred} A int B string
    } -result {
        {A int B string} {{A 27 B fred}}
    } -match relation

    test relation-fromdict-3.0 {
        many element dictionary
    } -constraints {
        tcl8.5
    } -body {
        set d [dict create 27 fred 42 alice 38 george 15 sue]
        relation fromdict $d A int B string
    } -result {
        {A int B string} {
            {A 27 B fred}
            {A 42 B alice}
            {A 38 B george}
            {A 15 B sue}
        }
    } -match relation

    test relation-fromdict-4.0 {
        duplicate dict key
    } -constraints {
        tcl8.5
    } -body {
        set d [dict create 27 fred 42 alice 38 george 27 sue]
        relation fromdict $d A int B string
    } -result {
        {A int B string} {
            {A 27 B sue}
            {A 42 B alice}
            {A 38 B george}
        }
    } -match relation

    test relation-fromdict-5.0 {
        bad element data type
    } -constraints {
        tcl8.5
    } -body {
        set d [dict create 27 fred 42 alice 38 george mary sue]
        relation fromdict $d A int B string
    } -result {bad value type for value, "mary"} -returnCodes error

    test relation-fromdict-6.0 {
        bad dictionary
    } -constraints {
        tcl8.5
    } -body {
        set d {27 fred 42 alice 38 george 13}
        relation fromdict $d A int B string
    } -result {missing value to go with key} -returnCodes error

    # relation fromlist subcommand
    test relation-fromlist-1.0 {
        empty list
    } -body {
        relation fromlist {} A int
    } -result {
        {A int} {}
    } -match relation

    test relation-fromlist-2.0 {
        singleton list
    } -body {
        relation fromlist {27} A int
    } -result {
        {A int} {{A 27}}
    } -match relation

    test relation-fromlist-3.0 {
        many element list
    } -body {
        relation fromlist {27 42 38 15} A int
    } -result {
        {A int} {{A 27} {A 42} {A 38} {A 15}}
    } -match relation

    test relation-fromlist-4.0 {
        duplicate list element
    } -body {
        relation fromlist {15 42 38 15} A int
    } -result {
        {A int} {{A 15} {A 42} {A 38}}
    } -match relation

    test relation-fromlist-5.0 {
        bad element data type
    } -body {
        relation fromlist {15 42 fred} A int
    } -result {bad value type for value, "fred"} -returnCodes error

    # relation group subcommand
    test relation-group-1.0 {group two attributes} -body {
        relation group $SP PQ P# QTY
    } -result {
        {S# string PQ {Relation {P# string QTY int}}}
        {
            {S# S1 PQ {
                {P# P1 QTY 300}
                {P# P2 QTY 200}
                {P# P3 QTY 400}
                {P# P4 QTY 200}
                {P# P5 QTY 100}
                {P# P6 QTY 100}}
            }
            {S# S2 PQ {
                {P# P1 QTY 300}
                {P# P2 QTY 400}}
            }
            {S# S3 PQ {
                {P# P2 QTY 200}}
            }
            {S# S4 PQ {
                {P# P2 QTY 200}
                {P# P4 QTY 300}
                {P# P5 QTY 400}}
            }
        }
    } -match relation

    test relation-group-2.0 {group two attributes} -body {
        relation group $SP SQ S# QTY
    } -result {
        {P# string SQ {Relation {S# string QTY int}}}
        {
            {P# P1 SQ {{S# S1 QTY 300} {S# S2 QTY 300}}}
            {P# P2 SQ {
                {S# S1 QTY 200}
                {S# S2 QTY 400}
                {S# S3 QTY 200}
                {S# S4 QTY 200}}
            }
            {P# P3 SQ {{S# S1 QTY 400}}}
            {P# P4 SQ {{S# S1 QTY 200} {S# S4 QTY 300}}}
            {P# P5 SQ {{S# S1 QTY 100} {S# S4 QTY 400}}}
            {P# P6 SQ {{S# S1 QTY 100}}}
        }
    } -match relation

    test relation-group-3.0 {group; no ids in grouped attribute} -setup {
        set r1 {
            {Name string Number int Street string}
            {
                {Name Andrew Number 599 Street Blackwood}
                {Name Jane Street Main Number 300}
                {Name Alice Street Main Number 300}
                {Name Fred Street Maple Number 599}
            }
        }
    } -body {
        relation group $r1 Addr Number Street
    } -result {
        {Name string Addr {Relation {Number int Street string}}} {
            {Name Andrew Addr {{Number 599 Street Blackwood}}}
            {Name Jane Addr {{Number 300 Street Main}}}
            {Name Alice Addr {{Number 300 Street Main}}}
            {Name Fred Addr {{Number 599 Street Maple}}}
        }
    } -match relation

    test relation-group-4.0 {group; all ids in grouped attribute} -setup {
        set r1 {
            {Name string Number int Street string}
            {
                {Name Andrew Number 599 Street Blackwood}
                {Name Jane Street Main Number 300}
                {Name Alice Street Main Number 300}
                {Name Fred Street Maple Number 599}
            }
        }
    } -body {
        relation group $r1 Addr Number Street
    } -result {
        {Name string Addr {Relation {Number int Street string}}} {
            {Name Andrew Addr {{Number 599 Street Blackwood}}}
            {Name Jane Addr {{Number 300 Street Main}}}
            {Name Alice Addr {{Number 300 Street Main}}}
            {Name Fred Addr {{Number 599 Street Maple}}}
        }
    } -match relation

    test relation-group-5.0 {group, unreversable} -setup {
        set three {
            {A int X string}
            {
                {A 1 X a}
                {A 1 X b}
                {A 1 X c}
            }
        }
    } -body {
        relation group $three RVX X
    } -result {
        {A int RVX {Relation {X string}}} {
            {A 1 RVX {{X a} {X b} {X c}}}
        }
    } -match relation

    test relation-group-6.0 {grouping across identifiers} -setup {
        set e {
            {DId int CId int EName string ENum int} {
                {DId 1 CId 1 EName a ENum 1}
                {DId 1 CId 1 EName b ENum 2}
                {DId 1 CId 1 EName c ENum 3}
                {DId 1 CId 2 EName a ENum 1}
                {DId 1 CId 2 EName b ENum 2}
                {DId 1 CId 2 EName c ENum 3}
            }
        }
    } -body {
        relation group $e ByC EName ENum
    } -result {
        {DId int CId int ByC {Relation {EName string ENum int}}} {
            {DId 1 CId 1 ByC {
                {EName a ENum 1}
                {EName b ENum 2}
                {EName c ENum 3}
            }}
            {DId 1 CId 2 ByC {
                {EName a ENum 1}
                {EName b ENum 2}
                {EName c ENum 3}
            }}
        }
    } -match relation

    test relation-group-7.0 {grouped attributes in multiple identifers} -setup {
        set e {
            {
                DomainId int
                ClassId int
                ElemId int
                ElemName string
                HierId int
                SubName string
                SubCode int
            } {
                {DomainId 1 ClassId 1 ElemId 17 ElemName R11 HierId 0
                    SubName COM_SKS SubCode 0}
                {DomainId 1 ClassId 1 ElemId 17 ElemName R11 HierId 0
                    SubName COM_IQS SubCode 1}
                {DomainId 1 ClassId 1 ElemId 17 ElemName R11 HierId 0
                    SubName COM_SRS SubCode 2}
                {DomainId 1 ClassId 9 ElemId 43 ElemName R3 HierId 0
                    SubName COM_KAA SubCode 0}
                {DomainId 1 ClassId 9 ElemId 43 ElemName R3 HierId 0
                    SubName COM_DPA SubCode 1}
                {DomainId 1 ClassId 12 ElemId 57 ElemName R5 HierId 0
                    SubName COM_MSA SubCode 0}
            }
        }
    } -body {
        relation group $e Subtypes SubName SubCode
    } -result {
        {
            DomainId int
            ClassId int
            ElemId int
            ElemName string
            HierId int
            Subtypes {Relation {SubName string SubCode int}}
        } {
            {DomainId 1 ClassId 1 ElemId 17 ElemName R11 HierId 0 Subtypes {
                {SubName COM_SKS SubCode 0}
                {SubName COM_IQS SubCode 1}
                {SubName COM_SRS SubCode 2}}
            }
            {DomainId 1 ClassId 9 ElemId 43 ElemName R3 HierId 0 Subtypes {
                {SubName COM_KAA SubCode 0}
                {SubName COM_DPA SubCode 1}}
            }
            {DomainId 1 ClassId 12 ElemId 57 ElemName R5 HierId 0 Subtypes {
                {SubName COM_MSA SubCode 0}}
            }
        }
    } -match relation

    # relation heading subcommand
    test relation-heading-1.0 {dum relation} -body {
        relation heading $DUM
    } -result {}

    test relation-heading-2.0 {dee relation} -body {
        relation heading $DEE
    } -result {}

    test relation-heading-3.0 {single attribute} -body {
        relation heading {{Name string} {{Name Andrew}}}
    } -result {Name string}

    test relation-heading-4.0 {multiple attributes} -body {
        relation heading $S
    } -result {S# string SNAME string STATUS int CITY string}

    # relation insert subcommand
    test relation-insert-1.0 {single tuple} -body {
        relation insert [relation emptyof $S]\
            {S# S1 SNAME Jones STATUS 20 CITY Madrid}
    } -result {
        {S# string SNAME string STATUS int CITY string}
        {
            {S# S1 SNAME Jones STATUS 20 CITY Madrid}
        }
    } -match relation

    test relation-insert-2.0 {multiple tuple} -body {
        relation insert [relation emptyof $S]\
            {S# S1 SNAME Jones STATUS 20 CITY Madrid}\
            {S# S2 SNAME Smith STATUS 10 CITY London}\
            {S# S3 SNAME Elm STATUS 30 CITY Athens}
    } -result {
        {S# string SNAME string STATUS int CITY string}
        {
            {S# S1 SNAME Jones STATUS 20 CITY Madrid}
            {S# S2 SNAME Smith STATUS 10 CITY London}
            {S# S3 SNAME Elm STATUS 30 CITY Athens}
        }
    } -match relation

    test relation-insert-3.0 {duplicate tuple} -body {
        relation insert [relation emptyof $S]\
            {S# S1 SNAME Jones STATUS 20 CITY Madrid}\
            {S# S3 SNAME Elm STATUS 30 CITY Athens}\
            {S# S1 SNAME Jones STATUS 20 CITY Madrid}
    } -result {duplicate tuple, "S# S1 SNAME Jones STATUS 20 CITY Madrid"}\
    -returnCodes error

    test relation-insert-4.0 {bad tuple} -body {
        relation insert [relation emptyof $S]\
            {S# S1 SNAME Jones STATUS 20}
    } -result {wrong number of attributes specified, "S# S1 SNAME Jones STATUS 20"}\
    -returnCodes error

    # relation intersect subcommand
    test relation-intersect-1.0 {dum relation} -body {
        relation intersect $DUM $DUM
    } -result {{} {}} -match relation

    test relation-intersect-2.0 {dee relation} -body {
        relation intersect $DEE $DEE
    } -result {{} {{}}} -match relation

    test relation-intersect-3.0 {disjoint sets} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}}}
        set r2 {{Name string Age int City string}
            {{Name George Age 20 City {San Jose}}}}
        relation intersect $r1 $r2
    } -result {{Name string Age int City string} {}}\
    -match relation

    test relation-intersect-4.0 {same relation} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}}}
        relation intersect $r1 $r1
    } -result {
        {Name string Age int City string}
        {
            {Name Andrew Age 30 City Sunnyvale}
        }
    } -match relation

    test relation-intersect-5.0 {common tuples} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Name George Age 20 City {San Jose}}}}
        set r2 {{Name string Age int City string}
            {{Name George Age 20 City {San Jose}}}}
        relation intersect $r1 $r2
    } -result {
        {Name string Age int City string}
        {
            {Name George Age 20 City {San Jose}}
        }
    } -match relation

    test relation-intersect-6.0 {multiple common tuples} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Name George Age 20 City {San Jose}}}}
        set r2 {{Name string Age int City string}
            {{Name George Age 20 City {San Jose}}
            {Name Fred Age 10 City Saratoga}
            {Name Andrew Age 30 City Sunnyvale}}}
        relation intersect $r1 $r2
    } -result {
        {Name string Age int City string}
        {
            {Name Andrew Age 30 City Sunnyvale}
        {Name George Age 20 City {San Jose}}
        }
    } -match relation

    test relation-intersect-7.0 {multiple relations} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Name George Age 20 City {San Jose}}}}
        set r2 {{Name string Age int City string}
            {{Name George Age 20 City {San Jose}}}}
        set r3 {{Name string Age int City string}
            {{Name George Age 20 City {San Jose}}
            {Name Fred Age 10 City Saratoga}}}
        relation intersect $r1 $r2 $r3
    } -result {
        {Name string Age int City string}
        {
            {Name George Age 20 City {San Jose}}
        }
    } -match relation

    test relation-intersect-8.0 {multiple relations, different order} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Name George Age 20 City {San Jose}}}}
        set r2 {{Age int Name string City string}
            {{Name George Age 20 City {San Jose}}}}
        set r3 {{Age int City string Name string}
            {{Name George Age 20 City {San Jose}}
            {Name Fred Age 10 City Saratoga}}}
        relation intersect $r1 $r2 $r3
    } -result {
        {Name string Age int City string}
        {
            {Name George Age 20 City {San Jose}}
        }
    } -match relation

    # relation is subcommand

    # relation equal operator
    test relation-is-equal-1.0 {dum relation} -body {
        relation is $DUM equal {{} {}}
    } -result 1

    test relation-is-equal-2.0 {dee relation} -body {
        relation is $DEE equal {{} {{}}}
    } -result 1

    test relation-is-equal-3.0 {same relations} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 equal $r2
    } -result 1

    test relation-is-equal-4.0 {different header order} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string City string Age int}
            {{Age 20 Name George City {San Jose}}
            {Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 equal $r2
    } -result 1

    test relation-is-equal-5.0 {different relations} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string City string Age int}
            {{Age 20 Name George City {San Jose}}
            {Name Andrew Age 40 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 equal $r2
    } -result 0

    test relation-is-equal-6.0 {different headings} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string Status int City string}
            {{Status 20 Name George City {San Jose}}
            {Name Andrew Status 30 City Sunnyvale}
            {City Saratoga Status 10 Name Fred}}}
        relation is $r1 equal $r2
    } -result {headings not equal, "{Name string Status int City string}
            {{Status 20 Name George City {San Jose}}
            {Name Andrew Status 30 City Sunnyvale}
            {City Saratoga Status 10 Name Fred}}"} -returnCodes error

    test relation-is-equal-7.0 {tuple valued attributes} -body {
        set r1 {
            {   Name string
                Age int
                Address {Tuple {Number int Street string City string}}
            }
            {
                {Name Andrew Age 30
                    Address {Number 200 Street Main City Sunnyvale}}
                {Age 20 Name George
                    Address {Number 300 Street Clay City {San Jose}}}
                {Address {Street 51st Number 100 City Saratoga}
                    Age 10 Name Fred}
            }
        }
        set r2 {
            {   Name string
                Address {Tuple {Number int Street string City string}}
                Age int
            }
            {
                {   Address {City Sunnyvale Number 200 Street Main}
                    Age 30
                    Name Andrew
                }
                {   Age 20 
                    Name George
                    Address {Number 300 Street Clay City {San Jose}}
                }
                {   Name Fred
                    Address {Street 51st Number 100 City Saratoga}
                    Age 10
                }
            }
        }
        relation is $r1 == $r2
    } -result 1

    test relation-is-equal-7.1 {
        tuple valued identifier
    } -body {
        set r1 {
            {
                Name {Tuple {First string Middle string Last string}}
                Age int
                Address {Tuple {Number int Street string City string}}
            } {
                {
                    Name {First Fred Middle A Last Thomas}
                    Age 30
                    Address {Number 200 Street Main City Sunnyvale}
                }
                {
                    Age 20
                    Name {Middle F First George Last Harrison}
                    Address {Number 300 Street Clay City {San Jose}}
                }
                {
                    Address {Street 51st Number 100 City Saratoga}
                    Age 10
                    Name {Last Smith First John Middle Henry}
                }
            }
        }
        set r2 {
            {
                Name {Tuple {First string Middle string Last string}}
                Age int
                Address {Tuple {Number int Street string City string}}
            } {
                {
                    Age 30
                    Name {First Fred Middle A Last Thomas}
                    Address {Number 200 Street Main City Sunnyvale}
                }
                {
                    Name {First George Middle F Last Harrison}
                    Age 20
                    Address {Number 300 Street Clay City {San Jose}}
                }
                {
                    Name {First John Last Smith Middle Henry}
                    Address {Street 51st Number 100 City Saratoga}
                    Age 10
                }
            }
        }
        relation is $r1 == $r2
    } -result 1

    test relation-is-equal-8.0 {relation valued attributes} -body {
        set r1 {
            {   Name string
                Age int
                Addresses {Relation {Number int Street string City string}}
            } {
                {   Name Andrew
                    Age 30
                    Addresses {
                        {Number 200 Street Main City Sunnyvale}
                    }
                }
                {
                    Age 20
                    Name George
                    Addresses {
                        {Number 300 Street Clay City {San Jose}}
                    }
                }
                {   Addresses {
                        {Street 51st Number 100 City Saratoga}
                    }
                    Age 10
                    Name Fred
                }
            }
        }
        set r2 {
            {   Name string
                Age int
                Addresses {Relation {Number int Street string City string}}
            } {
                {
                    Age 20
                    Addresses {
                        {Number 300 Street Clay City {San Jose}}
                    }
                    Name George
                }
                {   Addresses {
                        {Street 51st Number 100 City Saratoga}
                    }
                    Age 10
                    Name Fred
                }
                {   Name Andrew
                    Addresses {
                        {Number 200 Street Main City Sunnyvale}
                    }
                    Age 30
                }
            }
        }
        relation is $r1 == $r2
    } -result 1

    test relation-is-equal-8.1 {relation valued attributes, multi value} -body {
        set r1 {
            {   Name string
                Age int
                Addresses {Relation {Number int Street string City string}}
            } {
                {   Name Andrew
                    Age 30
                    Addresses {
                        {Number 200 Street Main City Sunnyvale}
                        {Number 201 Street Main City Sunnyvale}
                        {Number 202 Street Main City Sunnyvale}
                    }
                }
                {
                    Age 20
                    Name George
                    Addresses {
                        {Number 300 Street Clay City {San Jose}}
                        {Number 301 Street Clay City {San Jose}}
                        {Number 302 Street Clay City {San Jose}}
                    }
                }
                {   Addresses {
                        {Street 51st Number 100 City Saratoga}
                        {Street 51st Number 101 City Saratoga}
                        {Street 51st Number 102 City Saratoga}
                    }
                    Age 10
                    Name Fred
                }
            }
        }
        set r2 {
            {   Name string
                Age int
                Addresses {Relation {Number int Street string City string}}
            } {
                {
                    Age 20
                    Addresses {
                        {Number 301 Street Clay City {San Jose}}
                        {Number 300 Street Clay City {San Jose}}
                        {Number 302 Street Clay City {San Jose}}
                    }
                    Name George
                }
                {   Addresses {
                        {Street 51st Number 102 City Saratoga}
                        {Street 51st Number 100 City Saratoga}
                        {Street 51st Number 101 City Saratoga}
                    }
                    Age 10
                    Name Fred
                }
                {   Name Andrew
                    Addresses {
                        {Number 201 Street Main City Sunnyvale}
                        {Number 202 Street Main City Sunnyvale}
                        {Number 200 Street Main City Sunnyvale}
                    }
                    Age 30
                }
            }
        }
        relation is $r1 == $r2
    } -result 1

    test relation-is-equal-9.0 {double representation} -body {
        set r1 {
            {Name string Age double City string} {
                {Name Andrew Age 30 City Sunnyvale}
            }
        }
        set r2 {
            {Name string Age double City string} {
                {Name Andrew Age 30.0 City Sunnyvale}
            }
        }
        relation is $r1 equal $r2
    } -result 1

    # relation notequal operator
    test relation-is-notequal-1.0 {dum relation} -body {
        relation is $DUM notequal {{} {}}
    } -result 0

    test relation-is-notequal-2.0 {dee relation} -body {
        relation is $DEE notequal {{} {{}}}
    } -result 0

    test relation-is-notequal-3.0 {same relations} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 notequal $r2
    } -result 0

    test relation-is-notequal-4.0 {different header order} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string City string Age int}
            {{Age 20 Name George City {San Jose}}
            {Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 notequal $r2
    } -result 0

    test relation-is-notequal-5.0 {different relations} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string City string Age int}
            {{Age 20 Name George City {San Jose}}
            {Name Andrew Age 40 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 != $r2
    } -result 1

    # relation propersubset operator
    test relation-is-propersubset-1.0 {dum relation} -body {
        relation is $DUM propersubsetof $DUM
    } -result 0

    test relation-is-propersubset-2.0 {dee relation} -body {
        relation is $DEE propersubsetof $DEE
    } -result 0

    test relation-is-propersubset-3.0 {same relations} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 propersubsetof $r2
    } -result 0

    test relation-is-propersubset-4.0 {smaller 1st relation} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 propersubsetof $r2
    } -result 1

    test relation-is-propersubset-5.0 {larger 1st relation} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 < $r2
    } -result 0

    # relation propersuperset operator
    test relation-is-propersuperset-1.0 {dum relation} -body {
        relation is $DUM propersuperset $DUM
    } -result 0

    test relation-is-propersuperset-2.0 {dee relation} -body {
        relation is $DEE propersupersetof $DEE
    } -result 0

    test relation-is-propersuperset-3.0 {same relations} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 propersupersetof $r2
    } -result 0

    test relation-is-propersuperset-4.0 {larger 1st relation} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 propersupersetof $r2
    } -result 1

    test relation-is-propersuperset-5.0 {smaller 1st relation} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 > $r2
    } -result 0

    # relation subset operator
    test relation-is-subset-1.0 {dum relation} -body {
        relation is $DUM subsetof $DUM
    } -result 1

    test relation-is-subset-2.0 {dee relation} -body {
        relation is $DEE subsetof $DEE
    } -result 1

    test relation-is-subset-3.0 {same relations} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 subsetof $r2
    } -result 1

    test relation-is-subset-4.0 {smaller 1st relation} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 subsetof $r2
    } -result 1

    test relation-is-subset-5.0 {larger 1st relation} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 <= $r2
    } -result 0

    # relation superset operator
    test relation-is-superset-1.0 {dum relation} -body {
        relation is $DUM supersetof $DUM
    } -result 1

    test relation-is-superset-2.0 {dee relation} -body {
        relation is $DEE supersetof $DEE
    } -result 1

    test relation-is-superset-3.0 {same relations} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 supersetof $r2
    } -result 1

    test relation-is-superset-4.0 {larger 1st relation} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 supersetof $r2
    } -result 1

    test relation-is-superset-5.0 {smaller 1st relation} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {Name Andrew Age 30 City Sunnyvale}
            {City Saratoga Age 10 Name Fred}}}
        relation is $r1 >= $r2
    } -result 0

    # relation isempty subcommand
    test relation-isempty-1.0 {dum relation} -body {
        relation isempty $DUM
    } -result 1

    test relation-isempty-2.0 {dee relation} -body {
        relation isempty $DEE
    } -result 0

    test relation-isempty-3.0 {multiple body tuples} -body {
        relation isempty $S
    } -result 0

    # relation isnotempty subcommand
    test relation-isnotempty-1.0 {dum relation} -body {
        relation isnotempty $DUM
    } -result 0

    test relation-isnotempty-2.0 {dee relation} -body {
        relation isnotempty $DEE
    } -result 1

    test relation-isnotempty-3.0 {multiple body tuples} -body {
        relation isnotempty $S
    } -result 1

    # relation issametype subcommand
    test relation-issametype-1.0 {
        is same type
    } -body {
        set r1 {{Name string Age int Address string} {}}
        set r2 {{Age int Name string Address string} {}}
        relation issametype $r1 $r2
    } -result {1}

    test relation-issametype-1.0 {
        not same type
    } -body {
        set r1 {{Age int Address string} {}}
        set r2 {{Age int Name string Address string} {}}
        relation issametype $r1 $r2
    } -result {0}

    # relation join subcommand
    test relation-join-1.0 {one common attribute} -body {
        set r1 {{Name string Age int}
            {{Age 20 Name George}
            {Age 10 Name Fred}}}
        set r2 {{Age int City string}
            {{Age 30 City Sunnyvale}
            {Age 20 City {San Jose}}
            {City Saratoga Age 10}}}
        relation join $r1 $r2
    } -result {
        {Name string Age int City string} {
            {Name George Age 20 City {San Jose}}
            {Name Fred Age 10 City Saratoga}
        }
    } -match relation

    test relation-join-2.0 {multiple common attribute} -body {
        set r1 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Age int City string}
            {{Age 30 City Sunnyvale}
            {Age 20 City {San Jose}}
            {City Saratoga Age 10}}}
        relation join $r1 $r2
    } -result {
        {Name string Age int City string} {
            {Name George Age 20 City {San Jose}}
            {Name Fred Age 10 City Saratoga}
        }
    } -match relation

    test relation-join-3.0 {no common attribute} -body {
        set r1 {{Name string Age int}
            {{Age 20 Name George}
            {Age 10 Name Fred}}}
        set r2 {{Status int City string}
            {{Status 30 City Sunnyvale}
            {Status 20 City {San Jose}}
            {City Saratoga Status 10}}}
        relation join $r1 $r2
    } -result {
        {Name string Age int Status int City string} {
            {Name George Age 20 Status 30 City Sunnyvale}
            {Name George Age 20 Status 20 City {San Jose}}
            {Name George Age 20 Status 10 City Saratoga}
            {Name Fred Age 10 Status 30 City Sunnyvale}
            {Name Fred Age 10 Status 20 City {San Jose}}
            {Name Fred Age 10 Status 10 City Saratoga}
        }
    } -match relation

    test relation-join-4.0 {join with DEE; identity} -body {
        set r1 {{Name string Age int}
            {{Age 20 Name George}
            {Age 10 Name Fred}}}
        relation is [relation join $r1 $DEE] == $r1
    } -result 1

    test relation-join-5.0 {join with DUM ; empty} -body {
        set r1 {{Name string Age int}
            {{Age 20 Name George}
            {Age 10 Name Fred}}}
        relation is [relation join $r1 $DUM] == [relation empty $r1]
    } -result 1

    test relation-join-6.0 {specified attribute} -body {
        set r1 {{Name string Age int City string}
            {{Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        set r2 {{Status int City string}
            {{Status 30 City Sunnyvale}
            {Status 20 City {San Jose}}
            {City Saratoga Status 10}}}
        relation join $r1 $r2 -using {City City}
    } -result {
        {Name string Age int City string Status int} {
            {Name George Age 20 City {San Jose} Status 20}
            {Name Fred Age 10 City Saratoga Status 10}
        }
    } -match relation

    test relation-join-7.0 {identifier subsets} -body {
        set r1 {
            {XId string A2 int A3 string} {
                {A2 20 XId George A3 {San Jose}}
                {A3 Saratoga A2 10 XId Fred}
            }
        }
        set r2 {
            {XId string A4 int} {
                {A4 30 XId George}
                {A4 20 XId Fred}
                {XId Fred A4 10}
            }
        }
        relation join $r1 $r2
    } -result {
        {XId string A2 int A3 string A4 int} {
            {XId George A2 20 A3 {San Jose} A4 30}
            {XId Fred A2 10 A3 Saratoga A4 20}
            {XId Fred A2 10 A3 Saratoga A4 10}
        }
    } -match relation

    test relation-join-7.1 {identifier subsets} -body {
        set r1 {
            {XId string A2 int A3 string} {
                {A2 20 XId George A3 {San Jose}}
                {A3 Saratoga A2 10 XId Fred}
            }
        }
        set r2 {
            {XId string A4 int} {
                {A4 30 XId George}
                {A4 20 XId Fred}
                {XId Fred A4 10}
            }
        }
        relation join $r2 $r1
    } -result {
        {XId string A2 int A3 string A4 int} {
            {XId George A2 20 A3 {San Jose} A4 30}
            {XId Fred A2 10 A3 Saratoga A4 20}
            {XId Fred A2 10 A3 Saratoga A4 10}
        }
    } -match relation

    test relation-join-8.0 {common identifiers} -setup {
        set r1 {
            {A1 string A2 string} {
                {A1 aa A2 ab}
                {A1 ba A2 bb}
                {A1 ca A2 cb}
            }
        }
        set r2 {
            {A1 string B1 string} {
                {A1 aa B1 ab}
                {A1 ba B1 bb}
                {A1 ca B1 cb}
                {A1 da B1 db}
                {A1 ea B1 eb}
                {A1 fa B1 fb}
            }
        }
    } -body {
        relation join $r1 $r2
    } -result {
        {A1 string A2 string B1 string} {
            {A1 aa A2 ab B1 ab}
            {A1 ba A2 bb B1 bb}
            {A1 ca A2 cb B1 cb}
        }
    } -match relation

    test relation-join-8.1 {common identifiers} -setup {
        set r1 {
            {A1 string A2 string} {
                {A1 aa A2 ab}
                {A1 ba A2 bb}
                {A1 ca A2 cb}
            }
        }
        set r2 {
            {A1 string B1 string} {
                {A1 aa B1 ab}
                {A1 ba B1 bb}
                {A1 ca B1 cb}
                {A1 da B1 db}
                {A1 ea B1 eb}
                {A1 fa B1 fb}
            }
        }
    } -body {
        relation join $r2 $r1
    } -result {
        {A1 string A2 string B1 string} {
            {A1 aa A2 ab B1 ab}
            {A1 ba A2 bb B1 bb}
            {A1 ca A2 cb B1 cb}
        }
    } -match relation

    test relation-join-8.2 {common identifiers} -setup {
        set r1 {
            {A1 string A2 string} {
                {A1 aa A2 ab}
                {A1 ba A2 bb}
                {A1 ca A2 cb}
            }
        }
        set r2 {
            {A1 string B1 string} {
                {A1 aa B1 ab}
                {A1 ba B1 bb}
                {A1 ca B1 cb}
                {A1 da B1 db}
                {A1 ea B1 eb}
                {A1 fa B1 fb}
            }
        }
    } -body {
        relation join $r2 $r1
    } -result {
        {A1 string A2 string B1 string} {
            {A1 aa A2 ab B1 ab}
            {A1 ba A2 bb B1 bb}
            {A1 ca A2 cb B1 cb}
        }
    } -match relation

    test relation-join-9.0 {duplicate attribute in join} -setup {
        set r1 {
            {A1 string A2 string} {
                {A1 aa A2 ab}
                {A1 ba A2 bb}
                {A1 ca A2 cb}
            }
        }
    } -body {
        relation join $r1 $r1 -using {A1 A1}
    } -result {duplicate attribute name, "A2"} -returnCodes error

    test relation-join-10.0 {
        multi-attribute identifier where concatenating values yields a duplicate
    } -setup {
        set r1 {
            {ID1 int} {
                {ID1 10}
                {ID1 0}
            }
        }

        set r2 {
            {ID2 int } {
                {ID2 2}
                {ID2 21}
            }
        }
    } -body {
        relation join $r2 $r1
    } -result {
        {ID2 int ID1 int} {
            {ID2 2 ID1 10}
            {ID2 2 ID1 0}
            {ID2 21 ID1 10}
            {ID2 21 ID1 0}
        }
    } -match relation

    # relation list subcommand
    test relation-list-1.0 {multiple tuples} -body {
        set r {
            {SNAME string} {
                {SNAME Smith}
                {SNAME Jones}
                {SNAME Blake}
                {SNAME Clark}
                {SNAME Adams}
            }
        }
        lsort [relation list $r]
    } -result {Adams Blake Clark Jones Smith}

    test relation-list-2.0 {one tuple} -body {
        relation list {{Name string} {{Name Fred}}}
    } -result {Fred}

    test relation-list-3.0 {list of named attribute} -body {
        lsort [relation list $S CITY]
    } -result {Athens London London Paris Paris}

    test relation-list-4.0 {
        sorting on one attribute
    } -body {
        relation list $P CITY P#
    } -result {London Paris Oslo London Paris London}

    test relation-list-4.1 {
        sorting on one attribute, descending
    } -body {
        relation list $P CITY -descending P#
    } -result {London Paris London Oslo Paris London}

    test relation-list-4.2 {
        sorting on multiple attributes
    } -body {
        relation list $P CITY -ascending {PNAME COLOR}
    } -result {Paris Paris London London Oslo London}

    # relation minus subcommand
    test relation-minus-1.0 {dum relation} -body {
        relation minus $DUM $DUM
    } -result {{} {}} -match relation

    test relation-minus-2.0 {dee relation} -body {
        relation minus $DEE $DEE
    } -result {{} {}} -match relation

    test relation-minus-3.0 {disjoint sets} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}}}
        set r2 {{Name string Age int City string}
            {{Name George Age 20 City {San Jose}}}}
        relation minus $r1 $r2
    } -result {{Name string Age int City string}\
        {{Name Andrew Age 30 City Sunnyvale}}} -match relation

    test relation-minus-4.0 {same sets} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}}}
        relation minus $r1 $r1
    } -result {{Name string Age int City string} {}}\
    -match relation

    # relation project subcommand
    test relation-project-1.0 {single attribute} -body {
        set r1 {
            {Name string Number int Street string IsMale string}
            {
                {Name Andrew Number 599 Street Blackwood IsMale true}
                {Name Jane Street Main Number 300 IsMale false}
                {Name Fred Street Maple Number 599 IsMale true}
            }
        }
        relation project $r1 Name
    } -result {
        {Name string}
        {
            {Name Andrew}
            {Name Jane}
            {Name Fred}
        }
    } -match relation

    test relation-project-2.0 {multiple attributes} -body {
        set r1 {
            {Name string Number int Street string IsMale string}
            {
                {Name Andrew Number 599 Street Blackwood IsMale true}
                {Name Jane Street Main Number 300 IsMale false}
                {Name Fred Street Maple Number 599 IsMale true}
            }
        }
        relation project $r1 Number IsMale
    } -result {
        {Number int IsMale string}
        {
            {Number 599 IsMale true}
            {Number 300 IsMale false}
        }
    } -match relation

    test relation-project-3.0 {nullary projection, non-empty relation} -body {
        set r1 {
            {Name string Number int Street string IsMale string}
            {
                {Name Andrew Number 599 Street Blackwood IsMale true}
                {Name Jane Street Main Number 300 IsMale false}
                {Name Fred Street Maple Number 599 IsMale true}
            }
        }
        relation project $r1
    } -result $DEE -match relation

    test relation-project-4.0 {nullary projection, empty relation} -body {
        set r1 {
            {Name string Number int Street string IsMale string}
            {}
        }
        relation project $r1
    } -result $DUM -match relation

    test relation-project-5.0 {non-existent attribute} -body {
        set r1 {
            {Name string Number int Street string IsMale string}
            {
                {Name Andrew Number 599 Street Blackwood IsMale true}
                {Name Jane Street Main Number 300 IsMale false}
                {Name Fred Street Maple Number 599 IsMale true}
            }
        }
        relation project $r1 foo
    } -result {unknown attribute name, "foo"} -returnCodes error

    test relation-project-6.0 {duplicate projection attribute} -body {
        set r1 {
            {Name string Number int Street string IsMale string}
            {
                {Name Andrew Number 599 Street Blackwood IsMale true}
                {Name Jane Street Main Number 300 IsMale false}
                {Name Fred Street Maple Number 599 IsMale true}
            }
        }
        relation project $r1 Name Name
    } -result {
        {Name string}
        {
            {Name Andrew}
            {Name Jane}
            {Name Fred}
        }
    } -match relation

    test relation-project-7.0 {reorder attributes} -body {
        set r1 {
            {Name string Number int Street string IsMale string}
            {{Name Andrew Number 599 Street Blackwood IsMale true}
            {Name Jane Street Main Number 300 IsMale false}
            {Name Fred Street Maple Number 599 IsMale true}}}
        relation project $r1 Number Street IsMale
    } -result {
        {Number int Street string IsMale string}
        {
            {Number 599 Street Blackwood IsMale true}
            {Number 300 Street Main IsMale false}
            {Number 599 Street Maple IsMale true}
        }
    } -match relation

    # relation rank subcommand
    test relation-rank-1.0 {rank descending} -body {
        relation rank $P -descending WEIGHT WEIGHT_RANK
    } -result {
        {P# string PNAME string COLOR string WEIGHT double CITY string
            WEIGHT_RANK int}
        {
            {P# P1 PNAME Nut COLOR Red WEIGHT 12.0 CITY London WEIGHT_RANK 5}
            {P# P2 PNAME Bolt COLOR Green WEIGHT 17.0 CITY Paris WEIGHT_RANK 2}
            {P# P3 PNAME Screw COLOR Blue WEIGHT 17.0 CITY Oslo WEIGHT_RANK 2}
            {P# P4 PNAME Screw COLOR Red WEIGHT 14.0 CITY London WEIGHT_RANK 4}
            {P# P5 PNAME Cam COLOR Blue WEIGHT 12.0 CITY Paris WEIGHT_RANK 5}
            {P# P6 PNAME Cog COLOR Red WEIGHT 19.0 CITY London WEIGHT_RANK 1}
        }
    } -match relation

    test relation-rank-2.0 {rank ascending} -body {
        relation rank $S -ascending STATUS SR
    } -result {
        {S# string SNAME string STATUS int CITY string SR int}
        {
            {S# S1 SNAME Smith STATUS 20 CITY London SR 2}
            {S# S2 SNAME Jones STATUS 10 CITY Paris SR 1}
            {S# S3 SNAME Blake STATUS 30 CITY Paris SR 4}
            {S# S4 SNAME Clark STATUS 20 CITY London SR 2}
            {S# S5 SNAME Adams STATUS 30 CITY Athens SR 4}
        }
    } -match relation

    # relation rename subcommand
    test relation-rename-1.0 {single attribute} -body {
        set r {{Name string} {{Name Andrew}}}
        relation rename $r Name foo
    } -result {
        {foo string} {{foo Andrew}}
    } -match relation

    test relation-rename-2.0 {multiple attributes} -body {
        set r {{Name string Age int City string}
        {{Name Andrew Age 30 City Sunnyvale}\
         {Name George Age 20 City {San Jose}}}}
        relation rename $r Age Status
    } -result {{Name string Status int City string}
        {{Name Andrew Status 30 City Sunnyvale}\
         {Name George Status 20 City {San Jose}}}
    } -match relation

    test relation-rename-2.1 {multiple attributes, multiple renames} -body {
        set r {{Name string Age int City string}
        {{Name Andrew Age 30 City Sunnyvale}
         {Name George Age 20 City {San Jose}}}}
        relation rename $r Age Status City Town
    } -result {
        {Name string Status int Town string}
        {
            {Name Andrew Status 30 Town Sunnyvale}
            {Name George Status 20 Town {San Jose}}
        }
    } -match relation

    test relation-rename-3.0 {renaming identifying attributes} -body {
        set r {
            {
                N1 string N2 string Age int City string
            } {
                {N1 Andrew N2 A Age 30 City Sunnyvale}
                {N1 George N2 G Age 20 City {San Jose}}
            }
        }
        relation rename $r N2 Name2
    } -result {
        {
            N1 string Name2 string Age int City string
        } {
            {N1 Andrew Name2 A Age 30 City Sunnyvale}
            {N1 George Name2 G Age 20 City {San Jose}}
        }
    } -match relation

    # relation restrict subcommand
    test relation-restrict-1.0 {match on one attribute} -body {
        set r {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        relation restrict $r t {[tuple extract $t Age] < 20}
    } -result {
        {Name string Age int City string}
        {{Name Fred Age 10 City Saratoga}}
    } -match relation

    test relation-restrict-2.0 {match on several attributes} -body {
        set r {
            {Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        relation restrict $r t\
            {[tuple extract $t Age] < 20 &&\
            [string index [tuple extract $t City] 0] ne "S"}
    } -result {{Name string Age int City string} {}
    } -match relation

    test relation-restrict-2.1 {
        match on a tuple valued attribute
    } -setup {
        set r {
            {Name string Address {Tuple {Street string City string}}} {
                {Name John Address {City Stockton Street Elm}}
                {Name Sue Address {Street Main City Modesto}}
                {Name Frank Address {Street 2nd City {Palo Alto}}}
            }
        }
    } -body {
        set m {{City string Street string} {Street Main City Modesto}}
        relation restrict $r t {[tuple equal [tuple extract $t Address] $m]}
    } -result {
        {Name string Address {Tuple {Street string City string}}} {
            {Name Sue Address {Street Main City Modesto}}
        }
    } -match relation

    test relation-restrict-3.0 {bad expression} -body {
        set r {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        relation restrict $r selected {< 20}
    } -result {missing operand at _@_
in expression "_@_< 20"} -returnCodes error

    # relation restrictwith subcommand
    test relation-restrictwith-1.0 {match on one attribute} -body {
        set r {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        relation restrictwith $r {$Age < 20}
    } -result {
        {Name string Age int City string}
        {{Name Fred Age 10 City Saratoga}}
    } -match relation

    test relation-restrictwith-2.0 {match on several attributes} -body {
        set r {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        relation restrictwith $r\
            {$Age < 20 && [string index $City 0] ne "S"}
    } -result {{Name string Age int City string} {}
    } -match relation

    test relation-restrictwith-3.0 {bad expression} -body {
        set r {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Age 20 Name George City {San Jose}}
            {City Saratoga Age 10 Name Fred}}}
        relation restrictwith $r {< 20}
    } -result {missing operand at _@_
in expression "_@_< 20"} -returnCodes error

    # relation semijoin subcommand
    test relation-semijoin-1.0 {one common attribute} -body {
        set r1 {{Age int City string}
            {{Age 30 City Sunnyvale}
            {Age 20 City {San Jose}}
            {City Saratoga Age 10}}}
        set r2 {{Name string Age int}
            {{Age 20 Name George}
            {Age 10 Name Fred}}}
        relation semijoin $r1 $r2
    } -result {
        {Name string Age int}
        {
            {Name George Age 20}
            {Name Fred Age 10}
        }
    } -match relation

    test relation-semijoin-2.0 {one common attribute} -body {
        set r1 {{Age int City string}
            {{Age 35 City Sunnyvale}
            {Age 20 City {San Jose}}
            {City Saratoga Age 15}}}
        set r2 {{Name string Age int}
            {{Age 20 Name George}
            {Age 10 Name Fred}}}
        relation semijoin $r1 $r2
    } -result {
        {Name string Age int}
        {
            {Name George Age 20}
        }
    } -match relation

    test relation-semijoin-3.0 {more than two relations} -body {
        relation semijoin $P $SP $S
    } -result {
        {S# string SNAME string STATUS int CITY string}
        {
            {S# S1 SNAME Smith STATUS 20 CITY London}
            {S# S2 SNAME Jones STATUS 10 CITY Paris}
            {S# S3 SNAME Blake STATUS 30 CITY Paris}
            {S# S4 SNAME Clark STATUS 20 CITY London}
        }
    } -match relation

    test relation-semijoin-4.0 {reflexive association; one direction} -setup {
        set Item {
            {A1 string PrevA1 string}
            {
                {A1 a PrevA1 {}}
                {A1 b PrevA1 a}
                {A1 c PrevA1 b}
            }
        }
    } -cleanup {
    } -body {
        relation semijoin $Item $Item -using {A1 PrevA1}
    } -result {
        {A1 string PrevA1 string}
        {
            {A1 b PrevA1 a}
            {A1 c PrevA1 b}
        }
    } -match relation

    test relation-semijoin-4.1 {reflexive association; other direction} -setup {
        set Item {
            {A1 string PrevA1 string}
            {
                {A1 a PrevA1 {}}
                {A1 b PrevA1 a}
                {A1 c PrevA1 b}
            }
        }
    } -cleanup {
    } -body {
        relation semijoin $Item $Item -using {PrevA1 A1}
    } -result {
        {A1 string PrevA1 string}
        {
            {A1 a PrevA1 {}}
            {A1 b PrevA1 a}
        }
    } -match relation

    test relation-semijoin-5.0 {compound identifiers, attr order} -setup {
        set Container {
            {A1 string A2 string PrevA1 string}
            {
                {A1 a1 A2 a2 PrevA1 {}}
                {A1 b1 A2 a2 PrevA1 a1}
                {A1 c1 A2 a2 PrevA1 b1}
            }
        }
    } -cleanup {
    } -body {
        set s [relation restrictwith $Container {$PrevA1 eq ""}]
        relation semijoin $s $Container -using {A2 A2 A1 PrevA1}
    } -result {
        {A1 string A2 string PrevA1 string}
        {
            {A1 b1 A2 a2 PrevA1 a1}
        }
    } -match relation

    test relation-semijoin-5.1 {overlapping identifiers} -setup {
        set C1 {
            {A1 string A2 string A3 string}
            {
                {A1 a1 A2 a2 A3 a3}
                {A1 b1 A2 b2 A3 b3}
                {A1 c1 A2 c2 A3 c3}
            }
        }
        set C2 {
            {A1 string A2 string C1 string C2 string}
            {
                {A1 a1 A2 a2 C1 c1 C2 c2}
                {A1 a1 A2 a2 C1 c2 C2 c2}
            }
        }
    } -cleanup {
    } -body {
        relation semijoin $C2 $C1
    } -result {
        {A1 string A2 string A3 string}
        {
            {A1 a1 A2 a2 A3 a3}
        }
    } -match relation

    test relation-semijoin-5.2 {overlapping identifiers} -setup {
        set C1 {
            {A1 string A2 string A3 string}
            {
                {A1 a1 A2 a2 A3 a3}
                {A1 b1 A2 b2 A3 b3}
                {A1 c1 A2 c2 A3 c3}
            }
        }
        set C2 {
            {A1 string A2 string C1 string C2 string}
            {
                {A1 a1 A2 a2 C1 c1 C2 c2}
                {A1 a1 A2 a2 C1 c2 C2 c2}
            }
        }
    } -cleanup {
    } -body {
        relation semijoin $C1 $C2
    } -result {
        {A1 string A2 string C1 string C2 string}
        {
            {A1 a1 A2 a2 C1 c1 C2 c2}
            {A1 a1 A2 a2 C1 c2 C2 c2}
        }
    } -match relation

    test relation-semijoin-5.3 {overlapping identifiers} -setup {
        set class {
            {
                DomainId int
                ClassId int
                ClassName string
                Line int
                StorageSlots int
                PolyEvents list
            } {
                {DomainId 1 ClassId 1 ClassName foo Line 10 StorageSlots 0
                    PolyEvents {}}
                {DomainId 1 ClassId 2 ClassName bar Line 11 StorageSlots 0
                    PolyEvents {}}
            }
        }
        set classref {
            {
                DomainId int
                ClassId int
                ElemId int
                RefToClass string
                Multiple boolean
            } {
                {DomainId 1 ClassId 1 ElemId 1 RefToClass bar Multiple 0}
                {DomainId 1 ClassId 1 ElemId 2 RefToClass bar Multiple 0}
                {DomainId 1 ClassId 1 ElemId 3 RefToClass bar Multiple 0}
                {DomainId 1 ClassId 2 ElemId 4 RefToClass foo Multiple 0}
                {DomainId 1 ClassId 2 ElemId 5 RefToClass foo Multiple 0}
                {DomainId 1 ClassId 2 ElemId 6 RefToClass foo Multiple 0}
            }
        }
    } -cleanup {
    } -body {
        set class1 [relation restrictwith $class {$ClassId == 1}]
        relation semijoin $class1 $classref
    } -result {
        {
            DomainId int
            ClassId int
            ElemId int
            RefToClass string
            Multiple boolean
        } {
            {DomainId 1 ClassId 1 ElemId 1 RefToClass bar Multiple 0}
            {DomainId 1 ClassId 1 ElemId 2 RefToClass bar Multiple 0}
            {DomainId 1 ClassId 1 ElemId 3 RefToClass bar Multiple 0}
        }
    } -match relation

    test relation-semijoin-5.4 {overlapping identifiers} -setup {
        set domain {
            {
                DomainId int
                DomainName string
                IntfProlog string
                IntfPrologLine int
                IntfEpilog string
                IntfEpilogLine int
            } {
                {
                    DomainId 1
                    DomainName Foo
                    IntfProlog prolog
                    IntfPrologLine 22
                    IntfEpilog epilog
                    IntfEpilogLine 200
                }
            }
        }
        set class {
            {
                DomainId int
                ClassId int
                ClassName string
                Line int
                StorageSlots int
            } {
                {DomainId 1 ClassId 1 ClassName c1 Line 20 StorageSlots 0}
                {DomainId 1 ClassId 2 ClassName c2 Line 21 StorageSlots 1}
                {DomainId 1 ClassId 3 ClassName c3 Line 23 StorageSlots 2}
                {DomainId 1 ClassId 4 ClassName c4 Line 24 StorageSlots 3}
                {DomainId 1 ClassId 5 ClassName c5 Line 25 StorageSlots 4}
            }
        }
    } -cleanup {
    } -body {
        relation semijoin $domain $class
    } -result {
        {
            DomainId int
            ClassId int
            ClassName string
            Line int
            StorageSlots int
        } {
            {DomainId 1 ClassId 1 ClassName c1 Line 20 StorageSlots 0}
            {DomainId 1 ClassId 2 ClassName c2 Line 21 StorageSlots 1}
            {DomainId 1 ClassId 3 ClassName c3 Line 23 StorageSlots 2}
            {DomainId 1 ClassId 4 ClassName c4 Line 24 StorageSlots 3}
            {DomainId 1 ClassId 5 ClassName c5 Line 25 StorageSlots 4}
        }
    } -match relation

    test relation-semijoin-5.4 {
        common attributes not all in identifiers
    } -setup {
        set r1 {
            {
                Attr1 string Attr2 int Attr3 string
            } {
                {Attr1 a1 Attr2 1 Attr3 a4}
                {Attr1 a2 Attr2 2 Attr3 a5}
                {Attr1 a3 Attr2 3 Attr3 a6}
            }
        }
        set r2 {
            {
                Bttr1 string Attr1 string
            } {
                {Bttr1 b1 Attr1 a1}
                {Bttr1 b3 Attr1 a33}
                {Bttr1 b2 Attr1 a3}
                {Bttr1 b4 Attr1 a44}
            }
        }
    } -cleanup {
        unset r1 r2
    } -body {
        relation semijoin $r1 $r2
    } -result {
        {
            Bttr1 string Attr1 string
        } {
            {Bttr1 b1 Attr1 a1}
            {Bttr1 b2 Attr1 a3}
        }
    } -match relation

    test relation-semijoin-6.1 {unknown using attribute} -setup {
        set A [relation create {A_ID string}]
        set B [relation create {B_ID string}]
    } -body {
        relation semijoin $A $B -using {A_ID A_ID}
    } -result {unknown attribute name, "A_ID"} -returnCodes error

    test relation-semijoin-6.2 {bad -using list} -setup {
        set A [relation create {A_ID string}]
        set B [relation create {B_ID string}]
    } -body {
        relation semijoin $A $B -using {A_ID}
    } -result {bad list of pairs, "A_ID"} -returnCodes error

    # relation semiminus subcommand
    test relation-semiminus-1.0 {one common attribute} -body {
        relation semiminus $SP $S
    } -result {
        {S# string SNAME string STATUS int CITY string}
        {
            {S# S5 SNAME Adams STATUS 30 CITY Athens}
        }
    } -match relation

    test relation-semiminus-2.0 {one common attribute} -body {
        relation semiminus $S $SP
    } -result {
        {S# string P# string QTY int}
        {}
    } -match relation

    test relation-semiminus-3.0 {one common attribute} -body {
        set r1 {
            {Age int City string}
            {
                {Age 30 City Sunnyvale}
                {Age 20 City {San Jose}}
                {City Saratoga Age 10}
            }
        }
        set r2 {
            {Name string Age int Town string}
            {
                {Age 20 Name George Town Sunnyvale}
                {Age 10 Name Fred Town {New York}}
            }
        }
        relation semiminus $r1 $r2 -using {City Town}
    } -result {
            {Name string Age int Town string}
            {
                {Age 10 Name Fred Town {New York}}
            }
    } -match relation

    # relation summarize subcommand
    test relation-summarize-1.0 {count} -constraints {
        tcl8.5
    } -body {
        set p [relation project $P P#]
        relation summarize $SP $p r Total int {rsum($r, "QTY")}
    } -result {
        {P# string Total int}
        {
            {P# P1 Total 600}
            {P# P2 Total 1000}
            {P# P3 Total 400}
            {P# P4 Total 500}
            {P# P5 Total 500}
            {P# P6 Total 100}
        }
    } -match relation

    # For tcl8.4
    test relation-summarize-1.0.1 {count} -constraints {
        tcl8.4
    } -body {
        set p [relation project $P P#]
        relation summarize $SP $p r Total int {[rsum $r "QTY"]}
    } -result {
        {P# string Total int}
        {
            {P# P1 Total 600}
            {P# P2 Total 1000}
            {P# P3 Total 400}
            {P# P4 Total 500}
            {P# P5 Total 500}
            {P# P6 Total 100}
        }
    } -match relation

    test relation-summarize-2.0 {summarize per dee} -constraints {
        tcl8.5
    } -body {
        relation summarize $SP $DEE r GrandTotal int {rsum($r, "QTY")}
    } -result {
        {GrandTotal int}
        {
            {GrandTotal 3100}
        }
    } -match relation

    # For tcl8.4
    test relation-summarize-2.0.1 {summarize per dee} -constraints {
        tcl8.4
    } -body {
        relation summarize $SP $DEE r GrandTotal int {[rsum $r "QTY"]}
    } -result {
        {GrandTotal int}
        {
            {GrandTotal 3100}
        }
    } -match relation

    test relation-summarize-2.1 {summarize per dee, average} -constraints {
        tcl8.5
    } -body {
        relation summarize $SP $DEE r GrandAvg int {ravg($r, "QTY")}
    } -result {
        {GrandAvg int}
        {
            {GrandAvg 258}
        }
    } -match relation

    # For tcl8.4
    test relation-summarize-2.1.1 {summarize per dee, average} -constraints {
        tcl8.4
    } -body {
        relation summarize $SP $DEE r GrandAvg int {[ravg $r "QTY"]}
    } -result {
        {GrandAvg int}
        {
            {GrandAvg 258}
        }
    } -match relation

    test relation-summarize-2.2 {summarize per dee, average} -constraints {
        tcl8.5
    } -body {
        relation summarize $OWNER $DEE r AverageAge int {ravg($r, "Age")}
    } -result {
        {AverageAge int}
        {
            {AverageAge 36}
        }
    } -match relation

    # For tcl8.4
    test relation-summarize-2.2.1 {summarize per dee, average} -constraints {
        tcl8.4
    } -body {
        relation summarize $OWNER $DEE r AverageAge int {[ravg $r "Age"]}
    } -result {
        {AverageAge int}
        {
            {AverageAge 36}
        }
    } -match relation

    test relation-summarize-3.0 {projection} -body {
        relation summarize $S [relation project $S STATUS CITY] r\
            TOTAL int {[relation cardinality $r]}
    } -result {
        {STATUS int CITY string TOTAL int}
        {
            {STATUS 20 CITY London TOTAL 2}
            {STATUS 10 CITY Paris TOTAL 1}
            {STATUS 30 CITY Paris TOTAL 1}
            {STATUS 30 CITY Athens TOTAL 1}
        }
    } -match relation

    test relation-summarize-4.0 {projection, counting} -body {
        set ac [relation project $OWNERSHIP Acquired]
        relation summarize $OWNERSHIP $ac r\
            NumAcquired int {[relation cardinality $r]}
    } -result {
        {Acquired string NumAcquired int} {
            {Acquired 2001 NumAcquired 3}
            {Acquired 2000 NumAcquired 2}
            {Acquired 2002 NumAcquired 1}
            {Acquired 2003 NumAcquired 1}
        }
    } -match relation

    # relation summarizeby subcommand
    test relation-summarizeby-1.0 {
        count
    } -constraints {
        tcl8.5
    } -body {
        relation summarizeby $SP P# r Total int {rsum($r, "QTY")}
    } -result {
        {P# string Total int} {
            {P# P1 Total 600}
            {P# P2 Total 1000}
            {P# P3 Total 400}
            {P# P4 Total 500}
            {P# P5 Total 500}
            {P# P6 Total 100}
        }
    } -match relation

    test relation-summarizeby-2.0 {
        summarize no attributes
    } -constraints {
        tcl8.5
    } -body {
        relation summarizeby $SP {} r GrandTotal int {rsum($r, "QTY")}
    } -result {
        {GrandTotal int} {
            {GrandTotal 3100}
        }
    } -match relation

    test relation-summarizeby-3.0 {
        bad attribute
    } -body {
        relation summarizeby $SP A r GrandTotal int {rsum($r, "QTY")}
    } -result {unknown attribute name, "A"} -returnCodes error

    test relation-summarizeby-3.1 {
        duplicate attribute
    } -body {
        relation summarizeby $SP {P# P#} r GrandTotal int {rsum($r, "QTY")}
    } -result {duplicate attribute name, "P#"} -returnCodes error

    test relation-summarizeby-4.0 {
        projection, counting
    } -body {
        relation summarizeby $OWNERSHIP Acquired r\
            NumAcquired int {[relation cardinality $r]}
    } -result {
        {Acquired string NumAcquired int} {
            {Acquired 2001 NumAcquired 3}
            {Acquired 2000 NumAcquired 2}
            {Acquired 2002 NumAcquired 1}
            {Acquired 2003 NumAcquired 1}
        }
    } -match relation

    test relation-summarizeby-4.1 {
        multiple attributes
    } -body {
        relation summarizeby $S {STATUS CITY} r\
            TOTAL int {[relation cardinality $r]}
    } -result {
        {STATUS int CITY string TOTAL int} {
            {STATUS 20 CITY London TOTAL 2}
            {STATUS 10 CITY Paris TOTAL 1}
            {STATUS 30 CITY Paris TOTAL 1}
            {STATUS 30 CITY Athens TOTAL 1}
        }
    } -match relation

    test relation-summarizeby-5.0 {
        relation valued attribute, bad heading
    } -body {
        relation summarizeby $OWNERSHIP Acquired r\
            NumAcquired {Relation {Number int Year int}}\
            {{{Number int} {{Number 100} {Number 200}}}}
    } -result {wrong number of attributes specified, "Number int"}\
    -returnCodes error

    test relation-summarizeby-5.1 {
        relation valued attribute, with tuple value
    } -body {
        relation summarizeby $OWNERSHIP Acquired r\
            NumAcquired {Relation {Number int Year int}}\
            {[tuple create {Number int Year int} {Number 100 Year 2000}]}
    } -result {bad value type for value, "int"} -returnCodes error

    # relation tag subcommand
    test relation-tag-1.0 {relation scope -- ascending} -body {
        relation tag $S NameOrder -ascending SNAME
    } -result {
        {S# string SNAME string STATUS int CITY string NameOrder int} {
            {S# S1 SNAME Smith STATUS 20 CITY London NameOrder 4}
            {S# S2 SNAME Jones STATUS 10 CITY Paris NameOrder 3}
            {S# S3 SNAME Blake STATUS 30 CITY Paris NameOrder 1}
            {S# S4 SNAME Clark STATUS 20 CITY London NameOrder 2}
            {S# S5 SNAME Adams STATUS 30 CITY Athens NameOrder 0}
        }
    } -match relation

    test relation-tag-2.0 {relation scope -- descending} -body {
        relation tag $S NameOrder -descending SNAME
    } -result {
        {S# string SNAME string STATUS int CITY string NameOrder int}
        {
            {S# S1 SNAME Smith STATUS 20 CITY London NameOrder 0}
            {S# S2 SNAME Jones STATUS 10 CITY Paris NameOrder 1}
            {S# S3 SNAME Blake STATUS 30 CITY Paris NameOrder 3}
            {S# S4 SNAME Clark STATUS 20 CITY London NameOrder 2}
            {S# S5 SNAME Adams STATUS 30 CITY Athens NameOrder 4}
        }
    } -match relation

    test relation-tag-3.0 {within scope} -body {
        relation tag $SP SOrder -within S#
    } -result {
        {S# string P# string QTY int SOrder int}
        {
            {S# S1 P# P1 QTY 300 SOrder 0}
            {S# S1 P# P2 QTY 200 SOrder 1}
            {S# S1 P# P3 QTY 400 SOrder 2}
            {S# S1 P# P4 QTY 200 SOrder 3}
            {S# S1 P# P5 QTY 100 SOrder 4}
            {S# S1 P# P6 QTY 100 SOrder 5}
            {S# S2 P# P1 QTY 300 SOrder 0}
            {S# S2 P# P2 QTY 400 SOrder 1}
            {S# S3 P# P2 QTY 200 SOrder 0}
            {S# S4 P# P2 QTY 200 SOrder 0}
            {S# S4 P# P4 QTY 300 SOrder 1}
            {S# S4 P# P5 QTY 400 SOrder 2}
        }
    } -match relation

    test relation-tag-3.1 {within scope -- descending P#} -body {
        relation tag $SP POrder -descending P# -within S#
    } -result {
        {S# string P# string QTY int POrder int}
        {
            {S# S1 P# P1 QTY 300 POrder 5}
            {S# S1 P# P2 QTY 200 POrder 4}
            {S# S1 P# P3 QTY 400 POrder 3}
            {S# S1 P# P4 QTY 200 POrder 2}
            {S# S1 P# P5 QTY 100 POrder 1}
            {S# S1 P# P6 QTY 100 POrder 0}
            {S# S2 P# P1 QTY 300 POrder 1}
            {S# S2 P# P2 QTY 400 POrder 0}
            {S# S3 P# P2 QTY 200 POrder 0}
            {S# S4 P# P2 QTY 200 POrder 2}
            {S# S4 P# P4 QTY 300 POrder 1}
            {S# S4 P# P5 QTY 400 POrder 0}
        }
    } -match relation

    test relation-tag-4.1 {
        duplicate tag attribute name
    } -body {
        relation tag $S SNAME
    } -result {duplicate attribute name, "SNAME"} -returnCodes error

    test relation-tag-4.2 {
        contradicting sort options
    } -body {
        relation tag $S SNAME -descending SNAME -ascending SNAME
    } -result {duplicate command option, "-ascending"} -returnCodes error

    test relation-tag-4.3 {
        contradicting sort options
    } -body {
        relation tag $S SNAME -within SNAME -within SNAME
    } -result {duplicate command option, "-within"} -returnCodes error

    test relation-tag-4.4 {
        sorting on unknown attribute
    } -body {
        relation tag $S SNAME -ascending foo
    } -result {unknown attribute name, "foo"} -returnCodes error

    # relation tclose subcommand
    test relation-tclose-1.0 {single path} -body {
        set r {
            {A string B string}
            {
                {A a B b}
                {A b B c}
            }
        }
        relation tclose $r
    } -result {
        {A string B string}
        {
            {A a B b}
            {A b B c}
            {A a B c}
        }
    } -match relation

    test relation-tclose-1.1 {reverse path} -body {
        set r {
            {A string B string}
            {
                {A b B a}
                {A c B b}
            }
        }
        relation tclose $r
    } -result {
        {A string B string}
        {
            {A b B a}
            {A c B b}
            {A c B a}
        }
    } -match relation

    test relation-tclose-2.0 {joining path} -body {
        set r {
            {A string B string}
            {
                {A a B b}
                {A a B c}
                {A b B d}
                {A c B d}
            }
        }
        relation tclose $r
    } -result {
        {A string B string}
        {
            {A a B b}
            {A a B c}
            {A b B d}
            {A c B d}
            {A a B d}
        }
    } -match relation

    test relation-tclose-2.1 {diverging path} -body {
        set r {
            {A string B string}
            {
                {A a B b}
                {A a B c}
                {A b B d}
                {A c B d}
                {A c B e}
                {A e B f}
            }
        }
        relation tclose $r
    } -result {
        {A string B string}
        {
            {A a B b}
            {A a B c}
            {A a B d}
            {A a B e}
            {A a B f}
            {A b B d}
            {A c B d}
            {A c B e}
            {A c B f}
            {A e B f}
        }
    } -match relation

    test relation-tclose-3.0 {AHU example} -body {
        set r {
            {A string B string}
            {
                {A v1 B v1}
                {A v1 B v2}
                {A v1 B v3}
                {A v2 B v1}
                {A v3 B v2}
            }
        }
        relation tclose $r
    } -result {
        {A string B string}
        {
            {A v1 B v1}
            {A v1 B v2}
            {A v1 B v3}
            {A v2 B v1}
            {A v2 B v2}
            {A v2 B v3}
            {A v3 B v1}
            {A v3 B v2}
            {A v3 B v3}
        }
    } -match relation

    test relation-tclose-4.0 {tree} -body {
        set r {
            {A string B string}
            {
                {A root B n1}
                {A root B n2}
                {A n1 B n3}
                {A n1 B n4}
                {A n2 B n5}
                {A n2 B n6}
            }
        }
        relation tclose $r
    } -result {
        {A string B string}
        {
            {A root B n1}
            {A root B n2}
            {A root B n3}
            {A root B n4}
            {A root B n5}
            {A root B n6}
            {A n1 B n3}
            {A n1 B n4}
            {A n2 B n5}
            {A n2 B n6}
        }
    } -match relation

    test relation-tclose-4.1 {reverse tree} -body {
        set r {
            {B string A string}
            {
                {A root B n1}
                {A root B n2}
                {A n1 B n3}
                {A n1 B n4}
                {A n2 B n5}
                {A n2 B n6}
            }
        }
        relation tclose $r
    } -result {
        {A string B string}
        {
            {A root B n1}
            {A root B n2}
            {A root B n3}
            {A root B n4}
            {A root B n5}
            {A root B n6}
            {A n1 B n3}
            {A n1 B n4}
            {A n2 B n5}
            {A n2 B n6}
        }
    } -match relation

    # relation times subcommand
    test relation-times-1.0 {single attribute, square relation} -body {
        set r1 {{Name string} {{Name Andrew}}}
        set r2 {{XName string} {{XName Andrew}}}
        relation times $r1 $r2
    } -result {
        {Name string XName string}
        {
            {Name Andrew XName Andrew}
        }
    } -match relation

    test relation-times-2.0 {single attribute times dee} -body {
        set r1 {{Name string} {{Name Andrew}}}
        relation times $r1 $DEE
    } -result {{Name string} {{Name Andrew}}} -match relation

    test relation-times-3.0 {single attribute times dum} -body {
        set r1 {{Name string} {{Name Andrew}}}
        relation times $r1 $DUM
    } -result {{Name string} {}} -match relation

    test relation-times-4.0 {single attribute, cube relation} -body {
        set r1 {{Name string} {{Name Andrew}}}
        set r2 {{XName string} {{XName Andrew}}}
        set r3 {{YName string} {{YName Andrew}}}
        relation times $r1 $r2 $r3
    } -result {
        {Name string XName string YName string}
        {
            {Name Andrew XName Andrew YName Andrew}
        }
    } -match relation

    test relation-times-5.0 {multiple attributes, square relation} -body {
        set r1 {{Name string} {{Name Andrew} {Name George}}}
        set r2 {{Status int} {{Status 20} {Status 30}}}
        relation times $r1 $r2
    } -result {
        {Name string Status int}
        {
            {Name Andrew Status 20}
            {Name Andrew Status 30}
            {Name George Status 20}
            {Name George Status 30}
        }
    } -match relation

    test relation-times-6.0 {attribute name conflict} -body {
        set r1 {{Name string} {{Name Andrew}}}
        relation times $r1 $r1
    } -result {duplicate attribute name, "{Name string} {{Name Andrew}}"}\
    -returnCodes error

    test relation-times-6.1 {attribute name conflict, third relation} -body {
        set r1 {{Name string} {{Name Andrew}}}
        set r2 {{Status int} {{Status 20} {Status 30}}}
        relation times $r1 $r2 $r1
    } -result {duplicate attribute name, "{Name string} {{Name Andrew}}"}\
    -returnCodes error

    # relation tuple subcommand
    test relation-tuple-1.0 {single attribute} -body {
        set t [relation tuple {{Name string} {{Name Andrew}}}]
        tuple equal $t {{Name string} {Name Andrew}}
    } -result 1

    test relation-tuple-2.0 {multiple attributes} -body {
        set r {{Name string Age int} {{Name Andrew Age 20}}}
        set t [relation tuple $r]
        tuple equal $t {{Name string Age int} {Name Andrew Age 20}}
    } -result 1

    test relation-tuple-3.0 {body too long} -body {
        set r {{Name string Age int} {{Name Andrew Age 20} {Name George Age 20}}}
        relation tuple $r
    } -result {relation must have cardinality of one, "{Name string Age int} {{Name Andrew Age 20} {Name George Age 20}}"} -returnCodes error

    # relation ungroup subcommand
    test relation-ungroup-1.0 {two attribute relation} -body {
        set r {
            {Name string
                Dog {Relation {DogName string Breed string}}
            }
            {
                {Name Fred Dog {
                    {DogName Rover Breed Terrier}
                    {DogName Missy Breed Poodle}}
                }
                {Name Alice Dog {
                    {DogName Tiger Breed Setter}}
                }
            }
        }
        relation ungroup $r Dog
    } -result {
        {Name string DogName string Breed string}
        {
            {Name Fred DogName Rover Breed Terrier}
            {Name Fred DogName Missy Breed Poodle}
            {Name Alice DogName Tiger Breed Setter}
        }
    } -match relation

    test relation-ungroup-2.0 {duplicate attribute name} -body {
        set r {
            {Name string Dog {Relation {Name string Breed string}}}
            {
                {Name Fred Dog {
                    {Name Rover Breed Terrier}
                    {Name Missy Breed Poodle}}
                }
                {Name Alice Dog {{Name Tiger Breed Setter}}}
            }
        }
        relation ungroup $r Dog
    } -result {duplicate attribute name, "while ungrouping relation"}\
    -returnCodes error

    test relation-ungroup-2.1 {unknown attribute name} -body {
        set r {
            {Name string Dog {Relation {Name string Breed string}}}
            {
                {Name Fred Dog
                    {
                        {Name Rover Breed Terrier}
                        {Name Missy Breed Poodle}
                    }
                }
                {Name Alice Dog {{Name Tiger Breed Setter}}
                }
            }
        }
        relation ungroup $r Weight
    } -result {unknown attribute name, "Weight"}\
    -returnCodes error

    test relation-ungroup-2.2 {attribute not a relation} -body {
        set r {
            {Name string Dog {Relation {Name string Breed string}}}
            {
                {Name Fred Dog
                    {
                        {Name Rover Breed Terrier}
                        {Name Missy Breed Poodle}
                    }
                }
                {Name Alice Dog {{Name Tiger Breed Setter}}
                }
            }
        }
        relation ungroup $r Name
    } -result {attribute must be of a Relation type, "Name"} -returnCodes error

    test relation-ungroup-3.0 {common tuples in the relation attribute} -body {
        set r {
            {Name string Dog {Relation {DogName string Breed string}}}
            {
                {Name Fred Dog {
                    {DogName Rover Breed Terrier}
                    {DogName Missy Breed Poodle}}
                }
                {Name Fred Dog {{DogName Rover Breed Terrier}}}
            }
        }
        relation ungroup $r Dog
    } -result {
        {Name string DogName string Breed string}
        {
            {Name Fred DogName Rover Breed Terrier}
            {Name Fred DogName Missy Breed Poodle}
        }
    } -match relation

    test relation-ungroup-4.0 {attributes beyond ungrouped attribute} -body {
        set r {
            {Name string
             Dog {Relation {DogName string Breed string}}
             Weight int}
            {
                {Name Fred Dog {
                        {DogName Rover Breed Terrier}
                        {DogName Missy Breed Poodle}} Weight 20
                }
                {Name Alice Dog {
                        {DogName Tiger Breed Setter}} Weight 40
                }
            }
        }
        relation ungroup $r Dog
    } -result {
        {Name string Weight int DogName string Breed string}
        {
            {Name Fred Weight 20 DogName Rover Breed Terrier}
            {Name Fred Weight 20 DogName Missy Breed Poodle}
            {Name Alice Weight 40 DogName Tiger Breed Setter}
        }
    } -match relation

    test relation-ungroup-5.0 {ungroup; functionally dependent} -setup {
        set two {
            {A int RVX {Relation {X string}}}
            {
                {A 1 RVX {{X a} {X b}}}
                {A 1 RVX {{X a} {X c}}}
            }
        }
    } -body {
        relation ungroup $two RVX
    } -result {
        {A int X string}
        {
            {A 1 X a}
            {A 1 X b}
            {A 1 X c}
        }
    } -match relation

    # relation union subcommand
    test relation-union-1.0 {dum relation} -body {
        relation union $DUM $DUM
    } -result {{} {}} -match relation

    test relation-union-2.0 {dee relation} -body {
        relation union $DEE $DEE
    } -result {{} {{}}} -match relation

    test relation-union-3.0 {disjoint sets} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}}}
        set r2 {{Name string Age int City string}
            {{Name George Age 20 City {San Jose}}}}
        relation union $r1 $r2
    } -result {
        {Name string Age int City string}
        {
            {Name Andrew Age 30 City Sunnyvale}
            {Name George Age 20 City {San Jose}}
        }
    } -match relation

    test relation-union-4.0 {relations with common tuples} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}}}
        set r2 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}
            {Name George Age 20 City {San Jose}}}}
        relation union $r1 $r2
    } -result {
        {Name string Age int City string}
        {
            {Name Andrew Age 30 City Sunnyvale}
            {Name George Age 20 City {San Jose}}
        }
    } -match relation

    test relation-union-5.0 {union of more than two relations} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}}}
        set r2 {{Name string Age int City string}
            {{Name George Age 20 City {San Jose}}}}
        set r3 {{Name string Age int City string}
            {{Name Fred Age 10 City Saratoga}}}
        relation union $r1 $r2 $r3
    } -result {
        {Name string Age int City string}
        {
            {Name Andrew Age 30 City Sunnyvale}
            {Name George Age 20 City {San Jose}}
            {Name Fred Age 10 City Saratoga}
        }
    } -match relation

    test relation-union-6.0 {union of more than two, common tuples } -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}}}
        set r2 {{Name string Age int City string}
            {{Name George Age 20 City {San Jose}}
            {Name Andrew Age 30 City Sunnyvale}}}
        set r3 {{Name string Age int City string}
            {{Name George Age 20 City {San Jose}}
            {Name Fred Age 10 City Saratoga}}}
        relation union $r1 $r2 $r3
    } -result {
        {Name string Age int City string}
        {
            {Name Andrew Age 30 City Sunnyvale}
            {Name George Age 20 City {San Jose}}
            {Name Fred Age 10 City Saratoga}
        }
    } -match relation

    test relation-union-7.0 {type mismatch} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}}}
        set r2 {{Name string City string}
            {{Name George City {San Jose}}}}
        relation union $r1 $r2
    } -result {headings not equal, "Name string Age int City string != Name string City string"}\
    -returnCodes error

    test relation-union-8.0 {equal headings of different order} -body {
        set r1 {{Name string Age int City string}
            {{Name Andrew Age 30 City Sunnyvale}}}
        set r2 {{Age int Name string City string}
            {{Name George Age 20 City {San Jose}}}}
        relation union $r1 $r2
    } -result {
        {Name string Age int City string}
        {
            {Name Andrew Age 30 City Sunnyvale}
            {Name George Age 20 City {San Jose}}
        }
    } -match relation

    # relation update subcommand
    test relation-update-1.0 {
	expression is false
    } -setup {
        set x [relation create {Name string Status int}\
	    {Name George Status 20}\
	    {Name Fred Status 30}\
	    {Status 40 Name Alice}]
    } -cleanup {
    } -body {
	relation update $x xt {0} {tuple update $xt Status -1}
    } -result {
        {Name string Status int} {
	    {Name George Status 20}
	    {Name Fred Status 30}
	    {Status 40 Name Alice}
        }
    } -match relation

    test relation-update-2.0 {
	expression is true
    } -setup {
        set x [relation create {Name string Status int}\
	    {Name George Status 20}\
	    {Name Fred Status 30}\
	    {Status 40 Name Alice}]
    } -cleanup {
    } -body {
	relation update $x xt {1} {tuple update $xt Status -1}
    } -result {
        {Name string Status int} {
	    {Name George Status -1}
	    {Name Fred Status -1}
	    {Status -1 Name Alice}
        }
    } -match relation

    test relvar-update-3.0 {
	subset is updated
    } -setup {
        set x [relation create {Name string Status int}\
	    {Name George Status 20}\
	    {Name Fred Status 30}\
	    {Status 40 Name Alice}]
    } -cleanup {
    } -body {
	relation update $x xt {[tuple extract $xt Name] eq "George"} {
	    tuple update $xt Status -1
	}
    } -result {
	{Name string Status int} {
	    {Name George Status -1}
	    {Name Fred Status 30}
	    {Status 40 Name Alice}
	}
    } -match relation

    test relvar-update-3.1 {
	subset is updated, original is deleted
    } -setup {
        set x [relation create {Name string Status int}\
	    {Name George Status 20}\
	    {Name Fred Status 30}\
	    {Status 40 Name Alice}]
    } -cleanup {
    } -body {
	set y [relation update $x xt {[tuple extract $xt Name] eq "George"} {
	    tuple update $xt Status -1
	}]
        unset x
        set y
    } -result {
	{Name string Status int} {
	    {Name George Status -1}
	    {Name Fred Status 30}
	    {Status 40 Name Alice}
	}
    } -match relation

    test relvar-update-4.0 {
	wrong tuple from script
    } -setup {
        set x [relation create {Name string Status int}\
	    {Name George Status 20}\
	    {Name Fred Status 30}\
	    {Status 40 Name Alice}]
    } -cleanup {
    } -body {
	relation update $x xt {[tuple extract $xt Name] eq "George"} {
	    tuple eliminate $xt Status
	}
    } -result {headings not equal, "{Name string} {Name George}"} -returnCodes error

    test relvar-update-4.1 {
	script throws error
    } -setup {
        set x [relation create {Name string Status int}\
	    {Name George Status 20}\
	    {Name Fred Status 30}\
	    {Status 40 Name Alice}]
    } -cleanup {
    } -body {
	relation update $x xt {[tuple extract $xt Name] eq "George"} {
            set a 4 3
	}
    } -result {wrong # args: should be "set varName ?newValue?"} -returnCodes error

    test relvar-update-4.2 {
	script throws error
    } -setup {
        set x [relation create {Name string Status int}\
	    {Name George Status 20}\
	    {Name Fred Status 30}\
	    {Status 40 Name Alice}]
    } -cleanup {
    } -body {
	relation update $x xt {[tuple extract $xt Name] eq "George"} {
            set a $xt
            unset xt
	    tuple update $a Status -1
	}
    } -result {
	{Name string Status int} {
	    {Name George Status -1}
	    {Name Fred Status 30}
	    {Status 40 Name Alice}
	}
    } -match relation

    # relation unwrap subcommand
    test relation-unwrap-1.0 {
        no duplicated attributes
    } -body {
        set r {
            {Name string Address {Tuple {City string State string}}} {
                {Name Andrew Address {City Sunnyvale State CA}}
                {Name George Address {City Cleveland State OH}}
                {Name Frank Address {City Seattle State WA}}
            }
        }
        relation unwrap $r Address
    } -result {
        {Name string City string State string}
        {
            {Name Andrew City Sunnyvale State CA}
            {Name George City Cleveland State OH}
            {Name Frank City Seattle State WA}
        }
    } -match relation

    test relation-unwrap-1.1 {
        wrong attribute
    } -body {
        set r {
            {Name string Address {Tuple {City string State string}}} {
                {Name Andrew Address {City Sunnyvale State CA}}
                {Name George Address {City Cleveland State OH}}
                {Name Frank Address {City Seattle State WA}}
            }
        }
        relation unwrap $r Foo
    } -result {unknown attribute name, "Foo"} -returnCodes error

    test relation-unwrap-1.2 {
        duplicate attribute in the result
    } -body {
        set r {
            {Name string State string
                    Address {Tuple {City string State string}}} {
                {Name Andrew State CA Address {City Sunnyvale State CA}}
                {Name George State CA Address {City Cleveland State OH}}
                {Name Frank State CA Address {City Seattle State WA}}
            }
        }
        relation unwrap $r Address
    } -result {duplicate attribute name, "while unwrapping tuple"} -returnCodes error

    # relation wrap subcommand
    test relation-wrap-1.0 {
        wrap multiple attributes
    } -body {
        set r {
            {Name string City string State string} {
                {Name Andrew City Sunnyvale State CA}
                {Name George City Cleveland State OH}
                {Name Frank City Seattle State WA}
            }
        }
        relation wrap $r Address City State
    } -result {
        {Name string Address {Tuple {City string State string}}} {
            {Name Andrew Address {City Sunnyvale State CA}}
            {Name George Address {City Cleveland State OH}}
            {Name Frank Address {City Seattle State WA}}
        }
    } -match relation

    test relation-wrap-2.0 {
        wrap single attribute
    } -body {
        set r {
            {Name string Status int State string} {
                {Name Andrew Status 20 State CA}
                {Name George Status 30 State OH}
                {Name Frank Status 55 State WA}
            }
        }
        relation wrap $r Number Status
    } -result {
        {Name string State string Number {Tuple {Status int}}} {
            {Name Andrew State CA Number {Status 20}}
            {Name George State OH Number {Status 30}}
            {Name Frank State WA Number {Status 55}}
        }
    } -match relation

    test relation-wrap-2.1 {
        wrapped attribute the same as unwrapped attribute
    } -body {
        set r {
            {Name string Status int State string} {
                {Name Andrew Status 20 State CA}
                {Name George Status 30 State OH}
                {Name Frank Status 55 State WA}
            }
        }
        relation wrap $r Status Status
    } -result {
        {Name string State string Status {Tuple {Status int}}} {
            {Name Andrew State CA Status {Status 20}}
            {Name George State OH Status {Status 30}}
            {Name Frank State WA Status {Status 55}}
        }
    } -match relation

    test relation-wrap-3.0 {
        wrap no attribute
    } -body {
        set r {
            {Name string Status int State string} {
                {Name Andrew Status 20 State CA}
                {Name George Status 30 State OH}
                {Name Frank Status 55 State WA}
            }
        }
        relation wrap $r Empty
    } -result {
        {Name string State string Status int Empty {Tuple {}}} {
            {Name Andrew State CA Status 20 Empty {}}
            {Name George State OH Status 30 Empty {}}
            {Name Frank State WA Status 55 Empty {}}
        }
    } -match relation

    test relation-wrap-4.0 {
        unknown attribute to wrap
    } -body {
        set r {
            {Name string City string State string} {
                {Name Andrew City Sunnyvale State CA}
                {Name George City Cleveland State OH}
                {Name Frank City Seattle State WA}
            }
        }
        relation wrap $r Address City State Zip
    } -result {unknown attribute name, "Zip"} -returnCodes error

    test relation-wrap-4.1 {
        duplicate attribute to wrap
    } -body {
        set r {
            {Name string City string State string} {
                {Name Andrew City Sunnyvale State CA}
                {Name George City Cleveland State OH}
                {Name Frank City Seattle State WA}
            }
        }
        relation wrap $r Address City State City
    } -result {duplicate attribute name, "City"} -returnCodes error

    # relvar Tests

    # relvar create subcommand
    test relvar-create-1.0 {
        single attribute
    } -body {
        relvar create N {Name string} Name
    } -cleanup {
        relvar unset N
    } -result {{Name string} {}} -match relation

    test relvar-create-2.0 {
        non-existent namespace
    } -body {
        relvar create ::ral::test::foo::N {Name string} Name
    } -result {can't set "::ral::test::foo::N": parent namespace doesn't exist}\
    -returnCodes error

    test relvar-create-2.1 {
        no such id attribute
    } -body {
        relvar create N {Name string} foo
    } -result {unknown attribute name, "foo"} -returnCodes error

    test relvar-create-2.2 {
        duplicate attribute in an identifier
    } -body {
        relvar create N {Name string} {Name Name}
    } -result {duplicate attribute name in identifier attribute set, "Name Name"} -returnCodes error

    test relvar-create-2.3 {
        identifiers that are subsets of each other
    } -body {
        relvar create N {Name string Address string} Name {Name Address}
    } -result {identifiers must not be subsets of other identifiers, "Name Address"} -returnCodes error

    test relvar-create-2.4 {
        empty list as an identifier
    } -body {
        relvar create N {A1 string B1 int} {}
    } -result {identifiers must have at least one attribute, ""}\
    -returnCodes error

    test relvar-create-2.5 {
        bad list as identifier
    } -body {
        relvar create N {A1 string B1 int} \{
    } -result {unmatched open brace in list}\
    -returnCodes error

    test relvar-create-2.6 {
        duplicate relvar name
    } -cleanup {
        relvar unset N
    } -body {
        relvar create N {Name string} Name
        relvar create N {Addr string} Addr
    } -result {duplicate relvar name, "::ral::test::N"} -returnCodes error

    # relvar names subcommand
    test relvar-names-1.0 {simple list of names} -setup {
        relvar create SV {S# string SNAME string STATUS int CITY string} S#
        relvar create PV\
            {P# string PNAME string COLOR string WEIGHT double CITY string}\
            P#
        relvar create SPV {S# string P# string QTY int} {S# P#}
    } -body {
        lsort [relvar names]
    } -cleanup {
        relvar unset SV PV SPV
    } -result {::ral::test::PV ::ral::test::SPV ::ral::test::SV}

    # relvar path subcommand
    test relvar-path-1.0 {path name} -setup {
        relvar create R {S# string SNAME string STATUS int CITY string} S#
    } -body {
        relvar path R
    } -cleanup {
        relvar unset R
    } -result {::ral::test::R}

    # relvar set subcommand
    test relvar-set-1.0 {simple assignment} -body {
        relvar create SV\
            {S# string SNAME string STATUS int CITY string} S#
        relvar set SV $S
    } -cleanup {
        relvar unset SV
    } -result {
        {S# string SNAME string STATUS int CITY string}
        {
            {S# S1 SNAME Smith STATUS 20 CITY London}
            {S# S2 SNAME Jones STATUS 10 CITY Paris}
            {S# S3 SNAME Blake STATUS 30 CITY Paris}
            {S# S4 SNAME Clark STATUS 20 CITY London}
            {S# S5 SNAME Adams STATUS 30 CITY Athens}
        }
    } -match relation

    test relvar-set-2.0 {name resolution} -setup {
        relvar create ::R {R# string RNAME string} R#
    } -cleanup {
        relvar unset ::R
    } -body {
        relvar set R [relation create {R# string RNAME string}\
            {R# 1 RNAME First}]
        relvar set ::R
    } -result {
        {R# string RNAME string}
        {
            {R# 1 RNAME First}
        }
    } -match relation

    test relvar-set-3.0 {Tcl variable is also modified} -body {
        relvar create SV\
            {S# string SNAME string STATUS int CITY string} S#
        relvar set SV $S
        set SV
    } -cleanup {
        relvar unset SV
    } -result {
        {S# string SNAME string STATUS int CITY string}
        {
            {S# S1 SNAME Smith STATUS 20 CITY London}
            {S# S2 SNAME Jones STATUS 10 CITY Paris}
            {S# S3 SNAME Blake STATUS 30 CITY Paris}
            {S# S4 SNAME Clark STATUS 20 CITY London}
            {S# S5 SNAME Adams STATUS 30 CITY Athens}
        }
    } -match relation

    test relvar-set-4.0 {
        fails identity constraints
    } -setup {
        relvar create ID {Name string Age int} Name
    } -cleanup {
        relvar unset ID
    } -body {
        relvar set ID [relation create\
            {Name string Age int}\
            {Name Andrew Age 30}\
            {Name Andrew Age 32}\
        ]
    } -result {tuple has duplicate values for an identifier, "{Name string Age int} {Name Andrew Age 32}"}\
    -returnCodes error

    test relvar-set-4.1 {
        fails identity constraints -- old value remains
    } -setup {
        relvar create ID {Name string Age int} Name
        relvar set ID [relation create\
            {Name string Age int}\
            {Name Andrew Age 30}\
            {Name George Age 32}\
        ]
    } -cleanup {
        relvar unset ID
    } -body {
        catch {
            relvar set ID [relation create\
                {Name string Age int}\
                {Name Andrew Age 30}\
                {Name Andrew Age 32}]
        }
        relvar set ID
    } -result {
            {Name string Age int} {
                {Name Andrew Age 30}
                {Name George Age 32}
            }
    } -match relation

    # relvar restrictone subcommand
    test relvar-restrictone-1.0 {
        find one tuple
    } -setup {
        relvar create X {Name string Status int} Name
        relvar set X [relation create {Name string Status int}\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}]
    } -cleanup {
        relvar unset X
    } -body {
        relation cardinality [relvar restrictone X Name George]
    } -result 1

    test relvar-restrictone-1.1 {
        fail to find tuple
    } -setup {
        relvar create X {Name string Status int} Name
        relvar set X [relation create {Name string Status int}\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}]
    } -cleanup {
        relvar unset X
    } -body {
        relation cardinality [relvar restrictone X Name Foo]
    } -result 0

    test relvar-restrictone-1.2 {
        Compare integer values
    } -setup {
        relvar create X {Name string Status int} Status
        relvar set X [relation create {Name string Status int}\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}]
    } -cleanup {
        relvar unset X
    } -body {
        relation cardinality [relvar restrictone X Status 0x14]
    } -result 1

    test relvar-restrictone-2.1 {
        bad input name / value pairs
    } -setup {
        relvar create X {Name string Status int} Name
        relvar set X [relation create {Name string Status int}\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}]
    } -cleanup {
        relvar unset X
    } -body {
        relation cardinality [relvar restrictone X Name]
    } -result {wrong # args: should be "relvar restrictone relvarValue attr value ?attr2 value 2 ...?"} -returnCodes error

    test relvar-restrictone-2.2 {
        unknown attribute
    } -setup {
        relvar create X {Name string Status int} Name
        relvar set X [relation create {Name string Status int}\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}]
    } -cleanup {
        relvar unset X
    } -body {
        relation cardinality [relvar restrictone X Foo 1]
    } -result {unknown attribute name, "Foo"} -returnCodes error

    test relvar-restrictone-2.3 {
        not an identifier
    } -setup {
        relvar create X {Name string Status int} Name
        relvar set X [relation create {Name string Status int}\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}]
    } -cleanup {
        relvar unset X
    } -body {
        relation cardinality [relvar restrictone X Status 16]
    } -result {attributes do not constitute an identifier, "during identifier construction operation"} -returnCodes error

    # relvar union subcommand
    test relvar-union-1.0 {union single relation} -setup {
        relvar create X {Name string Status int} Name
        relvar set X [relation create {Name string Status int}\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}]
    } -cleanup {
        relvar unset X
    } -body {
        set x [relation create\
            {Name string Status int}\
            {Name George Status 20}\
            {Status 40 Name Alice}\
            {Name Allen Status 95}\
        ]
        relvar union X $x
    } -result {
        {Name string Status int}
        {
            {Name George Status 20}
            {Name Fred Status 30}
            {Status 40 Name Alice}
            {Name Allen Status 95}
        }
    } -match relation

    test relvar-union-1.1 {check Tcl variable} -setup {
        relvar create X {Name string Status int} Name
        relvar set X [relation create\
            {Name string Status int}\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}]
    } -cleanup {
        relvar unset X
    } -body {
        set x [relation create\
            {Name string Status int}\
            {Name George Status 20}\
            {Status 40 Name Alice}\
            {Name Allen Status 95}\
        ]
        relvar union X $x
        set X
    } -result {
        {Name string Status int}
        {
            {Name George Status 20}
            {Name Fred Status 30}
            {Status 40 Name Alice}
            {Name Allen Status 95}
        }
    } -match relation

    test relvar-union-1.2 {union multiple relations} -setup {
        relvar create X {Name string Status int} Name
        relvar set X [relation create\
            {Name string Status int}\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}]
    } -cleanup {
        relvar unset X
    } -body {
        set x [relation create\
            {Name string Status int}\
            {Name George Status 20}\
            {Status 40 Name Alice}\
            {Name Allen Status 95}\
        ]
        set y [relation create\
            {Name string Status int}\
            {Name Jean Status 22}\
            {Name John Status 28}\
        ]
        relvar union X $x $y
    } -result {
        {Name string Status int}
        {
            {Name George Status 20}
            {Name Fred Status 30}
            {Status 40 Name Alice}
            {Name Allen Status 95}
            {Name Jean Status 22}
            {Name John Status 28}
        }
    } -match relation

    test relvar-union-1.3 {
        different header order
    } -setup {
        relvar create X {Name string Status int} Name
        relvar set X [relation create\
            {Name string Status int}\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}]
    } -cleanup {
        relvar unset X
    } -body {
        set x [relation create\
            {Status int Name string}\
            {Name George Status 20}\
            {Status 40 Name Alice}\
            {Name Allen Status 95}\
        ]
        relvar union X $x
    } -result {
        {Name string Status int}
        {
            {Name George Status 20}
            {Name Fred Status 30}
            {Status 40 Name Alice}
            {Name Allen Status 95}
        }
    } -match relation

    test relvar-union-2.0 {incompatible union} -setup {
        relvar create X {Name string Status int} Name
        relvar set X [relation create\
            {Name string Status int}\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}]
    } -cleanup {
        relvar unset X
    } -body {
        set x [relation create {Name string} {Name George}]
        relvar union X $x
    } -result {headings not equal, "Name string Status int != Name string"}\
    -returnCodes error

    test relvar-union-2.1 {
        error: wrong args
    } -body {
        relvar union
    } -result {wrong # args: should be "relvar union relvarName ?relationValue ...?"}\
    -returnCodes error

    test relvar-union-2.2 {
        union with non relation type
    } -setup {
        relvar create X {Name string Status int} Name
        relvar set X [relation create\
            {Name string Status int}\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}]
    } -cleanup {
        relvar unset X
    } -body {
        relvar union X 27
    } -result {bad value format, "27"} -returnCodes error

    test relvar-union-2.3 {
        union results in identity constraint failure
    } -setup {
        relvar create X {Name string Status int} Name
        relvar set X [relation create\
            {Name string Status int}\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}]
    } -cleanup {
        relvar unset X
    } -body {
        set x [relation create\
            {Status int Name string}\
            {Name George Status 30}\
            {Status 40 Name Alice}\
            {Name Allen Status 95}\
        ]
        relvar union X $x
    } -result {tuple has duplicate values for an identifier, "{Name string Status int} {Name George Status 30}"}\
    -returnCodes error

    # relvar intersect subcommand
    test relvar-intersect-1.0 {intersect single relation} -setup {
        relvar create X {Name string Status int} Name
        relvar set X [relation create\
            {Name string Status int}\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}]
    } -cleanup {
        relvar unset X
    } -body {
        set x [relation create\
            {Name string Status int}\
            {Name George Status 20}\
            {Status 40 Name Alice}\
            {Name Allen Status 95}\
        ]
        relvar intersect X $x
    } -result {
        {Name string Status int}
        {
            {Name George Status 20}
            {Name Alice Status 40}
        }
    } -match relation

    # relvar minus subcommand
    test relvar-minus-1.0 {subtract single relation} -setup {
        relvar create X {Name string Status int} Name
        relvar set X [relation create\
            {Name string Status int}\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}]
    } -cleanup {
        relvar unset X
    } -body {
        set x [relation create\
            {Name string Status int}\
            {Name George Status 20}\
            {Status 40 Name Alice}\
            {Name Allen Status 95}\
        ]
        relvar minus X $x
    } -result {
        {Name string Status int}
        {
            {Name Fred Status 30}
        }
    } -match relation

    # relvar insert subcommand
    test relvar-insert-1.0 {insert single tuple} -setup {
        relvar create N {Name string Age int City string} Name
    } -cleanup {
        relvar unset N
    } -body {
        relvar insert N {Name Andrew Age 20 City Sunnyvale}
    } -result {
        {Name string Age int City string} {
            {Name Andrew Age 20 City Sunnyvale}
        }
    } -match relation

    test relvar-insert-2.0 {insert multiple tuples} -setup {
        relvar create N {Name string Age int City string} Name
    } -cleanup {
        relvar unset N
    } -body {
        relvar insert N\
            {Name Andrew Age 20 City Sunnyvale}\
            {Age 20 Name George City {San Jose}}\
            {Name Fred City Saratoga Age 20}
    } -result {
        {Name string Age int City string}
        {
            {Name Andrew Age 20 City Sunnyvale}
            {Name George Age 20 City {San Jose}}
            {Name Fred Age 20 City Saratoga}
        }
    } -match relation

    test relvar-insert-2.1 {
        return value is what is inserted.
    } -setup {
        relvar create N {Name string Age int City string} Name
        relvar insert N\
            {Name Andrew Age 20 City Sunnyvale}\
            {Age 20 Name George City {San Jose}}
    } -cleanup {
        relvar unset N
    } -body {
        relvar insert N\
            {Name Fred City Saratoga Age 20}
    } -result {
        {Name string Age int City string}
        {
            {Name Fred Age 20 City Saratoga}
        }
    } -match relation

    test relvar-insert-3.0 {duplicate tuple} -setup {
        relvar create N {Name string Age int City string} Name
    } -cleanup {
        relvar unset N
    } -body {
        relvar insert N\
            {Name Andrew Age 20 City Sunnyvale}\
            {Age 20 Name George City {San Jose}}\
            {Name Andrew City Sunnyvale Age 20}
    } -result {duplicate tuple, "{Name string City string Age int} {Name Andrew City Sunnyvale Age 20}"}\
    -returnCodes error

    test relvar-insert-4.0 {value preserved on error} -setup {
        relvar create N {Name string Age int City string} Name
        relvar insert N\
            {Name Andrew Age 20 City Sunnyvale}\
            {Age 20 Name George City {San Jose}}\
            {Name Fred City Saratoga Age 20}
    } -cleanup {
        relvar unset N
    } -body {
        catch {relvar insert N {Name Andrew Age 20 City Sunnyvale}}
        relvar set N
    } -result {
        {Name string Age int City string}
        {
            {Name Andrew Age 20 City Sunnyvale}
            {Name George Age 20 City {San Jose}}
            {Name Fred Age 20 City Saratoga}
        }
    } -match relation

    test relvar-insert-5.0 {
        empty value for type
    } -setup {
        relvar create N {Name string Age int City string} Name
    } -cleanup {
        relvar unset N
    } -body {
        relvar insert N {Name Andrew Age {} City Sunnyvale}
    } -result {
        {Name string Age int City string}
        {
            {Name Andrew Age {} City Sunnyvale}
        }
    } -match relation

    test relvar-insert-5.1 {
        trace returns incorrect heading
    } -setup {
        proc insertTrace {op relvar tuple} {
            return [tuple create {Name string Status int} {Name foo Status 20}]
        }
        relvar create N {Name string Age int City string} Name
        relvar trace add variable N insert insertTrace
    } -cleanup {
        relvar unset N
        rename insertTrace {}
    } -body {
        relvar insert N {Name Andrew Age 33 City Sunnyvale}
    } -result {headings not equal, "{Name string Status int} {Name foo Status 20}"} -returnCodes error

    test relvar-insert-5.2 {
        trace changes heading order
    } -setup {
        proc insertTrace {op relvar tuple} {
            return [tuple create {City string Age int Name string}\
                    {Age 20 City Sunnyvale Name Fred}]
        }
        relvar create N {Name string Age int City string} Name
        relvar trace add variable N insert insertTrace
    } -cleanup {
        relvar unset N
        rename insertTrace {}
    } -body {
        relvar insert N {Name Andrew Age 33 City Sunnyvale}
    } -result {
        {Name string Age int City string} {
            {Name Fred Age 20 City Sunnyvale}
        }
    } -match relation

    test relvar-insert-5.3 {
        trace adds an attribute
    } -setup {
        proc insertTrace {op relvar tuple} {
            return [tuple extend $tuple Age int 33]
        }
        relvar create N {Name string Age int City string} Name
        relvar trace add variable N insert insertTrace
    } -cleanup {
        relvar unset N
        rename insertTrace {}
    } -body {
        relvar insert N {Name Andrew City Sunnyvale}
    } -result {
        {Name string Age int City string} {
            {Name Andrew Age 33 City Sunnyvale}
        }
    } -match relation

    # relvar delete subcommand
    test relvar-delete-1.0 {expression is false} -setup {
        relvar create X {Name string Status int} Name
        relvar insert X\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}
    } -cleanup {
        relvar unset X
    } -body {
        relvar delete X t {0}
    } -result {0}

    test relvar-delete-2.0 {expression is true} -setup {
        relvar create X {Name string Status int} Name
        relvar insert X\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}
    } -cleanup {
        relvar unset X
    } -body {
        relvar delete X t {1}
    } -result {3}

    test relvar-delete-3.0 {subset is deleted} -setup {
        relvar create X {Name string Status int} Name
        relvar insert X\
            {Name Fred Status 30}\
            {Name George Status 20}\
            {Status 40 Name Alice}
    } -cleanup {
        relvar unset X
    } -body {
        relvar delete X t {[tuple extract $t Name] eq "George"}
    } -result {1}

    test relvar-delete-3.1 {
        subset is deleted -- correct relation remains
    } -setup {
        relvar create X {Name string Status int} Name
        relvar insert X\
            {Name Fred Status 30}\
            {Name George Status 20}\
            {Status 40 Name Alice}
    } -cleanup {
        relvar unset X
    } -body {
        relvar delete X t {[tuple extract $t Name] eq "George"}
        relvar set X
    } -result {
        {Name string Status int} {
            {Status 40 Name Alice}
            {Name Fred Status 30}
        }
    } -match relation

    # relvar deleteone subcommand
    test relvar-deleteone-1.0 {
        no match
    } -setup {
        relvar create X {Name string Status int} Name
        relvar insert X\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}
    } -cleanup {
        relvar unset X
    } -body {
        relvar deleteone X Name Jane
    } -result {0}

    test relvar-deleteone-2.0 {
        match
    } -setup {
        relvar create X {Name string Status int} Name
        relvar insert X\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}
    } -cleanup {
        relvar unset X
    } -body {
        relvar deleteone X Name Fred
    } -result {1}

    test relvar-deleteone-3.0 {
        bad identifier
    } -setup {
        relvar create X {Name string Status int} Name
        relvar insert X\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}
    } -cleanup {
        relvar unset X
    } -body {
        relvar deleteone X Status 30
    } -result {attributes do not constitute an identifier, "during identifier construction operation"}\
    -returnCodes error

    test relvar-deleteone-3.1 {
        unknown attribute
    } -setup {
        relvar create X {Name string Status int} Name
        relvar insert X\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}
    } -cleanup {
        relvar unset X
    } -body {
        relvar deleteone X Address 30
    } -result {unknown attribute name, "Address"} -returnCodes error

    test relvar-deleteone-3.2 {
        bad attribute value
    } -setup {
        relvar create X {Name string Status int} Status
        relvar insert X\
            {Name George Status 20}\
            {Name Fred Status 30}\
            {Status 40 Name Alice}
    } -cleanup {
        relvar unset X
    } -body {
        relvar deleteone X Status foo
    } -result {bad value type for value, "foo"} -returnCodes error

    test relvar-deleteone-4.0 {
        deleting and iterating on same relvar
    } -setup {
        relvar create Foo {A string B int} A
        relvar insert Foo {
            A a1 B 1
        } {
            A a2 B 2
        } {
            A a3 B 3
        }
    } -cleanup {
        relvar unset Foo
    } -body {
        set aValues [list]
        relation foreach f [relvar set Foo] {
            lappend aValues [relation extract $f A]
            relvar deleteone Foo A [relation extract $f A]
        }
        set aValues
    } -result {a1 a2 a3}

    test relvar-deleteone-4.1 {
        deleting and iterating on same relvar
    } -setup {
        relvar create Foo {A string B int} A
        relvar insert Foo {
            A a1 B 1
        } {
            A a2 B 2
        } {
            A a3 B 3
        }
    } -cleanup {
        relvar unset Foo
    } -body {
        relation foreach f [relvar set Foo] {
            lappend aValues [relation extract $f A]
            relvar deleteone Foo A [relation extract $f A]
        }
        relation list [relvar set Foo] A
    } -result {}

    # relvar eval subcommand
    test relvar-eval-1.0 {simple body} -setup {
        relvar create SV {S# string SNAME string STATUS int CITY string} S#
    } -body {
        relvar eval {
            relvar set SV $S
        }
    } -cleanup {
        relvar unset SV
    } -result {
        {S# string SNAME string STATUS int CITY string} {
            {S# S1 SNAME Smith STATUS 20 CITY London}
            {S# S2 SNAME Jones STATUS 10 CITY Paris}
            {S# S3 SNAME Blake STATUS 30 CITY Paris}
            {S# S4 SNAME Clark STATUS 20 CITY London}
            {S# S5 SNAME Adams STATUS 30 CITY Athens}
        }
    } -match relation

    test relvar-eval-1.1 {break out of eval} -setup {
        relvar create SV {S# string SNAME string STATUS int CITY string} S#
    } -body {
        while 1 {
            relvar eval {
                relvar insert SV {S# S1 SNAME Smith STATUS 20 CITY London}
                if {[catch {relvar insert SV\
                    {S# S1 SNAME Smith STATUS 20 CITY London}}]} {
                    break ;
                }
            }
        }
        set SV
    } -cleanup {
        relvar unset SV
    } -result {
        {S# string SNAME string STATUS int CITY string} {
            {S# S1 SNAME Smith STATUS 20 CITY London}
        }
    } -match relation

    test relvar-eval-1.2 {continue out of eval} -setup {
        relvar create SV {S# string SNAME string STATUS int CITY string} S#
    } -body {
        set id 0
        foreach status {10 20 30} {
            relvar eval {
                if {$status == 20} {
                    continue ;
                }
                relvar insert SV [list\
                    S# S[incr id] SNAME Smith STATUS $status CITY London\
                ]
            }
        }
        set SV
    } -cleanup {
        relvar unset SV
    } -result {
        {S# string SNAME string STATUS int CITY string} {
            {S# S1 SNAME Smith STATUS 10 CITY London}
            {S# S2 SNAME Smith STATUS 30 CITY London}
        }
    } -match relation

    test relvar-eval-1.3 {return out of eval} -setup {
        relvar create SV {S# string SNAME string STATUS int CITY string} S#
    } -body {
        while 1 {
            relvar eval {
                relvar insert SV {S# S1 SNAME Smith STATUS 20 CITY London}
                if {[catch {relvar insert SV\
                    {S# S1 SNAME Smith STATUS 20 CITY London}}]} {
                    return $SV
                }
            }
        }
    } -cleanup {
        relvar unset SV
    } -result {
        {S# string SNAME string STATUS int CITY string} {
            {S# S1 SNAME Smith STATUS 20 CITY London}
        }
    } -match relation

    # relvar transaction tests
    test relvar-transaction-1.0 {
        ending a transaction that was not begun
    } -body {
        relvar transaction end
    } -result {end transaction with no beginning} -returnCodes error

    # relvar association subcommand
    test relvar-association-1.1 {one to one} -setup {
        relvar create A {A1 string A2 int} A1
        relvar create B {B1 string B2 string} B1
        relvar association R1 A A1 1 B B1 1
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B
    } -body {
        relvar eval {
            relvar insert A {A1 a A2 42}
            relvar insert A {A1 b A2 42}
            relvar insert B {B1 a B2 foo}
            relvar insert B {B1 b B2 foo}
        }
        return
    } -result {}

    test relvar-association-1.2 {one to one -- fail referring} -setup {
        relvar create A {A1 string A2 int} A1
        relvar create B {B1 string B2 string} B1
        relvar association R1 A A1 1 B B1 1
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B
    } -body {
        relvar eval {
            relvar insert A {A1 a A2 42}
            relvar insert A {A1 b A2 42}
            relvar insert B {B1 a B2 foo}
        }
        return
    } -result {for association ::ral::test::R1(::ral::test::A [1] ==> [1] ::ral::test::B), in relvar ::ral::test::A
tuple {A1 b A2 42} references no tuple
} -returnCodes error

    test relvar-association-1.3 {one to one -- fail referred to} -setup {
        relvar create A {A1 string A2 int} A1
        relvar create B {B1 string B2 string} B1
        relvar association R1 A A1 1 B B1 1
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B
    } -body {
        relvar eval {
            relvar insert A {A1 a A2 42}
            relvar insert B {B1 a B2 foo}
            relvar insert B {B1 b B2 bar}
        }
        return
    } -result {for association ::ral::test::R1(::ral::test::A [1] ==> [1] ::ral::test::B), in relvar ::ral::test::B
tuple {B1 b B2 bar} is not referenced by any tuple
} -returnCodes error

    test relvar-association-2.1 {one conditional to one} -setup {
        relvar create C {C1 string C2 int} C1
        relvar create D {D1 string D2 string} D1
        relvar association R2 C C1 ? D D1 1
    } -cleanup {
        relvar constraint delete R2
        relvar unset C D
    } -body {
        relvar eval {
            relvar insert C {C1 a C2 42}
            relvar insert C {C1 b C2 42}
            relvar insert D {D1 a D2 foo}
            relvar insert D {D1 b D2 foo}
            relvar insert D {D1 c D2 foo}
        }
        return
    } -result {}

    test relvar-association-2.2 {one conditional to one -- fail} -setup {
        relvar create C {C1 string C2 int} C1
        relvar create D {D1 string D2 string} D1
        relvar association R2 C C1 ? D D1 1
    } -cleanup {
        relvar constraint delete R2
        relvar unset C D
    } -body {
        relvar eval {
            relvar insert C {C1 a C2 42}
            relvar insert C {C1 c C2 42}
            relvar insert D {D1 a D2 foo}
            relvar insert D {D1 b D2 foo}
        }
    } -result {for association ::ral::test::R2(::ral::test::C [?] ==> [1] ::ral::test::D), in relvar ::ral::test::C
tuple {C1 c C2 42} references no tuple
} -returnCodes error

    test relvar-association-3.1 {one conditional to one conditional} -setup {
        relvar create C {C1 string C2 int} C1
        relvar create D {D1 string D2 string} D1
        relvar association R2 C C1 ? D D1 ?
    } -cleanup {
        relvar constraint delete R2
        relvar unset C D
    } -body {
        relvar eval {
            relvar insert C {C1 a C2 42}
            relvar insert C {C1 c C2 22}
            relvar insert D {D1 a D2 foo}
            relvar insert D {D1 b D2 bar}
        }
        return
    } -result {}

    test relvar-association-4.1 {many to one} -setup {
        relvar create A {A1 string BID string} A1
        relvar create B {B1 string B2 string} B1
        relvar association R1 A BID + B B1 1
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B
    } -body {
        relvar eval {
            relvar insert A {A1 a BID a}
            relvar insert A {A1 b BID b}
            relvar insert A {A1 c BID a}
            relvar insert A {A1 d BID b}
            relvar insert B {B1 a B2 foo}
            relvar insert B {B1 b B2 foo}
        }
    } -result {{B1 string B2 string} {{B1 b B2 foo}}} -match relation

    test relvar-association-4.2 {many to one -- fail referring} -setup {
        relvar create A {A1 string BID string} A1
        relvar create B {B1 string B2 string} B1
        relvar association R1 A BID + B B1 1
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B
    } -body {
        relvar eval {
            relvar insert A {A1 a BID a}
            relvar insert A {A1 b BID b}
            relvar insert A {A1 c BID a}
            relvar insert A {A1 d BID c}
            relvar insert B {B1 a B2 foo}
            relvar insert B {B1 b B2 foo}
        }
    } -result {for association ::ral::test::R1(::ral::test::A [+] ==> [1] ::ral::test::B), in relvar ::ral::test::A
tuple {A1 d BID c} references no tuple
} -returnCodes error

    test relvar-association-4.3 {many to one -- fail referred to} -setup {
        relvar create A {A1 string BID string} A1
        relvar create B {B1 string B2 string} B1
        relvar association R1 A BID + B B1 1
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B
    } -body {
        relvar eval {
            relvar insert A {A1 a BID a}
            relvar insert A {A1 b BID b}
            relvar insert A {A1 c BID a}
            relvar insert A {A1 d BID b}
            relvar insert B {B1 a B2 foo}
            relvar insert B {B1 b B2 foo}
            relvar insert B {B1 c B2 foo}
        }
    } -result {for association ::ral::test::R1(::ral::test::A [+] ==> [1] ::ral::test::B), in relvar ::ral::test::B
tuple {B1 c B2 foo} is not referenced by any tuple
} -returnCodes error

    test relvar-association-5.1 {many conditional to one} -setup {
        relvar create A {A1 string BID string} A1
        relvar create B {B1 string B2 string} B1
        relvar association R1 A BID * B B1 1
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B
    } -body {
        relvar eval {
            relvar insert A {A1 a BID a}
            relvar insert A {A1 b BID b}
            relvar insert A {A1 c BID a}
            relvar insert A {A1 d BID b}
            relvar insert B {B1 a B2 foo}
            relvar insert B {B1 b B2 foo}
            relvar insert B {B1 c B2 foo}
        }
        return
    } -result {}

    test relvar-association-5.2 {many to one conditional} -setup {
        relvar create A {A1 string BID string} A1
        relvar create B {B1 string B2 string} B1
        relvar association R1 A BID + B B1 ?
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B
    } -body {
        relvar eval {
            relvar insert A {A1 a BID a}
            relvar insert A {A1 b BID b}
            relvar insert A {A1 c BID a}
            relvar insert A {A1 d BID b}
            relvar insert A {A1 e BID {}}
            relvar insert B {B1 a B2 foo}
            relvar insert B {B1 b B2 foo}
        }
        return
    } -result {}

    test relvar-association-5.3 {many conditional to one conditional} -setup {
        relvar create A {A1 string BID string} A1
        relvar create B {B1 string B2 string} B1
        relvar association R1 A BID * B B1 ?
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B
    } -body {
        relvar eval {
            relvar insert A {A1 a BID a}
            relvar insert A {A1 b BID b}
            relvar insert A {A1 c BID a}
            relvar insert A {A1 d BID b}
            relvar insert A {A1 e BID {}}
            relvar insert B {B1 a B2 foo}
            relvar insert B {B1 b B2 foo}
            relvar insert B {B1 c B2 foo}
        }
    } -result {{B1 string B2 string} {{B1 c B2 foo}}} -match relation

    test relvar-association-5.4 {many to one conditional, empty one} -setup {
        relvar create A {A1 string BID string} A1
        relvar create B {B1 string B2 string} B1
        relvar association R1 A BID + B B1 ?
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B
    } -body {
        relvar eval {
            relvar insert A {A1 a BID a}
            relvar insert A {A1 b BID b}
        }
        return
    } -result {}

    test relvar-association-5.5 {many conditional to one , empty many} -setup {
        relvar create A {A1 string BID string} A1
        relvar create B {B1 string B2 string} B1
        relvar association R1 A BID * B B1 1
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B
    } -body {
        relvar eval {
            relvar insert B {B1 a B2 foo}
            relvar insert B {B1 b B2 foo}
            relvar insert B {B1 c B2 foo}
        }
        return
    } -result {}

    test relvar-association-6.1 {duplicate names} -setup {
        relvar create A {A1 string BID string} A1
        relvar create B {B1 string B2 string} B1
    } -body {
        relvar association R1 A BID * B B1 ?
        relvar association R1 A BID * B B1 ?
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B
    } -result {duplicate constraint name, "::ral::test::R1"} -returnCodes error

    test relvar-association-6.2 {bad cond / mult spec} -setup {
        relvar create A {A1 string BID string} A1
        relvar create B {B1 string B2 string} B1
    } -body {
        relvar association R1 A BID X B B1 ?
    } -cleanup {
        relvar unset A B
    } -result {bad multiplicity specification "X": must be 1, +, ?, or *} -returnCodes error

    test relvar-association-6.3 {bad multiplicity} -setup {
        relvar create A {A1 string BID string} A1
        relvar create B {B1 string B2 string} B1
    } -body {
        relvar association R1 A BID * B B1 *
    } -cleanup {
        relvar unset A B
    } -result {referred to identifiers can not have non-singular multiplicities, "*"} -returnCodes error

    test relvar-association-7.1 {ordering in compound identifiers} -setup {
        relvar create A {A1 string B1ID string B2ID string} A1
        relvar create B {B1 string B2 string} {B1 B2}
        relvar association R1 A {B2ID B1ID} + B {B2 B1} 1
    } -body {
        relvar eval {
            relvar insert A {A1 a1 B1ID b1 B2ID b2}
            relvar insert B {B1 b1 B2 b2}
        }
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B
    } -result {{B1 string B2 string} {{B1 b1 B2 b2}}} -match relation

    test relvar-association-8.1 {failure at creation time} -setup {
        relvar create C {C1 string C2 int} C1
        relvar create D {D1 string D2 string} D1
        relvar insert C {C1 a C2 42}
        relvar insert C {C1 c C2 42}
        relvar insert D {D1 a D2 foo}
        relvar insert D {D1 b D2 foo}
    } -cleanup {
        relvar unset C D
    } -body {
        relvar association R2 C C1 ? D D1 1
    } -result {for association ::ral::test::R2(::ral::test::C [?] ==> [1] ::ral::test::D), in relvar ::ral::test::C
tuple {C1 c C2 42} references no tuple
} -returnCodes error

    # relvar constraint subcommand
    test relvar-constraint-1.1 {constraint names} -setup {
        relvar create A {A1 string BID1 string BID2 int} A1
        relvar create B {B1 string B2 int} B1 B2
        relvar association R3 A BID1 * B B1 ?
        relvar association R4 A BID2 * B B2 ?
    } -cleanup {
        relvar constraint delete R3 R4
        relvar unset A B
    } -body {
        lsort [relvar constraint names]
    } -result {::ral::test::R3 ::ral::test::R4}

    test relvar-constraint-2.1 {constraint info -- association} -setup {
        relvar create A {A1 string BID1 string BID2 int} A1
        relvar create B {B1 string B2 int} B1 B2
        relvar association R3 A BID1 * B B1 ?
    } -cleanup {
        relvar constraint delete R3
        relvar unset A B
    } -body {
        relvar constraint info R3
    } -result {association ::ral::test::R3 ::ral::test::A BID1 * ::ral::test::B B1 ?}

    test relvar-constraint-2.2 {constraint info -- partition} -setup {
        relvar create A {A1 string} A1
        relvar create B {B1 string} B1
        relvar create C {C1 string} C1
        relvar partition R1 A A1 B B1 C C1
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B C
    } -body {
        relvar constraint info R1
    } -result {partition ::ral::test::R1 ::ral::test::A A1 ::ral::test::B B1 ::ral::test::C C1}

    test relvar-constraint-2.3 {constraint info -- correlation} -setup {
        relvar create A {X1 string Y1 string} X1 Y1
        relvar create X {X1 string} X1
        relvar create Y {Y1 string} Y1
        relvar correlation R1 A X1 + X X1 Y1 * Y Y1
    } -cleanup {
        relvar constraint delete R1
        relvar unset A X Y
    } -body {
        relvar constraint info R1
    } -result {correlation ::ral::test::R1 ::ral::test::A X1 + ::ral::test::X X1 Y1 * ::ral::test::Y Y1}

    test relvar-constraint-3.1 {constraint member} -setup {
        relvar create A {X1 string Y1 string} X1 Y1
        relvar create X {X1 string} X1
        relvar create Y {Y1 string} Y1
        relvar correlation R1 A X1 + X X1 Y1 * Y Y1
    } -cleanup {
        relvar constraint delete R1
        relvar unset A X Y
    } -body {
        relvar constraint member A
    } -result {::ral::test::R1}

    # relvar correlation subcommand
    test relvar-correlation-1.1 {many to many} -setup {
        relvar create A {A1 int X_ID string Y_ID string} {X_ID Y_ID}
        relvar create X {X_ID string X2 string} X_ID
        relvar create Y {Y_ID string Y2 string} Y_ID
        relvar correlation R1 A X_ID + X X_ID Y_ID + Y Y_ID
    } -cleanup {
        relvar constraint delete R1
        relvar unset A X Y
    } -body {
        relvar eval {
            relvar insert X {X_ID x1 X2 one}
            relvar insert X {X_ID x2 X2 two}
            relvar insert Y {Y_ID y1 Y2 one}
            relvar insert Y {Y_ID y2 Y2 two}
            relvar insert A {A1 1 X_ID x1 Y_ID y1}
            relvar insert A {A1 1 X_ID x1 Y_ID y2}
            relvar insert A {A1 2 X_ID x2 Y_ID y1}
        }
        return
    } -result {}

    test relvar-correlation-1.2 {many to many complete} -setup {
        relvar create A {A1 int X_ID string Y_ID string} {X_ID Y_ID}
        relvar create X {X_ID string X2 string} X_ID
        relvar create Y {Y_ID string Y2 string} Y_ID
        relvar correlation -complete R1 A X_ID + X X_ID Y_ID + Y Y_ID
    } -cleanup {
        relvar constraint delete R1
        relvar unset A X Y
    } -body {
        relvar eval {
            relvar insert X {X_ID x1 X2 one}
            relvar insert X {X_ID x2 X2 two}
            relvar insert Y {Y_ID y1 Y2 one}
            relvar insert Y {Y_ID y2 Y2 two}
            relvar insert A {A1 1 X_ID x1 Y_ID y1}
            relvar insert A {A1 1 X_ID x1 Y_ID y2}
            relvar insert A {A1 2 X_ID x2 Y_ID y1}
            relvar insert A {A1 2 X_ID x2 Y_ID y2}
        }
        return
    } -result {}

    test relvar-correlation-1.3 {many to many complete -- failure} -setup {
        relvar create A {A1 int X_ID string Y_ID string} {X_ID Y_ID}
        relvar create X {X_ID string X2 string} X_ID
        relvar create Y {Y_ID string Y2 string} Y_ID
        relvar correlation -complete R1 A X_ID + X X_ID Y_ID + Y Y_ID
    } -cleanup {
        relvar constraint delete R1
        relvar unset A X Y
    } -body {
        relvar eval {
            relvar insert X {X_ID x1 X2 one}
            relvar insert X {X_ID x2 X2 two}
            relvar insert Y {Y_ID y1 Y2 one}
            relvar insert Y {Y_ID y2 Y2 two}
            relvar insert A {A1 1 X_ID x1 Y_ID y1}
            relvar insert A {A1 2 X_ID x2 Y_ID y1}
            relvar insert A {A1 2 X_ID x2 Y_ID y2}
        }
        return
    } -result {correlation ::ral::test::R1(::ral::test::X <== [+] ::ral::test::A (Complete) [+] ==> ::ral::test::Y) does not form a complete correlation}\
    -returnCodes error

    test relvar-correlation-2.1 {1 to 1} -setup {
        relvar create A {A1 int X_ID string Y_ID string} {X_ID Y_ID}
        relvar create X {X_ID string X2 string} X_ID
        relvar create Y {Y_ID string Y2 string} Y_ID
        relvar correlation R1 A X_ID 1 X X_ID Y_ID 1 Y Y_ID
    } -cleanup {
        relvar constraint delete R1
        relvar unset A X Y
    } -body {
        relvar eval {
            relvar insert X {X_ID x1 X2 one}
            relvar insert X {X_ID x2 X2 two}
            relvar insert Y {Y_ID y1 Y2 one}
            relvar insert Y {Y_ID y2 Y2 two}
            relvar insert A {A1 1 X_ID x1 Y_ID y2}
            relvar insert A {A1 2 X_ID x2 Y_ID y1}
        }
        return
    } -result {}

    test relvar-correlation-1.1 {many to many conditional} -setup {
        relvar create A {A1 int X_ID string Y_ID string} {X_ID Y_ID}
        relvar create X {X_ID string X2 string} X_ID
        relvar create Y {Y_ID string Y2 string} Y_ID
        relvar correlation R1 A X_ID * X X_ID Y_ID + Y Y_ID
    } -cleanup {
        relvar constraint delete R1
        relvar unset A X Y
    } -body {
        relvar eval {
            relvar insert X {X_ID x1 X2 one}
            relvar insert X {X_ID x2 X2 two}
            relvar insert Y {Y_ID y1 Y2 one}
            relvar insert Y {Y_ID y2 Y2 two}
            relvar insert A {A1 1 X_ID x1 Y_ID y1}
            relvar insert A {A1 1 X_ID x1 Y_ID y2}
        }
        return
    } -result {}

    # relvar partition subcommand
    test relvar-partition-1.1 {simple partition} -setup {
        relvar create A {A1 string} A1
        relvar create B {B1 string} B1
        relvar create C {C1 string} C1
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B C
    } -body {
        relvar partition R1 A A1 B B1 C C1
    } -result {}

    test relvar-partition-1.2 {unknown relvar} -setup {
        relvar create A {A1 string} A1
        relvar create B {B1 string} B1
    } -cleanup {
        relvar unset A B
    } -body {
        relvar partition R1 A A1 B B1 C C1
    } -result {unknown relvar name, "C"} -returnCodes error

    test relvar-partition-1.3 {unknown attribute} -setup {
        relvar create A {A1 string} A1
        relvar create B {B1 string} B1
        relvar create C {C1 string} C1
    } -cleanup {
        relvar unset A B C
    } -body {
        relvar partition R1 A A1 B B1 C C2
    } -result {unknown attribute name, "C2"} -returnCodes error

    test relvar-partition-1.4 {not an identifier } -setup {
        relvar create A {A1 string A2 int} A1
        relvar create B {B1 string} B1
        relvar create C {C1 string} C1
    } -cleanup {
        relvar unset A B C
    } -body {
        relvar partition R1 A A2 B B1 C C2
    } -result {attributes do not constitute an identifier, "A2"}\
    -returnCodes error

    test relvar-partition-1.5 {compound reference} -setup {
        relvar create A {A1 string A2 string A3 int} {A1 A2}
        relvar create B {A1 string A2 string B1 string} {A1 A2}
        relvar create C {A1 string A2 string C1 string} {A1 A2}
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B C
    } -body {
        relvar partition R1 A {A1 A2} B {A1 A2} C {A1 A2}
    } -result {}

    test relvar-partition-2.1 {passes constraints} -setup {
        relvar create A {A1 string} A1
        relvar create B {B1 string} B1
        relvar create C {C1 string} C1
        relvar partition R1 A A1 B B1 C C1
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B C
    } -body {
        relvar eval {
            relvar insert A {A1 b} {A1 c}
            relvar insert B {B1 b}
            relvar insert C {C1 c}
        }
    } -result {{C1 string} {{C1 c}}} -match relation

    test relvar-partition-2.2 {missing subtype} -setup {
        relvar create A {A1 string} A1
        relvar create B {B1 string} B1
        relvar create C {C1 string} C1
        relvar partition R1 A A1 B B1 C C1
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B C
    } -body {
        relvar eval {
            relvar insert A {A1 b} {A1 c}
            relvar insert B {B1 b}
        }
    } -result {for partition ::ral::test::R1(::ral::test::A is partitioned [::ral::test::B | ::ral::test::C]), in relvar ::ral::test::A
tuple {A1 c} is not referred to by any tuple
} -returnCodes error

    test relvar-partition-2.3 {extra super type reference} -setup {
        relvar create A {A1 string} A1
        relvar create B {B1 string} B1
        relvar create C {C1 string} C1
        relvar partition R1 A A1 B B1 C C1
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B C
    } -body {
        relvar eval {
            relvar insert A {A1 b}
            relvar insert B {B1 b}
            relvar insert C {C1 b}
        }
    } -result {for partition ::ral::test::R1(::ral::test::A is partitioned [::ral::test::B | ::ral::test::C]), in relvar ::ral::test::A
tuple {A1 b} is referred to by multiple tuples
} -returnCodes error

    test relvar-partition-3.1 {fail at create time} -setup {
        relvar create A {A1 string} A1
        relvar create B {B1 string} B1
        relvar create C {C1 string} C1
        relvar insert A {A1 b} {A1 c}
        relvar insert B {B1 b}
    } -cleanup {
        relvar unset A B C
    } -body {
        relvar partition R1 A A1 B B1 C C1
    } -result {for partition ::ral::test::R1(::ral::test::A is partitioned [::ral::test::B | ::ral::test::C]), in relvar ::ral::test::A
tuple {A1 c} is not referred to by any tuple
} -returnCodes error

    # This was a bug in 0.8.1 (and previous). If the partition attribute
    # associations were declared in an order that did not match the
    # identifier ordering of the relvar definitions, the constraint evaluation
    # would fail.
    test relvar-partition-3.2 {strange ordering} -setup {
        relvar create A {A1 string A2 string A3 int} {A1 A2}
        relvar create B {A1 string A2 string B1 string} {A1 A2}
        relvar create C {A1 string A2 string C1 string} {A1 A2}
    } -cleanup {
        relvar constraint delete R1
        relvar unset A B C
    } -body {
        relvar partition R1 A {A2 A1} B {A2 A1} C {A2 A1}
        relvar eval {
            relvar insert A {A1 a1 A2 a2 A3 1}
            relvar insert B {A1 a1 A2 a2 B1 b1}
        }
        return
    } -result {}

    # examples from the Date book
    test date-example-1.0 {Get suppliers who supply all parts} -body {
        set pnums [relation project $P P#]
        relation restrict $S sx\
            {[relation is\
                [relation project\
                    [relation restrict $SP spx\
                    {[tuple extract $spx S#] eq [tuple extract $sx S#]}] P#]\
            equal $pnums]}
    } -result {
        {S# string SNAME string STATUS int CITY string}
        {
            {S# S1 SNAME Smith STATUS 20 CITY London}
        }
    } -match relation

    test date-example-2.0 {Get suppliers who supply all parts (divide)}\
    -body {
        relation join\
            [relation divide\
                [relation project $S S#]\
                [relation project $P P#]\
                [relation project $SP S# P#]] $S
    } -result {
        {S# string SNAME string STATUS int CITY string}
        {
            {S# S1 SNAME Smith STATUS 20 CITY London}
        }
    } -match relation

    test date-example-3.0\
        {Get supplier names for suppliers who supply part P2} -body {
        relation project\
            [relation restrictwith [relation join $SP $S]\
                {${P#} eq "P2"}] SNAME
    } -result {
        {SNAME string}
        {
             {SNAME Smith}
             {SNAME Jones}
             {SNAME Blake}
             {SNAME Clark}
        }
    } -match relation

    test date-example-3.1\
        {Get supplier names for suppliers who supply part P2} -body {
        # use semijoin
        set p2 [relation restrictwith $P {${P#} eq "P2"}]
        relation project [relation semijoin $p2 $SP $S] SNAME
    } -result {
        {SNAME string}
        {
             {SNAME Smith}
             {SNAME Jones}
             {SNAME Blake}
             {SNAME Clark}
        }
    } -match relation

    test date-example-4.0 {Get supplier name for suppliers who supply at\
    least one red part} -body {
        relation project\
            [relation join\
                [relation project\
                    [relation join\
                        [relation restrictwith $P {$COLOR eq "Red"}]\
                        $SP]\
                    S#]\
                $S]\
            SNAME
    } -result {
        {SNAME string}
        {
             {SNAME Smith}
             {SNAME Jones}
             {SNAME Clark}
        }
    } -match relation

    test date-example-4.1 {Get supplier name for suppliers who supply at\
    least one red part} -body {
        # use semijoin
        set redPart [relation restrictwith $P {$COLOR eq "Red"}]
        relation project [relation semijoin $redPart $SP $S] SNAME
    } -result {
        {SNAME string}
        {
             {SNAME Smith}
             {SNAME Jones}
             {SNAME Clark}
        }
    } -match relation

    test date-example-6.0 {Get all pairs of supplier numbers such that\
        the suppliers concerned are colocated} -body {
        relation project\
            [relation restrictwith\
                [relation join\
                    [relation project [relation rename $S S# SA] SA CITY]\
                    [relation project [relation rename $S S# SB] SB CITY]\
                ]\
                {[string compare $SA $SB] < 0}\
            ]\
        SA SB
    } -result {
        {SA string SB string}
        {
            {SA S1 SB S4}
            {SA S2 SB S3}
        }
    } -match relation

    test date-example-7.0 {Get supplier info for suppliers who supply part P2}\
    -body {
        relation semijoin\
            [relation restrict $SP r1 {[tuple extract $r1 P#] eq "P2"}] $S
    } -result {
        {S# string SNAME string STATUS int CITY string}
        {
            {S# S1 SNAME Smith STATUS 20 CITY London}
            {S# S2 SNAME Jones STATUS 10 CITY Paris}
            {S# S3 SNAME Blake STATUS 30 CITY Paris}
            {S# S4 SNAME Clark STATUS 20 CITY London}
        }
    } -match relation

    test date-example-8.0 {Get supplier info for suppliers who do not\
        supply part P2} -body {
        relation semiminus [relation restrictwith $SP {${P#} eq "P2"}] $S
    } -result {
        {S# string SNAME string STATUS int CITY string}
        {
            {S# S5 SNAME Adams STATUS 30 CITY Athens}
        }
    } -match relation

    test relformat-1.0 {basic operation} -body {
        relformat $S
    } -result {+------+------+------+------+
|S#    |SNAME |STATUS|CITY  |
|string|string|int   |string|
+------+------+------+------+
|S1    |Smith |20    |London|
|S2    |Jones |10    |Paris |
|S3    |Blake |30    |Paris |
|S4    |Clark |20    |London|
|S5    |Adams |30    |Athens|
+------+------+------+------+}

    test relformat-2.0 {title} -body {
        relformat $S "Suppliers"
    } -result {+------+------+------+------+
|S#    |SNAME |STATUS|CITY  |
|string|string|int   |string|
+------+------+------+------+
|S1    |Smith |20    |London|
|S2    |Jones |10    |Paris |
|S3    |Blake |30    |Paris |
|S4    |Clark |20    |London|
|S5    |Adams |30    |Athens|
+------+------+------+------+
Suppliers
---------}

    test relformat-3.0 {sorting} -body {
        relformat $S "Suppliers" SNAME
    } -result {+------+------+------+------+
|S#    |SNAME |STATUS|CITY  |
|string|string|int   |string|
+------+------+------+------+
|S5    |Adams |30    |Athens|
|S3    |Blake |30    |Paris |
|S4    |Clark |20    |London|
|S2    |Jones |10    |Paris |
|S1    |Smith |20    |London|
+------+------+------+------+
Suppliers
---------}

    test relformat-4.0 {relation valued attribute} -body {
        relformat [relation group $SP PQ P# QTY] {} S#
    } -result {+------+------------+
|S#    |PQ          |
|string|Relation    |
+------+------------+
|S1    |+------+---+|
|      ||P#    |QTY||
|      ||string|int||
|      |+------+---+|
|      ||P1    |300||
|      ||P2    |200||
|      ||P3    |400||
|      ||P4    |200||
|      ||P5    |100||
|      ||P6    |100||
|      |+------+---+|
|S2    |+------+---+|
|      ||P#    |QTY||
|      ||string|int||
|      |+------+---+|
|      ||P1    |300||
|      ||P2    |400||
|      |+------+---+|
|S3    |+------+---+|
|      ||P#    |QTY||
|      ||string|int||
|      |+------+---+|
|      ||P2    |200||
|      |+------+---+|
|S4    |+------+---+|
|      ||P#    |QTY||
|      ||string|int||
|      |+------+---+|
|      ||P2    |200||
|      ||P4    |300||
|      ||P5    |400||
|      |+------+---+|
+------+------------+}

    cleanupTests
}

namespace delete ::ral::test
