#!/bin/sh
# \
exec tclsh "$0" "$@"
# This software is copyrighted 2004, 2005, 2006 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
# 
#  *++
# MODULE:
#   ral.test -- test cases for the Tcl Relational Algebra Library
# 
# ABSTRACT:
#   This file contains a set of test cases suitable for execution via
#   "tcltest" to test the code associated with the TCL Relational
#   Algebra library.
# 
# $RCSfile: trace.test,v $
# $Revision: 1.1 $
# $Date: 2007/01/02 04:15:06 $
#  *--

package require tcltest 2.2
eval tcltest::configure $argv

set ::auto_path [linsert $::auto_path 0\
    [file normalize [file join [info script] ..]]]
package require ral

proc relationMatch {expected actual} {
    return [::ral::relation is $expected == $actual]
}

namespace eval ::ral::test {
    namespace import ::tcltest::*
    namespace import ::ral::*

    customMatch relation relationMatch

    set recNum 0

    proc insertMap {relvarName opsList tup} {
	variable recNum
	#puts "insertMap: $relvarName, $opsList\n[tupleformat $tup\
	    "Insert Tuple"]"
	relvar eval {
	    relvar insert SMap [list R# $recNum S# [tuple extract $tup S#]]
	}
	incr recNum
    }

    proc deleteMap {relvarName opsList tup} {
	#puts "deleteMap: $relvarName, $opsList\n[tupleformat $tup\
	    "Delete Tuple"]"
	relvar eval {
	    relvar deleteone SMap S# [tuple extract $tup S#]
	}
    }

    proc updateMap {relvarName opsList oldtup newtup} {
	#puts [format "updateMap: $relvarName, $opsList\n%s\n%s"\
	    [tupleformat $oldtup "Old Tuple"]\
	    [tupleformat $newtup "New Tuple"]]
	set oldS [tuple extract $oldtup S#]
	set newS [tuple extract $newtup S#]
	if {$oldS ne $newS} {
	    relvar eval {
		relvar updateone SMap sm [list S# $oldS] {
		    tuple update sm S# $newS
		}
	    }
	}
    }

    proc setMap {relvarName opsList rel} {
	#puts "setMap: $relvarName, $opsList\n[relformat $rel setMap]"
	set newR [relation tag [relation project $rel S#] -ascending S# R#]
	relvar eval {
	    relvar set SMap $newR
	}
	variable recNum [relation cardinality $newR]
    }

    relvar create S {
	Relation
	{S# string SNAME string STATUS int CITY string}
	S#
    }

    relvar create SMap {
	Relation
	{R# int S# string}
	{R# S#}
    }

    test relvar-trace-1.0 {insert tracing} -setup {
	relvar trace add S insert [namespace code insertMap]
    } -cleanup {
	relvar trace remove S insert [namespace code insertMap]
    } -body {
	relvar insert S\
	    {S# S1 SNAME Smith STATUS 20 CITY London}\
	    {S# S2 SNAME Jones STATUS 10 CITY Paris}\
	    {S# S3 SNAME Blake STATUS 30 CITY Paris}\
	    {S# S4 SNAME Clark STATUS 20 CITY London}\
	    {S# S5 SNAME Adams STATUS 30 CITY Athens}
	relvar set SMap
    } -result {
	Relation
	{R# int S# string}
	{R# S#}
	{
	    {R# 0 S# S1}
	    {R# 1 S# S2}
	    {R# 2 S# S3}
	    {R# 3 S# S4}
	    {R# 4 S# S5}
	}
    } -match relation

    test relvar-trace-2.0 {delete tracing} -setup {
	relvar trace add S delete [namespace code deleteMap]
    } -cleanup {
	relvar trace remove S delete [namespace code deleteMap]
    } -body {
	relvar deleteone S S# S2
	relvar set SMap
    } -result {
	Relation
	{R# int S# string}
	{R# S#}
	{
	    {R# 0 S# S1}
	    {R# 2 S# S3}
	    {R# 3 S# S4}
	    {R# 4 S# S5}
	}
    } -match relation

    test relvar-trace-3.0 {update tracing} -setup {
	relvar trace add S update [namespace code updateMap]
    } -cleanup {
	relvar trace remove S update [namespace code updateMap]
    } -body {
	relvar updateone S supp {S# S3} {
	    tuple update supp S# S6
	}
	relvar set SMap
    } -result {
	Relation
	{R# int S# string}
	{R# S#}
	{
	    {R# 0 S# S1}
	    {R# 2 S# S6}
	    {R# 3 S# S4}
	    {R# 4 S# S5}
	}
    } -match relation

    test relvar-trace-4.0 {set tracing} -setup {
	relvar trace add S set [namespace code setMap]
    } -cleanup {
	relvar trace remove S set [namespace code setMap]
    } -body {
	relvar set S [relation include $S {S# S7 SNAME Foo STATUS 25 CITY Bar}]
	relvar set SMap
    } -result {
	Relation
	{R# int S# string}
	{R# S#}
	{
	    {R# 0 S# S1}
	    {R# 1 S# S4}
	    {R# 2 S# S5}
	    {R# 3 S# S6}
	    {R# 4 S# S7}
	}
    } -match relation

    cleanupTests
}

namespace delete ::ral::test
