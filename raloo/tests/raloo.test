#!/bin/sh
# \
exec tclsh "$0" "$@"
# This software is copyrighted 2008 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
# 
#  *++
# MODULE:
#   raloo.test -- test cases for Relation Oriented Programming package
# 
# ABSTRACT:
# 
# $RCSfile: raloo.test,v $
# $Revision: 1.20 $
# $Date: 2008/09/04 14:15:55 $
#  *--

package require tcltest 2.2

source ../raloo.tcl

if {"-level" in $argv} {
    set index [lsearch -exact $argv "-level"]
    ::raloo::arch::logLevel [lindex $argv $index+1]
    set argv [lreplace $argv $index $index+1]
} elseif {"-trace" in $argv} {
    set index [lsearch -exact $argv "-trace"]
    ::raloo::arch::trace [lindex $argv $index+1]
    set argv [lreplace $argv $index $index+1]
}

eval tcltest::configure $argv

proc tupleMatch {expected actual} {
    return [::ral::tuple equal $expected $actual]
}

proc relationMatch {expected actual} {
    return [::ral::relation is $expected == $actual]
}

proc syncSleep {} {
    vwait ::sync
    #puts "syncSleep: $::sync"
    return $::sync
}

proc syncWake {{value 1}} {
    set ::sync $value
}

proc ::bgerror msg {
    #puts $::errorInfo
    #puts stderr $msg
    syncWait $msg
}

namespace eval ::raloo::test {
    namespace import ::tcltest::*
    namespace import ::ral::*
    namespace import ::raloo::*

    customMatch tuple tupleMatch
    customMatch relation relationMatch

    proc setupDogOwnerOwnership {} {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Class Ownership {
		Attribute {
		    *DogName string
		    *OwnerName string
		}
	    }
	    AssocRelationship R1 Dog +-Ownership->* Owner
	}
    }
    proc cleanupDogOwnerOwnership {} {
	A destroy
    }
    proc setupDogPlays {} {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		}
	    }
	    Class Plays {
		Attribute {
		    *DogName string
		    *PlayerName string
		}
	    }
	    AssocRelationship R1 Dog *--Plays-->* Dog {
		FwrdRefMap {
		    PlayerName -> DogName
		}
		BackRefMap {
		    DogName -> DogName
		}
	    }
	}
	A transaction {
	    Dog insert DogName Fido
	    Dog insert DogName Fred
	    Dog insert DogName Alice
	    Plays insert DogName Fido PlayerName Fido
	    Plays insert DogName Fido PlayerName Fred
	    Plays insert DogName Fido PlayerName Alice
	    Plays insert DogName Alice PlayerName Fred
	    Plays insert DogName Fred PlayerName Fido
	}
    }
    proc cleanupDogPlays {} {
	A destroy
    }

    test Domain-1.1 {
	domain created in a relative namespace
    } -setup {
	Domain create A {}
    } -cleanup {
	A destroy
    } -body {
	namespace exists A
    } -result {1}

    test Domain-1.2 {
	domain created in an full-qualified namespace
    } -setup {
	Domain create ::A {}
    } -cleanup {
	A destroy
    } -body {
	namespace exists ::A
    } -result {1}

    test Domain-1.3 {
	domain / namespace conflict
    } -setup {
	namespace eval B {}
    } -cleanup {
	namespace delete B
    } -body {
	Domain create B {}
    } -result {A namespace with name, "::raloo::test::B", already exists and so a Domain by the same name may not be created.} -returnCodes error

    test Domain-2.1 {
	domain with domain operation
    } -setup {
	Domain create A {
	    DomainOp echo {a} {
		return $a
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A echo a
    } -result {a}

    test Domain-2.2 {
	failure in a domain operation invocation
    } -setup {
	Domain create A {
	    DomainOp echo {a} {
		return [$a]
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A echo a
    } -result {invalid command name "a"} -returnCodes error

    test Domain-2.3 {
	incrementally define a domain
    } -setup {
	Domain create A {
	    DomainOp echo {a} {
		return $a
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A define {
	    DomainOp repeat {str cnt} {
		return [string repeat $str $cnt]
	    }
	}
	A repeat a 3
    } -result {aaa}

    test Domain-2.4 {
	class reference within a DomainOp
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    Breed string
		}
	    }
	    DomainOp newDog {name breed} {
		Dog insert DogName $name Breed $breed
	    }
	    DomainOp getDogBreed {name} {
		set dog [Dog selectOne DogName $name]
		return [$dog readAttr Breed]
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A newDog Fred Poodle
	A getDogBreed Fred
    } -result {Poodle}

    test Domain-2.5 {
	domain operation transaction error
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Class Ownership {
		Attribute {
		    *DogName string
		    *OwnerName string
		}
	    }
	    AssocRelationship R1 Dog +-Ownership->+ Owner
	    DomainOp newDog {name} {
		Dog insert DogName $name
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A newDog Fred
    } -result {for correlation ::raloo::test::A::R1(::raloo::test::A::Dog <== [+] ::raloo::test::A::Ownership [+] ==> ::raloo::test::A::Owner), in relvar ::raloo::test::A::Dog
tuple {DogName Fred} is not referenced by any tuple
} -returnCodes error

    test Domain-3.1 {
	simple relationship definition
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A define {
	    Relationship R1 Dog +-->1 Owner
	}
	A::R1 info
    } -result {association ::raloo::test::A::R1 ::raloo::test::A::Dog OwnerName + ::raloo::test::A::Owner OwnerName 1}

    test Domain-3.2 {
	simple relationship definition with formalization
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *Name string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *Name string
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A define {
	    Relationship R1 Dog +-->1 Owner {
		RefMap {
		    OwnerName --> Name
		}
	    }
	}
	A::R1 info
    } -result {association ::raloo::test::A::R1 ::raloo::test::A::Dog OwnerName + ::raloo::test::A::Owner Name 1}

    test Domain-3.3 {
	simple relationship definition with multiple identifiers
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *Name string
		    OwnerName string
		    OwnerId int
		}
	    }
	    Class Owner {
		Attribute {
		    *Name string
		    *Id int
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A define {
	    Relationship R1 Dog +-->1 Owner {
		RefMap {
		    OwnerId --> Id
		    OwnerName --> Name
		}
	    }
	}
	A::R1 info
    } -result {association ::raloo::test::A::R1 ::raloo::test::A::Dog {OwnerName OwnerId} + ::raloo::test::A::Owner {Name Id} 1}

    test Domain-3.4 {
	relationship definition error -- bad id attribute
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *Name string
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A define {
	    Relationship R1 Dog +-->1 Owner {
		RefMap {
		    OwnerName --> Id
		}
	    }
	}
    } -result {attribute(s), "Id", do(es) not constitute an identifier of, "Owner"}\
    -returnCodes error

    test Domain-3.5 {
	relationship definition error -- bad referring attribute
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *Name string
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A define {
	    Relationship R1 Dog +-->1 Owner {
		RefMap {
		    Name --> Name
		}
	    }
	}
    } -result {"Name", is(are) not attributes of class, "Dog"}\
    -returnCodes error

    test Domain-3.6 {
	relationship definition error -- referring to wrong identifier
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *Name string
		    *2SSNum string
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A define {
	    Relationship R1 Dog +-->1 *2Owner {
		RefMap {
		    OwnerName --> Name
		}
	    }
	}
    } -result {referring attribute(s), "OwnerName", do(es) not refer to identifier, "2" of class, "Owner"}\
    -returnCodes error

    test Domain-4.1 {
	generalization relationship
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *Name string
		    OwnerName string
		}
	    }
	    Class SmallDog {
		Attribute {
		    *Name string
		}
	    }
	    Class BigDog {
		Attribute {
		    *Name string
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A define {
	    Generalization R1 Dog {
		SubType SmallDog
		SubType BigDog
	    }
	}
	A::R1 info
    } -result {partition ::raloo::test::A::R1 ::raloo::test::A::Dog Name ::raloo::test::A::SmallDog Name ::raloo::test::A::BigDog Name}

    test Domain-4.2 {
	generalization relationship specifying the reference mapping
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *Name string
		}
	    }
	    Class SmallDog {
		Attribute {
		    *SDName string
		}
	    }
	    Class BigDog {
		Attribute {
		    *BDName string
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A define {
	    Generalization R1 Dog {
		SubType SmallDog {
		    SDName -> Name
		}
		SubType BigDog {
		    BDName -> Name
		}
	    }
	}
	A::R1 info
    } -result {partition ::raloo::test::A::R1 ::raloo::test::A::Dog Name ::raloo::test::A::SmallDog SDName ::raloo::test::A::BigDog BDName}

    test Domain-4.3 {
	generalization relationship -- super type error
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *Name string
		}
	    }
	    Class SmallDog {
		Attribute {
		    *SDName string
		}
	    }
	    Class BigDog {
		Attribute {
		    *BDName string
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A define {
	    Generalization R1 Dog {
		SubType SmallDog {
		    SDName -> Name
		}
		SubType Dog
	    }
	}
    } -result {a supertype may not be its own subtype, "Dog"} -returnCodes error

    test Domain-5.1 {
	associative relationship
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Class Ownership {
		Attribute {
		    *OwnerName string
		    *DogName string
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A define {
	    AssocRelationship R1 Owner *--Ownership-->+ Dog
	}
	A::R1 info
    } -result {correlation ::raloo::test::A::R1 ::raloo::test::A::Ownership OwnerName + ::raloo::test::A::Owner OwnerName DogName * ::raloo::test::A::Dog DogName}

    test Domain-5.2 {
	associative relationship with explicit references
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *Name string
		}
	    }
	    Class Owner {
		Attribute {
		    *Name string
		}
	    }
	    Class Ownership {
		Attribute {
		    *OwnerName string
		    *DogName string
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A define {
	    AssocRelationship R1 Owner *--Ownership-->+ Dog {
		FwrdRefMap {
		    DogName -> Name
		}
		BackRefMap {
		    OwnerName -> Name
		}
	    }
	}
	A::R1 info
    } -result {correlation ::raloo::test::A::R1 ::raloo::test::A::Ownership OwnerName + ::raloo::test::A::Owner Name DogName * ::raloo::test::A::Dog Name}

    test Domain-5.3 {
	associative relationship -- target same as associator
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Class Ownership {
		Attribute {
		    *OwnerName string
		    *DogName string
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A define {
	    AssocRelationship R1 Owner *--Ownership-->+ Ownership
	}
    } -result {an associate relationship participant may not also be the associative class, "Ownership"} -returnCodes error

    test Class-1.1 {
	classes have a backing relvar
    } -setup {
    } -cleanup {
	A destroy
    } -body {
	Domain create A {
	    Class Foo {
		Attribute {
		    *Id int
		    Attr1 string
		    *1Other string
		}
	    }
	}
	relation attributes $A::Foo
    } -result {Id Attr1 Other}

    test Class-1.2 {
	inserting a tuple into a class relvar
    } -setup {
	Domain create B {
	    Class Dog {
		Attribute {
		    *Name string
		    Breed string
		    Age int
		}
	    }
	}
    } -cleanup {
	B destroy
    } -body {
	B::Dog insert Name Fifi Breed Poodle Age 3
    } -result {
	Relation {
	    Name string
	    Breed string
	    Age int
	} {
	    Name
	} {
	    {Name Fifi Breed Poodle Age 3}
	}
    } -match relation

    test Class-1.3 {
	create class reference
    } -setup {
	Domain create C {
	    Class Dog {
		Attribute {
		    *Name string
		    Breed string
		    Age int
		}
	    }
	}
    } -cleanup {
	C destroy
    } -body {
	C::Dog insert Name Rover Breed Retriever Age 5
	set r [C::Dog selectOne Name Rover]
	$r cardinality
    } -result {1}

    test Class-1.4 {
	class with multiple identifiers
    } -setup {
	Domain create C {
	    Class Dog {
		Attribute {
		    *Name string
		    *2Id int
		}
	    }
	}
    } -cleanup {
	C destroy
    } -body {
	C::Dog insert Name Rover Id 3
	set r [C::Dog selectOne Name Rover]
	$r readAttr Name
    } -result {Rover}

    test Class-1.5 {
	class with overlapping identifiers
    } -setup {
	Domain create C {
	    Class Dog {
		Attribute {
		    **2Name string
		    *Breed string
		    *2Id int
		}
	    }
	}
    } -cleanup {
	C destroy
    } -body {
	C::Dog insert Name Rover Breed Poodle Id 3
	set r [C::Dog selectOne Name Rover Breed Poodle]
	$r readAttr Name
    } -result {Rover}

    test Class-1.6 {
	class with unique identifier
    } -setup {
	Domain create C {
	    Class Foo {
		Attribute {
		    *Id UNIQUE
		    Breed string
		}
	    }
	}
    } -cleanup {
	C destroy
    } -body {
	C::Foo insert Id {} Breed Poodle
	set r [C::Foo selectOne Id 1]
	$r readAttr Id
    } -result {1}

    test Class-2.1 {
	create class reference by selection
    } -setup {
	Domain create C {
	    Class Dog {
		Attribute {
		    *Name string
		    Breed string
		    Age int
		}
	    }
	    Dog insert Name Rover Breed Retriever Age 5
	}
    } -cleanup {
	C destroy
    } -body {
	set r [C::Dog selectOne Name Rover]
	$r cardinality
    } -result {1}

    test Class-3.1 {
	retrieve attribute
    } -setup {
	Domain create C {
	    Class Dog {
		Attribute {
		    *Name string
		    Breed string
		    Age int
		}
	    }
	}
    } -cleanup {
	C destroy
    } -body {
	C::Dog insert Name Rover Breed Retriever Age 5
	set r [C::Dog selectOne Name Rover]
	$r readAttr Breed
    } -result {Retriever}

    test Class-3.2 {
	update attribute
    } -setup {
	Domain create C {
	    Class Dog {
		Attribute {
		    *Name string
		    Breed string
		    Age int
		}
	    }
	}
    } -cleanup {
	C destroy
    } -body {
	C::Dog insert Name Rover Breed Retriever Age 5
	set r [C::Dog selectOne Name Rover]
	$r writeAttr Age 10
	$r readAttr Age
    } -result {10}

    test Class-4.1 {
	class based operations
    } -setup {
	Domain create A {
	    Class Foo {
		Attribute {
		    *Id int
		}
		ClassOp echo {thing} {
		    return $thing
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A::Foo echo bar
    } -result {bar}

    test Class-4.2 {
	instance based operations
    } -setup {
	Domain create A {
	    Class Foo {
		Attribute {
		    *Id int
		}
		ClassOp echo {thing} {
		    return $thing
		}
		InstOp echo {thing} {
		    return $thing
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A::Foo insert Id 1
	set r [A::Foo selectOne Id 1]
	$r echo bar
    } -result {bar}

    test Class-5.1 {
	simple relationship traversal
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Relationship R1 Dog *-->1 Owner
	}
	A transaction {
	    Owner insert OwnerName John
	    Dog insert DogName Fred OwnerName John
	}
    } -cleanup {
	$owner destroy
	$dog destroy
	A destroy
    } -body {
	set dog [A::Dog selectOne DogName Fred]
	set owner [$dog selectRelated R1]
	$owner readAttr OwnerName
    } -result {John}

    test Class-5.2 {
	simple relationship traversal, error in destination
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Relationship R1 Dog *-->1 Owner
	}
	A transaction {
	    Owner insert OwnerName John
	    Dog insert DogName Fred OwnerName John
	}
    } -cleanup {
	$dog destroy
	A destroy
    } -body {
	set dog [A::Dog selectOne DogName Fred]
	set owner [$dog selectRelated R1.Dog]
    } -result {traversing R1 ends at, "Owner", and not at "Dog"}\
    -returnCodes error

    test Class-5.3 {
	simple relationship traversal, error in direction
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Relationship R1 Dog *-->1 Owner
	}
	A transaction {
	    Owner insert OwnerName John
	    Dog insert DogName Fred OwnerName John
	}
    } -cleanup {
	$dog destroy
	A destroy
    } -body {
	set dog [A::Dog selectOne DogName Fred]
	set owner [$dog selectRelated ~R1]
    } -result {traversing ~R1 begins at, "Owner", and not at "Dog"}\
    -returnCodes error

    test Class-5.4 {
	simple relationship backwards traversal
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Relationship R1 Dog *-->1 Owner

	    Owner insert OwnerName John
	    Dog insert DogName Fred OwnerName John
	}
    } -cleanup {
	$owner destroy
	$dog destroy
	A destroy
    } -body {
	set owner [A::Owner selectOne OwnerName John]
	set dog [$owner selectRelated ~R1]
	$dog readAttr DogName
    } -result {Fred}

    test Class-5.5 {
	simple relationship traversal -- multiple traversals
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Relationship R1 Dog *-->1 Owner
	    Class Phone {
		Attribute {
		    *Number string
		    OwnerName string
		}
	    }
	    Relationship R2 Phone *-->1 Owner
	}
	A::Owner insert OwnerName John
	A::Dog insert DogName Fred OwnerName John
	A::Phone insert Number 555-1212 OwnerName John
    } -cleanup {
	$phone destroy
	$dog destroy
	A destroy
    } -body {
	set dog [A::Dog selectOne DogName Fred]
	set phone [$dog selectRelated R1 ~R2]
	$phone readAttr Number
    } -result {555-1212}

    test Class-5.6 {
	simple relationship traversal -- reflexive, forward direction
    } -setup {
	Domain create A {
	    Class Phone {
		Attribute {
		    *Number string
		    PrevNumber string
		}
	    }
	    Relationship R1 Phone ?-->? Phone {
		RefMap {
		    PrevNumber -> Number
		}
	    }
	}
	A::Phone insert Number 555-1212 PrevNumber {}
	A::Phone insert Number 555-1213 PrevNumber 555-1212
    } -cleanup {
	$phone destroy
	$prevphone destroy
	A destroy
    } -body {
	set phone [A::Phone selectOne Number 555-1213]
	set prevphone [$phone selectRelated R1]
	$prevphone readAttr Number
    } -result {555-1212}

    test Class-5.7 {
	simple relationship traversal -- reflexive, backward direction
    } -setup {
	Domain create A {
	    Class Phone {
		Attribute {
		    *Number string
		    PrevNumber string
		}
	    }
	    Relationship R1 Phone ?-->? Phone {
		RefMap {
		    PrevNumber -> Number
		}
	    }
	}
	A::Phone insert Number 555-1212 PrevNumber {}
	A::Phone insert Number 555-1213 PrevNumber 555-1212
    } -cleanup {
	$phone destroy
	$nextphone destroy
	A destroy
    } -body {
	set phone [A::Phone selectOne Number 555-1212]
	set nextphone [$phone selectRelated ~R1]
	$nextphone readAttr Number
    } -result {555-1213}

    test Class-6.1 {
	generalization relationship traversal -- sub to super
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *Name string
		}
	    }
	    Class SmallDog {
		Attribute {
		    *Name string
		}
	    }
	    Class BigDog {
		Attribute {
		    *Name string
		}
	    }
	    Generalization R1 Dog {
		SubType SmallDog
		SubType BigDog
	    }
	}
	A transaction {
	    Dog insert Name Fred
	    SmallDog insert Name Fred
	}
    } -cleanup {
	$dog destroy
	$sdog destroy
	A destroy
    } -body {
	set sdog [A::SmallDog selectOne Name Fred]
	set dog [$sdog selectRelated R1]
	$dog readAttr Name
    } -result {Fred}

    test Class-6.2 {
	generalization relationship traversal -- super to sub
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *Name string
		}
	    }
	    Class SmallDog {
		Attribute {
		    *Name string
		}
	    }
	    Class BigDog {
		Attribute {
		    *Name string
		}
	    }
	    Generalization R1 Dog {
		SubType SmallDog
		SubType BigDog
	    }
	}
	A transaction {
	    Dog insert Name Fred
	    SmallDog insert Name Fred
	}
    } -cleanup {
	$dog destroy
	$sdog destroy
	A destroy
    } -body {
	set dog [A::Dog selectOne Name Fred]
	set sdog [$dog selectRelated ~R1.SmallDog]
	$sdog readAttr Name
    } -result {Fred}

    test Class-6.3 {
	generalization relationship traversal -- super to sub, alternate syntax
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *Name string
		}
	    }
	    Class SmallDog {
		Attribute {
		    *Name string
		}
	    }
	    Class BigDog {
		Attribute {
		    *Name string
		}
	    }
	    Generalization R1 Dog {
		SubType SmallDog
		SubType BigDog
	    }
	}
	A transaction {
	    Dog insert Name Fred
	    SmallDog insert Name Fred
	}
    } -cleanup {
	$dog destroy
	$sdog destroy
	A destroy
    } -body {
	set dog [A::Dog selectOne Name Fred]
	set sdog [$dog selectRelated R1.SmallDog]
	$sdog readAttr Name
    } -result {Fred}

    test Class-7.1 {
	associative relationship traversal -- source to target
    } -setup {
	setupDogOwnerOwnership
	A transaction {
	    Owner insert OwnerName John
	    Dog insert DogName Fido
	    Ownership insert DogName Fido OwnerName John
	}
    } -cleanup {
	$owner destroy
	$dog destroy
	cleanupDogOwnerOwnership
    } -body {
	set dog [A::Dog selectOne DogName Fido]
	set owner [$dog selectRelated R1]
	$owner readAttr OwnerName
    } -result {John}

    test Class-7.2 {
	associative relationship traversal -- target to source
    } -setup {
	setupDogOwnerOwnership
	A transaction {
	    Owner insert OwnerName John
	    Dog insert DogName Fido
	    Ownership insert DogName Fido OwnerName John
	}
    } -cleanup {
	$owner destroy
	$dog destroy
	cleanupDogOwnerOwnership
    } -body {
	set owner [A::Owner selectOne OwnerName John]
	set dog [$owner selectRelated ~R1]
	$dog readAttr DogName
    } -result {Fido}

    test Class-7.3 {
	associative relationship traversal -- source to associative class
    } -setup {
	setupDogOwnerOwnership
	A transaction {
	    Owner insert OwnerName John
	    Dog insert DogName Fido
	    Ownership insert DogName Fido OwnerName John
	}
    } -cleanup {
	$ownership destroy
	$dog destroy
	cleanupDogOwnerOwnership
    } -body {
	set dog [A::Dog selectOne DogName Fido]
	set ownership [$dog selectRelated R1.Ownership]
	$ownership readAttr OwnerName
    } -result {John}

    test Class-7.4 {
	associative relationship traversal -- target to associative class
    } -setup {
	setupDogOwnerOwnership
	A transaction {
	    Owner insert OwnerName John
	    Dog insert DogName Fido
	    Ownership insert DogName Fido OwnerName John
	}
    } -cleanup {
	$owner destroy
	$ownership destroy
	cleanupDogOwnerOwnership
    } -body {
	set owner [A::Owner selectOne OwnerName John]
	set ownership [$owner selectRelated ~R1.Ownership]
	$ownership readAttr DogName
    } -result {Fido}

    test Class-7.5 {
	associate relationship traversal -- reflexive, forward
    } -setup {
	setupDogPlays
    } -cleanup {
	$dog destroy
	$players destroy
	cleanupDogPlays
    } -body {
	set dog [A::Dog selectOne DogName Fido]
	set players [$dog selectRelated R1]
	$players get
    } -result {
	Relation {
	    DogName string
	} {
	    DogName
	} {
	    {DogName Fido}
	    {DogName Fred}
	    {DogName Alice}
	}
    } -match relation

    test Class-7.6 {
	associate relationship traversal -- reflexive, backward
    } -setup {
	setupDogPlays
    } -cleanup {
	$playmate destroy
	$dog destroy
	cleanupDogPlays
    } -body {
	set playmate [A::Dog selectOne DogName Fred]
	set dog [$playmate selectRelated ~R1]
	$dog get
    } -result {
	Relation {
	    DogName string
	} {
	    DogName
	} {
	    {DogName Fido}
	    {DogName Alice}
	}
    } -match relation

    test Class-7.7 {
	associate relationship traversal -- reflexive, target to associative
    } -setup {
	setupDogPlays
    } -cleanup {
	$playmate destroy
	$plays destroy
	cleanupDogPlays
    } -body {
	set playmate [A::Dog selectOne DogName Fred]
	set plays [$playmate selectRelated ~R1.Plays]
	$plays get
    } -result {
	Relation {
	    DogName string
	    PlayerName string
	} {
	    {DogName PlayerName}
	} {
	    {DogName Fido PlayerName Fred}
	    {DogName Alice PlayerName Fred}
	}
    } -match relation

    test Class-7.8 {
	associate relationship traversal -- reflexive, source to associative
    } -setup {
	setupDogPlays
    } -cleanup {
	$dog destroy
	$plays destroy
	cleanupDogPlays
    } -body {
	set dog [A::Dog selectOne DogName Fred]
	set plays [$dog selectRelated R1.Plays]
	$plays get
    } -result {
	Relation {
	    DogName string
	    PlayerName string
	} {
	    {DogName PlayerName}
	} {
	    {DogName Fred PlayerName Fido}
	}
    } -match relation

    test Class-8.1 {
	relate across simple relationship
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Relationship R1 Dog *-->1 Owner
	}
    } -cleanup {
	A destroy
    } -body {
	A transaction {
	    Owner insert OwnerName John
	    Dog insert DogName Fred OwnerName {}

	    set owner [Owner selectOne OwnerName John]
	    set dog [Dog selectOne DogName Fred]
	    $dog relate R1 $owner
	    $dog readAttr OwnerName
	}
    } -result {John}

    test Class-8.2 {
	relate across simple relationship -- backward
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Relationship R1 Dog *-->1 Owner
	}
    } -cleanup {
	A destroy
    } -body {
	A transaction {
	    Owner insert OwnerName John
	    Dog insert DogName Fred OwnerName {}

	    set owner [Owner selectOne OwnerName John]
	    set dog [Dog selectOne DogName Fred]
	    $owner relate ~R1 $dog
	    $dog readAttr OwnerName
	}
    } -result {John}

    test Class-8.3 {
	relate across simple relationship -- reflexive, forward
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    PrevDog string
		}
	    }
	    Relationship R1 Dog ?-->? Dog {
		RefMap {
		    PrevDog -> DogName
		}
	    }
	}
	A transaction {
	    Dog insert DogName Fred PrevDog {}
	    Dog insert DogName Fido PrevDog {}
	}
    } -cleanup {
	A destroy
    } -body {
	A transaction {
	    set leaddog [Dog selectOne DogName Fred]
	    set nextdog [Dog selectOne DogName Fido]
	    $nextdog relate R1 $leaddog
	    $nextdog readAttr PrevDog
	}
    } -result {Fred}

    test Class-8.4 {
	relate across simple relationship -- reflexive, backward
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    PrevDog string
		}
	    }
	    Relationship R1 Dog ?-->? Dog {
		RefMap {
		    PrevDog -> DogName
		}
	    }
	}
	A transaction {
	    Dog insert DogName Fred PrevDog {}
	    Dog insert DogName Fido PrevDog {}
	}
    } -cleanup {
	A destroy
    } -body {
	A transaction {
	    set leaddog [Dog selectOne DogName Fred]
	    set nextdog [Dog selectOne DogName Fido]
	    $leaddog relate ~R1 $nextdog
	    $nextdog readAttr PrevDog
	}
    } -result {Fred}

    test Class-8.5 {
	relate across simple relationship -- error
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Relationship R1 Dog *-->1 Owner
	}
    } -cleanup {
	A destroy
    } -body {
	A transaction {
	    Dog insert DogName Fred OwnerName {}
	    Dog insert DogName Fido OwnerName {}

	    set fred [Dog selectOne DogName Fred]
	    set fido [Dog selectOne DogName Fido]
	    $fred relate R1 $fido
	}
    } -result {"Dog" and "Dog" do not participate in relationship\
	"::raloo::test::A::R1"}\
    -returnCodes error

    test Class-9.1 {
	relate across generalization relationship - sub to super
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *Name string
		}
	    }
	    Class SmallDog {
		Attribute {
		    *Name string
		}
	    }
	    Class BigDog {
		Attribute {
		    *Name string
		}
	    }
	    Generalization R1 Dog {
		SubType SmallDog
		SubType BigDog
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A transaction {
	    Dog insert Name Fred
	    SmallDog insert Name {}

	    set dog [Dog selectOne Name Fred]
	    set sdog [SmallDog selectOne Name {}]
	    $sdog relate R1 $dog
	    $sdog readAttr Name
	}
    } -result {Fred}

    test Class-9.2 {
	relate across generalization relationship - super to sub
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *Name string
		}
	    }
	    Class SmallDog {
		Attribute {
		    *Name string
		}
	    }
	    Class BigDog {
		Attribute {
		    *Name string
		}
	    }
	    Generalization R1 Dog {
		SubType SmallDog
		SubType BigDog
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A transaction {
	    Dog insert Name Fred
	    SmallDog insert Name {}

	    set dog [Dog selectOne Name Fred]
	    set sdog [SmallDog selectOne Name {}]
	    $dog relate R1 $sdog
	    $sdog readAttr Name
	}
    } -result {Fred}

    test Class-10.1 {
	relate across associative relationship -- backward
    } -setup {
	setupDogOwnerOwnership
    } -cleanup {
	cleanupDogOwnerOwnership
    } -body {
	A transaction {
	    Dog insert DogName Fido
	    Owner insert OwnerName John

	    set dog [Dog selectOne DogName Fido]
	    set owner [Owner selectOne OwnerName John]
	    set ownership [$owner relateAssoc R1 $dog]
	    list [$ownership readAttr OwnerName] [$dog readAttr DogName]
	}
    } -result {John Fido}

    test Class-10.2 {
	relate across associative relationship -- foreward
    } -setup {
	setupDogOwnerOwnership
    } -cleanup {
	cleanupDogOwnerOwnership
    } -body {
	A transaction {
	    Dog insert DogName Fido
	    Owner insert OwnerName John

	    set dog [Dog selectOne DogName Fido]
	    set owner [Owner selectOne OwnerName John]
	    set ownership [$dog relateAssoc R1 $owner]
	    list [$ownership readAttr OwnerName] [$dog readAttr DogName]
	}
    } -result {John Fido}

    test Class-10.3 {
	relate across associative relationship -- reflexive, foreward
    } -setup {
	setupDogPlays
    } -cleanup {
	$dog1 destroy
	$dog2 destroy
	$plays destroy
	cleanupDogPlays
    } -body {
	set dog1 [A::Dog selectOne DogName Alice]
	set dog2 [A::Dog selectOne DogName Fido]
	set plays [$dog1 relateAssoc R1 $dog2]
	$plays readAttr PlayerName
    } -result {Fido}

    test Class-10.3 {
	relate across associative relationship -- reflexive, foreward
    } -setup {
	setupDogPlays
    } -cleanup {
	$dog1 destroy
	$dog2 destroy
	$plays destroy
	cleanupDogPlays
    } -body {
	set dog1 [A::Dog selectOne DogName Alice]
	set dog2 [A::Dog selectOne DogName Fido]
	set plays [$dog2 relateAssoc ~R1 $dog1]
	$plays readAttr PlayerName
    } -result {Fido}

    test Class-11.1 {
	unrelate across simple relationship
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Relationship R1 Dog *-->? Owner
	}
	A transaction {
	    Owner insert OwnerName John
	    Dog insert DogName Fido OwnerName John
	}
    } -cleanup {
	A destroy
    } -body {
	A transaction {
	    set owner [Owner selectOne OwnerName John]
	    set dog [Dog selectOne DogName Fido]
	    $dog unrelate R1 $owner
	    $dog readAttr OwnerName
	}
    } -result {}

    test Class-11.2 {
	unrelate across simple relationship -- reflexive, forward
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    PrevDog string
		}
	    }
	    Relationship R1 Dog ?-->? Dog {
		RefMap {
		    PrevDog -> DogName
		}
	    }
	}
	A transaction {
	    Dog insert DogName Fred PrevDog {}
	    Dog insert DogName Alice PrevDog Fred
	    Dog insert DogName Fido PrevDog Alice
	}
    } -cleanup {
	$alice destroy
	$fido destroy
	A destroy
    } -body {
	set alice [A::Dog selectOne DogName Alice]
	set fido [A::Dog selectOne DogName Fido]
	$alice unrelate R1 $fido
	$alice readAttr PrevDog
	list [$alice readAttr PrevDog] [$fido readAttr PrevDog]
    } -result {{} Alice}

    test Class-11.3 {
	unrelate across simple relationship -- reflexive, backward
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    PrevDog string
		}
	    }
	    Relationship R1 Dog ?-->? Dog {
		RefMap {
		    PrevDog -> DogName
		}
	    }
	}
	A transaction {
	    Dog insert DogName Fred PrevDog {}
	    Dog insert DogName Alice PrevDog Fred
	    Dog insert DogName Fido PrevDog Alice
	}
    } -cleanup {
	$alice destroy
	$fido destroy
	A destroy
    } -body {
	set alice [A::Dog selectOne DogName Alice]
	set fido [A::Dog selectOne DogName Fido]
	$alice unrelate ~R1 $fido
	list [$alice readAttr PrevDog] [$fido readAttr PrevDog]
    } -result {Fred {}}

    test Class-12.1 {
	subtype migration
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *Name string
		    Weight int
		}
	    }
	    Class SmallDog {
		Attribute {
		    *Name string
		    BreedSize string
		}
	    }
	    Class BigDog {
		Attribute {
		    *Name string
		}
	    }
	    Generalization R1 Dog {
		SubType SmallDog
		SubType BigDog
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A transaction {
	    Dog insert Name Fido Weight 20
	    BigDog insert Name Fido

	    set dog [Dog selectOne Name Fido]
	    set bdog [BigDog selectOne Name Fido]
	    set sdog [$bdog reclassify R1 SmallDog BreedSize toy]
	    list [$sdog readAttr Name] [$sdog readAttr BreedSize]
	}
    } -result {Fido toy}

    test Class-12.2 {
	subtype migration -- subtype names are different
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *Name string
		    Weight int
		}
	    }
	    Class SmallDog {
		Attribute {
		    *SName string
		    BreedSize string
		}
	    }
	    Class BigDog {
		Attribute {
		    *BName string
		}
	    }
	    Generalization R1 Dog {
		SubType SmallDog {
		    SName -> Name
		}
		SubType BigDog {
		    BName -> Name
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A transaction {
	    Dog insert Name Fido Weight 20
	    BigDog insert BName Fido

	    set dog [Dog selectOne Name Fido]
	    set bdog [BigDog selectOne BName Fido]
	    set sdog [$bdog reclassify R1 SmallDog BreedSize toy]
	    list [$sdog readAttr SName] [$sdog readAttr BreedSize]
	}
    } -result {Fido toy}

    test Lifecycle-1.1 {
	active class -- defining states
    } -setup {
	Domain create A {
	    Class Foo {
		Attribute {
		    *Id int
		}

		Lifecycle {
		    State born {date} {
			#puts born
		    }
		    Transition born - E1 -> born
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A::Foo states
    } -result {born}

    test Lifecycle-1.2 {
	active class -- creation state
    } -setup {
	Domain create A {
	    Class Foo {
		Attribute {
		    *Id int
		}

		Lifecycle {
		    State born {date} {
			#puts born
		    }
		    Transition @ - E1 -> born
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	#puts [relformat $::raloo::mm::StateModel StateModel]
	A::Foo states
    } -result {born}

    test Lifecycle-1.3 {
	active class -- specifying default transition
    } -setup {
	Domain create A {
	    Class Foo {
		Attribute {
		    *Id int
		}

		Lifecycle {
		    State born {date} {
			#puts born
		    }
		    Transition @ - E1 -> born
		    DefaultTransition IG
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	#puts [relformat $::raloo::mm::StateModel StateModel]
	relation list\
	    [relation restrictwith $::raloo::mm::StateModel {
		[string match *A $DomName] && $ModelName eq "Foo"}]\
	    DefaultTrans
    } -result {IG}

    test Lifecycle-1.3.1 {
	active class -- error in specifying default transition
    } -setup {
    } -cleanup {
    } -body {
	Domain create A {
	    Class Foo {
		Attribute {
		    *Id int
		}

		Lifecycle {
		    State born {date} {
			#puts born
		    }
		    Transition @ - E1 -> born
		    DefaultTransition XX
		}
	    }
	}
    } -result {for association ::raloo::mm::R35(::raloo::mm::StateModel [*] ==> [1] ::raloo::mm::TransitionRule), in relvar ::raloo::mm::StateModel
tuple {DomName ::raloo::test::A ModelName Foo InitialState born DefaultTrans XX} references no tuple
} -returnCodes error

    test Lifecycle-1.3.2 {
	active class -- error in specifying default initial state
    } -setup {
    } -cleanup {
    } -body {
	Domain create A {
	    Class Foo {
		Attribute {
		    *Id int
		}

		Lifecycle {
		    State born {date} {
			#puts born
		    }
		    Transition born - E1 -> born
		    DefaultInitialState foo
		}
	    }
	}
    } -result {for association ::raloo::mm::R34(::raloo::mm::StateModel [?] ==> [1] ::raloo::mm::ActiveState), in relvar ::raloo::mm::StateModel
tuple {DomName ::raloo::test::A ModelName Foo InitialState foo DefaultTrans CH} references no tuple
} -returnCodes error

    test Lifecycle-1.4 {
	active class -- signature mismatch
    } -setup {
    } -cleanup {
    } -body {
	Domain create A {
	    Class Foo {
		Attribute {
		    *Id int
		}

		Lifecycle {
		    State born {date} {
			#puts born
		    }
		    State grow {} {
			#puts grow
		    }
		    Transition born - E1 -> grow
		    Transition grow - E1 -> born
		}
	    }
	}
    } -result {for the transition, "grow - E1 -> born", the parameter signature for the event, "E1 {}", does not match the signature of the destination state, "born date"}\
    -returnCodes error

    test Lifecycle-1.5 {
	active class -- generating events
    } -setup {
	Domain create A {
	    Class Foo {
		Attribute {
		    *Id int
		}

		Lifecycle {
		    State born {date} {
			#puts "born: $date"
                        syncWake born
		    }
		    Transition born - E1 -> born
		}
	    }
	    DomainOp start {} {
		set n [Foo createInstance Id 1]
		#puts [relformat $::raloo::test::A::Foo Foo]
		$n generate E1 date [clock format [clock seconds]]
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A start
	syncSleep
    } -result {born}

    test Lifecycle-1.6 {
	active class -- generating self directed events
    } -setup {
	Domain create A {
	    Class Foo {
		Attribute {
		    *Id int
		    Count int
		}

		Lifecycle {
		    State grow {date} {
			#puts "grow: $date"
			my with Count {
			    incr Count
			    my writeAttr Count $Count
			    if {$Count == 1} {
				my generate E1 date epoch
			    } else {
                                syncWake born
			    }
			}
		    }
		    Transition grow - E1 -> grow
		}
	    }
	    DomainOp start {} {
		set n [Foo createInstance Id 1 Count 0]
		#puts [relformat $::raloo::test::A::Foo Foo]
		$n generate E1 date [clock format [clock seconds]]
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A start
	syncSleep
    } -result {born}

    test Lifecycle-1.7 {
	active class -- generating delayed events
    } -setup {
	Domain create A {
	    Class Foo {
		Attribute {
		    *Id int
		}

		Lifecycle {
		    State born {date} {
			#puts "born: $date"
                        syncWake born
		    }
		    Transition born - E1 -> born
		}
	    }
	    DomainOp start {} {
		set n [Foo createInstance Id 1]
		$n generateDelayed 100 E1 date [clock format [clock seconds]]
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A start
	syncSleep
    } -result {born}

    test Lifecycle-1.8 {
	active class -- cancelling delayed events
    } -setup {
	Domain create A {
	    Class Foo {
		Attribute {
		    *Id int
		}

		Lifecycle {
		    State born {date} {
			#puts "born: $date"
                        syncWake born
		    }
		    Transition born - E1 -> born
		}
	    }
	    DomainOp start {} {
		set n [Foo createInstance Id 1]
		$n generateDelayed 100 E1 date [clock format [clock seconds]]
	    }
	    DomainOp stop {} {
		set n [Foo selectOne Id 1]
		$n cancelDelayed E1
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A start
	A stop
	llength $::raloo::arch::DelayQueue
    } -result {0}

    test Lifecycle-1.9 {
	active class -- query remaining time of event
    } -setup {
	Domain create A {
	    Class Foo {
		Attribute {
		    *Id int
		}

		Lifecycle {
		    State s1 {} {
                        syncWake born
		    }
		    Transition s1 - E1 -> s1
		}
	    }
	    DomainOp start {} {
		set f1 [Foo createInstance Id 1]
		$f1 generateDelayed 100 E1
		return [$f1 delayedRemaining E1]
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	set remain [A start]
	syncSleep
        set remain
    } -result {100}

    test Lifecycle-2.1 {
	polymorphic event
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *Name string
		}
	    }
	    Class SmallDog {
		Attribute {
		    *Name string
		}
		Lifecycle {
		    State barking {} {
			#puts "SmallDog: bark"
                        syncWake SmallDog
		    }
		    Transition barking - taunt -> barking
		}
	    }
	    Class BigDog {
		Attribute {
		    *Name string
		}
		Lifecycle {
		    State barking {} {
			#puts "BigDog: bark"
                        syncWake BigDog
		    }
		    Transition barking - taunt -> barking
		}
	    }
	    Generalization R1 Dog {
		SubType SmallDog
		SubType BigDog
	    }
	    Polymorphic Dog taunt {}
	    DomainOp start {} {
		set sd [Dog selectOne Name Poopsy]
		$sd generate taunt
	    }
	}
	A transaction {
	    Dog insert Name Poopsy
	    SmallDog insert Name Poopsy
	    Dog insert Name Rover
	    BigDog insert Name Rover
	}
    } -cleanup {
	A destroy
    } -body {
	A start
	syncSleep
    } -result {SmallDog}

    test Lifecycle-2.2 {
	polymorphic event inherited more than one level
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *Name string
		}
	    }
	    Class SmallDog {
		Attribute {
		    *Name string
		}
		Lifecycle {
		    State barking {} {
			#puts "SmallDog: bark"
                        syncWake SmallDog
		    }
		    Transition barking - taunt -> barking
		}
	    }
	    Class BigDog {
		Attribute {
		    *Name string
		}
	    }
	    Class WorkingDog {
		Attribute {
		    *Name string
		}
		Lifecycle {
		    State barking {} {
			#puts "WorkingDog: bark"
                        syncWake WorkingDog
		    }
		    Transition barking - taunt -> barking
		}
	    }
	    Class ShowDog {
		Attribute {
		    *Name string
		}
		Lifecycle {
		    State barking {} {
			#puts "ShowDog: bark"
                        syncWake ShowDog
		    }
		    Transition barking - taunt -> barking
		}
	    }
	    Generalization R1 Dog {
		SubType SmallDog
		SubType BigDog
	    }
	    Generalization R2 BigDog {
		SubType WorkingDog
		SubType ShowDog
	    }
	    Polymorphic Dog taunt {}
	    DomainOp start {} {
		set sd [Dog selectOne Name Rover]
		$sd generate taunt
	    }
	}
	A transaction {
	    Dog insert Name Poopsy
	    SmallDog insertInState barking Name Poopsy
	    Dog insert Name Rover
	    BigDog insert Name Rover
	    ShowDog insertInState barking Name Rover
	}
    } -cleanup {
	A destroy
    } -body {
	A start
	syncSleep
    } -result {ShowDog}

    test Lifecycle-3.1 {
	thread of control leaves data inconsistent
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Class Ownership {
		Attribute {
		    *DogName string
		    *OwnerName string
		}
	    }
	    AssocRelationship R1 Dog +-Ownership->+ Owner
	    DomainOp newDog {name} {
		Dog insert DogName $name
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A newDog Fred
	syncSleep
    } -result {for correlation ::raloo::test::A::R1(::raloo::test::A::Dog <== [+] ::raloo::test::A::Ownership [+] ==> ::raloo::test::A::Owner), in relvar ::raloo::test::A::Dog
tuple {DogName Fred} is not referenced by any tuple
} -returnCodes error

    test Lifecycle-3.2 {
	thread of control creates an error
    } -setup {
	Domain create A {
	    DomainOp op {} {
		error "thread of control error"
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A op
	syncSleep
    } -result {thread of control error} -returnCodes error

    test Lifecycle-4.1 {
	creation events
    } -setup {
	Domain create A {
	    Class Foo {
		Attribute {
		    *Id int
		}

		Lifecycle {
		    State A {} {
			#puts "A"
                        syncWake A
		    }
		    Transition @ - E1 -> A
		}
		DomainOp startFoo {} {
		    Foo generate {Id 1} E1
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A startFoo
	syncSleep
    } -result {A}

    test Polymorphic-1.1 {
	polymorphic event
    } -setup {
	Domain create A {
	    Class Super {
		Attribute {
		    *Id UNIQUE
		}
	    }
	    Class Sub1 {
		Attribute {
		    *Id UNIQUE
		}
		Lifecycle {
		    State s1 {} {
			#puts "in s1"
		    }
		    Transition s1 - E1 -> s1
		}
	    }
	    Class Sub2 {
		Attribute {
		    *Id UNIQUE
		}
		Lifecycle {
		    State s1 {} {
			#puts "in s1"
		    }
		    Transition s1 - E1 -> s1
		}
	    }
	    Generalization R1 Super {
		SubType Sub1
		SubType Sub2
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A define {
	    Polymorphic Super E1 {}
	}
	relation extract [relation choose $::raloo::mm::PolymorphicEvent\
	    DomName ::raloo::test::A ModelName Super EventName E1] EventName
    } -result {E1}

    test Assigner-1.1 {
	assigner state model
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Class Ownership {
		Attribute {
		    *DogName string
		    *OwnerName string
		}
	    }
	    AssocRelationship R1 Dog +-Ownership->+ Owner {
		Assigner {
		    State s1 {p1} {
			#puts "s1: $p1"
		    }
		    State s2 {} {
			#puts "s2"
		    }
		    Transition s1 - e1 -> s2
		    Transition s2 - e2 -> s1
		}
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	relation extract [relation choose $::raloo::mm::AssignerStateModel\
	    DomName ::raloo::test::A RelName R1] RelName
    } -result {R1}

    test Assigner-1.2 {
	generating an event to a single assigner state model
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Relationship R1 Dog +-->1 Owner {
		Assigner {
		    State s1 {p1} {
			#puts "s1: $p1"
                        syncWake s1
		    }
		    State s2 {} {
			#puts "s2"
                        syncWake s2
		    }
		    Transition s1 - e1 -> s2
		    Transition s2 - e2 -> s1
		}
	    }
	    DomainOp assignR1 {p} {
		R1 generate e1
	    }
	}
    } -cleanup {
	A destroy
    } -body {
	A assignR1 foo
	syncSleep
    } -result {s2}

    test Assigner-1.3 {
	generating an event to a multiple assigner state model
    } -setup {
	Domain create A {
	    Class Dog {
		Attribute {
		    *DogName string
		    OwnerName string
		}
	    }
	    Class Owner {
		Attribute {
		    *OwnerName string
		}
	    }
	    Relationship R1 Dog +-->1 Owner {
		Assigner {
		    IdentifyBy Dog
		    State s1 {p1} {
			#puts "s1: $p1"
                        syncWake s1
		    }
		    State s2 {} {
			#puts "s2"
                        syncWake s2
		    }
		    Transition s1 - e1 -> s2
		    Transition s2 - e2 -> s1
		}
	    }
	    DomainOp assignR1 {p} {
		set r1a [R1 selectOne DogName Fido]
		$r1a generate e1
	    }
	}
	A transaction {
	    Dog insert DogName Fido OwnerName John
	    Owner insert OwnerName John
	    R1 insert DogName Fido __CS__ s1
	}
    } -cleanup {
	A destroy
    } -body {
	A assignR1 foo
	syncSleep
    } -result {s2}

    cleanupTests
}

namespace delete ::raloo::test

if 0 {
    test X.1 {
    } -setup {
    } -cleanup {
    } -body {
    } -result {}
}
